<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL 索引</title>
      <link href="2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/"/>
      <url>2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p><strong>索引是存储引擎用于快速找到记录的一种数据结构</strong>。</p><blockquote><p>举例说明：如果查找一本书中的某个特定主题，一般会先看书的目录（类似索引），找到对应页面。在MySQL，存储引擎采用类似的方法使用索引，高效获取查找的数据。</p></blockquote><h1 id="索引底层数据结构-TODO"><a href="#索引底层数据结构-TODO" class="headerlink" title="索引底层数据结构(TODO)"></a>索引底层数据结构(TODO)</h1><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><ul><li><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li><p>无法用于排序与分组；</p></li><li><p>只支持精确查找，无法用于部分查找和范围查找。</p></li></ul></li><li><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p></li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul><li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</li><li>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</li><li>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</li><li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li></ul><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><ul><li>是大多数 MySQL 存储引擎的默认索引类型。</li><li>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li><li>除了用于查找，还可以用于排序和分组。</li><li>可以指定多个列作为索引列，多个索引列共同组成键。</li><li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li><li>InnoDB 的 B+Tree 索引分为主索引和辅助索引。<strong>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。</strong>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</li><li><strong>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</strong></li></ul><h1 id="MySQL是如何存储索引和数据的"><a href="#MySQL是如何存储索引和数据的" class="headerlink" title="MySQL是如何存储索引和数据的"></a>MySQL是如何存储索引和数据的</h1><p>Innodb 创建表后生成的文件有：</p><ul><li>frm:创建表的语句</li><li>idb:表里面的数据+索引文件</li></ul><p>Myisam 创建表后生成的文件有</p><ul><li>frm:创建表的语句</li><li>MYD:表里面的数据文件（myisam data）</li><li>MYI:表里面的索引文件（myisam index）</li></ul><h2 id="MYISAM存储引擎"><a href="#MYISAM存储引擎" class="headerlink" title="MYISAM存储引擎"></a>MYISAM存储引擎</h2><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h1 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引/非聚集索引"></a>聚集索引/非聚集索引</h1><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>参考：</p><p><a href="https://juejin.cn/post/6844904134261342216">https://juejin.cn/post/6844904134261342216</a></p><p><a href="https://juejin.cn/post/6844903843428319239">https://juejin.cn/post/6844903843428319239</a></p><p><a href="https://juejin.cn/post/6844904072089174023">https://juejin.cn/post/6844904072089174023</a></p><p><a href="https://zhuanlan.zhihu.com/p/113917726">https://zhuanlan.zhihu.com/p/113917726</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL InnoDB-锁</title>
      <link href="2021/01/17/database/mysql/mysql-%E9%94%81/"/>
      <url>2021/01/17/database/mysql/mysql-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h1><ul><li>共享锁、读锁（Shared (S) Lock）</li></ul><blockquote><p>持有行记录读锁的事物允许读取该行记录。</p></blockquote><ul><li>排他锁、写锁（ Exclusive (X) Lock）</li></ul><blockquote><p>持有行记录写锁的事物允许更新活删除该行记录。</p></blockquote><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h2 id="行锁（Record-Locks）"><a href="#行锁（Record-Locks）" class="headerlink" title="行锁（Record Locks）"></a>行锁（Record Locks）</h2><p>A record lock is a lock on an index record. For example, SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; prevents any other transaction from inserting, updating, or deleting rows where the value of t.c1 is 10.</p><blockquote><p>行锁是作用在索引记录上的。例如， SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;会防止其他事物对于t.c1=10的增、删、改。</p></blockquote><p>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking.</p><blockquote><p>行锁总是锁索引记录的，尽管没有创建索引，对于没有创建索引的情况，InnoDB创建一个隐藏的聚簇索引并用该索引来实现行锁。</p></blockquote><h2 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h2><p>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</p><blockquote><p>间隙锁是作用于索引记录之间或第一条索引记录之前或最后一条索引记录之后的锁。</p></blockquote><p>Gap locking is not needed for statements that lock rows using a unique index to search for a unique row.</p><blockquote><p>间隙锁不会作用于使用唯一索引去检索唯一行记录的情况。</p></blockquote><p>为什么会有间隙锁？</p><blockquote><p>防止幻读。（当前读）</p></blockquote><ul><li>下面这个语句加什么锁？已知条件MySQL5.7版本，InnoDB引擎，隔离级别RR。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from t where id &#x3D; 10;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对id = 10的记录加写锁 (走主键索引)。<strong>这个答案对吗？</strong><br> 可能是对的也有可能是错的，因为已知条件不足。缺少下列条件：<br> 1，id是否是主键？<br> 2，id列如果不是主键，那么id上是否有索引？<br> 3，id列上如果有二级索引，那么这个索引是否是唯一索引？<br> 4，id=10的记录是否存在？<br> 根据以下组合来判断加的锁：</p><ol><li>id列是主键，只对id = 10 的记录加X锁。</li></ol><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167e01a7d1a1ad5c" alt="img"> 2. id是唯一索引，并且id = 10 记录存在，对唯一索引id的B+Tree id = 10 的记录加行锁，同时对聚簇索引（主键索引）上对应id = 10 的主键 b 加X锁。 <img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167e035c8f4d3c22" alt="img"> 3. id是唯一索引，但是id = 10 的记录不存在，对唯一索引id的B+Tree id = 10 的空隙加就间隙锁，防止新的符合条件的记录插入，产生幻读，即锁住id索引树(8,b)至(15,c)之间的空间。</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167e03df48edc708" alt="img"> 4. id非唯一索引，首先对id的索引树符合id = 10的记录加X锁，并且对符合id = 10对应的主键索引记录加X锁，还要对id索引树可能插入id = 10 的位置加入间隙锁，也就是(6,a)至(10,b), (10,b)至(10,c), (10,c)至(17,d)。</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167e045226074411" alt="img"> 5. id无索引，这种是最恐怖的情况，对主键索引所有行记录加X锁，所有空隙加间隙锁，尽管MySQL对此有些优化，也不建议这样的方式，尤其是长事物，会使除了快照读的所有业务停摆。</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167e04bb1058085e" alt="img"></p><p>看下面几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;k&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_k&#96; (&#96;k&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">复制代码</span><br><span class="line">insert into t values(2,2),(6,6);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>MySQL5.7版本，InnoDB引擎，隔离级别是RR情况下，创建表t，其中id是主键，k是普通索引。</p><p><strong><em>问题1：其中语句 1、2、3可以插入吗？</em></strong></p><p>|事物A | 事物B|事物C|事物D<br>|–|–|–|–|–|<br>begin;|<br>select * from t where k=4 for update; ||||<br>| | 1, insert into t values (3,3);||<br>| | |2, insert into t values (4,4);|<br>| | | |3, insert into t values (5,5);<br>|commit; |</p><blockquote><p>是不能插入的，因为k是普通索引，所以会在索引 k 的B+树上 k=2 至 k=6 之间加上间隙锁，防止幻读。</p></blockquote><p><strong><em>问题2：其中语句 4、5、6、 7可以插入吗？</em></strong></p><table><thead><tr><th>事物A</th><th>事物B</th><th>事物C</th><th>事物D</th><th>事物E</th></tr></thead><tbody><tr><td>begin;</td><td></td><td></td><td></td><td></td></tr><tr><td>select * from t where k=4 for update;</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>4, insert into t values (1,2);</td><td></td><td></td><td></td></tr><tr><td></td><td>5, insert into t values (3,2);</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>6, insert into t values (5,6);</td><td></td><td></td></tr><tr><td></td><td></td><td>7, insert into t values (7,6);</td><td></td><td></td></tr><tr><td>commit;</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>其中语句 4, 7 是可以插入的，而语句 5, 6 是不能插入的。</p></blockquote><p>根据前面的加锁机制分析一下原因：<br> 首先，select * from t where k=4 for update，由于 k 是普通索引，所以在InnoDB引擎下，默认隔离级别RR情况下会加间隙锁防止新数据插入，防止幻读。加锁方式如下图：</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167df7d99f19812b" alt="img"> <strong><em>如果4, 5, 6, 7语句可以插入的话应该插入在什么位置呢？</em></strong><br> 请看下图：</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/167eab5ee346fb7b" alt="img"> 由于B+树索引有序排列，所以如果4、5、6、7均可以插入，位置应该插入普通索引k的B+Tree,如上图所示。从上图插入数据的位置就可以很明显的看出为什么语句5、6不能插入了。因为对于K索引树来说叶子节点存的是(k, id),除了要按k值排序，也要按照id排序，所以insert into t values (3,2)和insert into t values (5,6)插入的位置就落在了间隙锁的范围，所以是不能插入的，而insert into t values (1,2)和insert into t values (7,6)插入的位置落在间隙锁范围之外，所以可以插入。</p><ul><li>间隙锁到底锁的是什么？</li></ul><p>通过上面这个例子可以看出，其实间隙锁并没有完全锁住k=2和k=6记录的插入，也就是锁住的不是具体的值，而是所有可能插入新值k=4的位置，在本例中也就是(2,2)至(6,6)之间的位置，因为索引是有序排列的，所以k=4只能插入(2,2)至(6,6)之间。</p><ul><li>什么情况下产生间隙锁？</li></ul><ol><li>where条件后用非索引列约束的时候。</li><li>where后用非唯一索引列约束(等值搜索、字符串的最左前缀 <em>LIKE ‘张%’</em> )的时候。</li><li>where条件后用唯一索引、普通索引做范围查询时候( <em>&lt;、&lt;=、&gt;、&gt;=、between and</em> )。</li><li>对于多列联合唯一索引，如果查询没有包含所有列的等值查询也会产生间隙锁。例如，联合唯一索引column_1、cloumn_2、column_3的联合唯一索引，如果当前读语句是  ··· where column_1 = value_1 and cloumn_2 = value_2，则会产生间隙锁，因为没有包含column_3。</li><li>根据唯一索引<em>delete</em>、<em>update</em> 、<em>select ··· lock in share mode</em> 或 <em>select ··· for update</em>等值条件约束不存在的列的时候。</li></ol><p>参考：</p><p><a href="https://juejin.cn/post/6844903744417562638">https://juejin.cn/post/6844903744417562638</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 日志</title>
      <link href="2021/01/17/database/mysql/mysql-%E6%97%A5%E5%BF%97/"/>
      <url>2021/01/17/database/mysql/mysql-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>日志是<code>mysql</code>数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志(<code>binlog</code>)和事务日志(包括<code>redo log</code>和<code>undo log</code>)，本文接下来会详细介绍这三种日志。</p><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>错误日志文件对MySQL的启动，运行，关闭过程进行了记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| Variable_name | Value               |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| log_error     | &#x2F;var&#x2F;log&#x2F;mysqld.log |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>可以看到错误日志的路径和文件名，默认情况下错误文件的文件名为服务器的主机名，即：<code>hostname.err</code>。只不过我这里设置的是<code>/var/log/mysqld.log</code>,修改错误日志地址可以在<code>/etc/my.cnf</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Recommended in standard MySQL setup</span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br></pre></td></tr></table></figure><p>当出现MySQL数据库不能正常启动时，第一个必须查找的文件就是<strong>错误日志文件</strong>，该文件记录了出错信息，能够帮助我们找到问题。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录响应时间超过阈值的SQL语句，所以我们可以设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。该阈值可以通过参数  <code>long_query_time</code> 来设置，默认为10秒。</p><h2 id="启动慢查询日志"><a href="#启动慢查询日志" class="headerlink" title="启动慢查询日志"></a>启动慢查询日志</h2><p><strong>默认情况下，MySQL数据库并不启动慢查询日志，需要手动将这个参数设为ON，然后启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow%&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| log_slow_admin_statements | OFF                                             |</span><br><span class="line">| log_slow_slave_statements | OFF                                             |</span><br><span class="line">| slow_launch_time          | 2                                               |</span><br><span class="line">| slow_query_log            | OFF                                             |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;slow_query_log&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+                                        |</span><br><span class="line">| slow_query_log            | ON                                              |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">2   rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>**但是使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果MySQL数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf (其他系统变量也是如此)**，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log&#x3D;1</span><br></pre></td></tr></table></figure><p>然后重启MySQL就可以让慢查询日志记录开启了,至于日志文件的路径就是上面<code>slow_query_log_file</code>对应的路径。</p><h2 id="设置阈值"><a href="#设置阈值" class="headerlink" title="设置阈值"></a>设置阈值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>阈值默认为10秒，我们可以修改阈值大小，比如(当然这还是对当前数据库有效)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time&#x3D;0.05;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>设置<code>long_query_time</code>这个阈值之后，MySQL数据库会记录运行时间超过该值的所有SQL语句，但对于运行时间正好等于 <code>long_query_time</code> 的情况，并不会被记录下。而设置 <code>long_query_time</code>为0来捕获所有的查询</p><h2 id="参数log-queries-not-using-indexes"><a href="#参数log-queries-not-using-indexes" class="headerlink" title="参数log_queries_not_using_indexes"></a>参数log_queries_not_using_indexes</h2><p><strong>另一个和慢查询日志有关的参数是 log_queries_not_using_indexes</strong>, 如果运行的SQL语句没有使用索引，则MySQL数据库同样会将这条SQL语句记录到慢查询日志文件。首先确认打开了log_queries_not_using_indexes;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | ON    |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">1 row in set (0.12 sec)</span><br></pre></td></tr></table></figure><p>例子，没有用到索引进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from vote_record_memory where vote_id &#x3D; 323;</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table              | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | vote_record_memory | ALL  | NULL          | NULL | NULL    | NULL | 149272 | Using where |</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">1 row in set (1.56 sec)</span><br></pre></td></tr></table></figure><p>可以看到是进行了全表扫描； 然后去log日志文件中查看这条SQL已经被标记为慢SQL，因为它没有使用索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Time: 180817 11:42:59</span><br><span class="line"># User@Host: root[root] @  [117.136.86.151]  Id:  2625</span><br><span class="line"># Query_time: 0.016542  Lock_time: 0.000112 Rows_sent: 142  Rows_examined: 149272</span><br><span class="line">SET timestamp&#x3D;1534477379;</span><br><span class="line">select * from vote_record_memory where vote_id &#x3D; 323;</span><br></pre></td></tr></table></figure><h2 id="将日志记录放入表中"><a href="#将日志记录放入表中" class="headerlink" title="将日志记录放入表中"></a>将日志记录放入表中</h2><p>MySQL5.1开始可以将慢查询的日志记录放入一张表中，在mysql数据库下，名为slow_log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| slow_log | CREATE TABLE &#96;slow_log&#96; (</span><br><span class="line">  &#96;start_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  &#96;user_host&#96; mediumtext NOT NULL,</span><br><span class="line">  &#96;query_time&#96; time NOT NULL,</span><br><span class="line">  &#96;lock_time&#96; time NOT NULL,</span><br><span class="line">  &#96;rows_sent&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;rows_examined&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;db&#96; varchar(512) NOT NULL,</span><br><span class="line">  &#96;last_insert_id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;insert_id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;server_id&#96; int(10) unsigned NOT NULL,</span><br><span class="line">  &#96;sql_text&#96; mediumtext NOT NULL,</span><br><span class="line">  &#96;thread_id&#96; bigint(21) unsigned NOT NULL</span><br><span class="line">) ENGINE&#x3D;CSV DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;Slow log&#39; |</span><br></pre></td></tr></table></figure><p>参数<code>log_output</code>指定了慢查询输出的格式，默认为file,可以将它设置成table，将变成了上面的slow_log中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;log_output&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_output    | FILE  |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p><strong>但是多数情况下这样做没什么必要，这不但对性能有较大影响，而且 MySQL 5.1 在将慢查询记录到文件中时已经支持微秒级别的信息，然而将慢查询记录到表中会导致时间粒度退化为只能到秒级，而秒级别的慢查询日志没有太大的意义</strong></p><h2 id="慢查询日志分析工具"><a href="#慢查询日志分析工具" class="headerlink" title="慢查询日志分析工具"></a>慢查询日志分析工具</h2><h3 id="mysqldumpslo3w命令"><a href="#mysqldumpslo3w命令" class="headerlink" title="mysqldumpslo3w命令"></a>mysqldumpslo3w命令</h3><p>当越来越多的SQL查询被记录到慢查询日志文件中，这时候直接看日志文件就不容易了，MySQL提供了<code>mysqldumpslow</code> 命令解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zeaf3cg1099kiidi06mz mysql]# mysqldumpslow iz2zeaf3cg1099kiidi06mz-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from iz2zeaf3cg1099kiidi06mz-slow.log</span><br><span class="line">Count: 1  Time&#x3D;60.02s (60s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;149272.0 (149272), root[root]@[117.136.86.151]</span><br><span class="line">  select * from vote_record_memory</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;14.85s (14s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;0.0 (0), root[root]@[117.136.86.151]</span><br><span class="line">  CALL add_vote_memory(N)</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;1.72s (1s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;0.0 (0), root[root]@[117.136.86.151]</span><br><span class="line">  INSERT into vote_record SELECT * from  vote_record_memory</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;0.02s (0s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;142.0 (142), root[root]@[117.136.86.151]</span><br><span class="line">  select * from vote_record_memory where vote_id &#x3D; N</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多关于 <code>mysqldumpslow</code> 命令的介绍，请参阅 ：<a href="https://github.com/luisedware/Archives/issues/7">mysqldumpslow 的参数讲解与基础使用</a></p><h3 id="pt-query-digest-工具"><a href="#pt-query-digest-工具" class="headerlink" title="pt-query-digest 工具"></a>pt-query-digest 工具</h3><p>pt-query-digest 是分析MySQL查询日志最有力的工具，该工具功能强大，它可以分析binlog，Generallog，slowlog，也可以通过<code>show processlist</code>或者通过 <code>tcpdump</code> 抓取的MySQL协议数据来进行分析，比 mysqldumpslow 更具体，更完善。以下是使用pt-query-digest的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接分析慢查询文件</span><br><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该工具可以将查询的剖析报告打印出来，可以分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间，次数，占比等，可以借助分析结果找出问题进行优化。更多关于pt-query-digest的安装与使用，请参阅 : <a href="http://www.ywnds.com/?p=8179">www.ywnds.com/?p=8179</a></p></blockquote><h1 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h1><p>查看日志记录了所有对 MySQL 数据库请求的信息，不论这些请求是否得到了正确的执行。默认为 <code>主机名.log</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;general_log%&quot;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | OFF                                        |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">2 rows in set (0.24 sec)   </span><br></pre></td></tr></table></figure><p>默认情况下不启动查询日志，必须要先开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global general_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;general_log%&quot;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | ON                                         |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">2 rows in set (0.11 sec)</span><br></pre></td></tr></table></figure><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p><code>binlog</code>用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code>是<code>mysql</code>的逻辑日志，并且由<code>Server</code>层进行记录，使用任何存储引擎的<code>mysql</code>数据库都会记录<code>binlog</code>日志。</p><blockquote><p>逻辑日志：<strong>可以简单理解为记录的就是sql语句</strong>。</p></blockquote><blockquote><p>物理日志：<strong>因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更</strong>。</p></blockquote><p><code>binlog</code>是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code>参数设置每个<code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><h2 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a>binlog使用场景</h2><p>在实际应用中，<code>binlog</code>的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p><ol><li><strong>主从复制</strong>：在<code>Master</code>端开启<code>binlog</code>，然后将<code>binlog</code>发送到各个<code>Slave</code>端，<code>Slave</code>端重放<code>binlog</code>从而达到主从数据一致。</li><li><strong>数据恢复</strong>：通过使用<code>mysqlbinlog</code>工具来恢复数据。</li></ol><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><p>对于<code>InnoDB</code>存储引擎而言，只有在事务提交时才会记录<code>biglog</code>，此时记录还在内存中，那么<code>biglog</code>是什么时候刷到磁盘中的呢？<code>mysql</code>通过<code>sync_binlog</code>参数控制<code>biglog</code>的刷盘时机，取值范围是<code>0-N</code>：</p><ul><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：每次<code>commit</code>的时候都要将<code>binlog</code>写入磁盘；</li><li>N：每N个事务，才会将<code>binlog</code>写入磁盘。</li></ul><p>从上面可以看出，<code>sync_binlog</code>最安全的是设置是<code>1</code>，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p><h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p><code>binlog</code>日志有三种格式，分别为<code>STATMENT</code>、<code>ROW</code>和<code>MIXED</code>。</p><blockquote><p>在 <code>MySQL 5.7.7</code>之前，默认的格式是<code>STATEMENT</code>，<code>MySQL 5.7.7</code>之后，默认值是<code>ROW</code>。日志格式通过<code>binlog-format</code>指定。</p></blockquote><ul><li><code>STATMENT</code> <strong>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中</strong>。 优点：<strong>不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能</strong>； 缺点：<strong>在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</strong>。</li><li><code>ROW</code> <strong>基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了</strong>。 优点：<strong>不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题</strong>； 缺点：<strong>会产生大量的日志，尤其是alter table的时候会让日志暴涨</strong></li><li><code>MIXED</code> <strong>基于STATMENT和ROW两种模式的混合复制(mixed-based replication, MBR)，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog</strong></li></ul><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h2><p>我们都知道，事务的四大特性里面有一个是<strong>持久性</strong>，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong>。那么<code>mysql</code>是如何保证持久性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p><ol><li>因为<code>Innodb</code>是以<code>页</code>为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li></ol><p>因此<code>mysql</code>设计了<code>redo log</code>，<strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p><h2 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a>redo log基本概念</h2><p><code>redo log</code>包括两部分：一个是内存中的日志缓冲(<code>redo log buffer</code>)，另一个是磁盘上的日志文件(<code>redo log file</code>)。<code>mysql</code>每执行一条<code>DML</code>语句，先将记录写入<code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到<code>redo log file</code>。这种<strong>先写日志，再写磁盘</strong>的技术就是<code>MySQL</code>里经常说到的<code>WAL(Write-Ahead Logging)</code> 技术。</p><p>在计算机操作系统中，用户空间(<code>user space</code>)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(<code>kernel space</code>)缓冲区(<code>OS Buffer</code>)。因此，<code>redo log buffer</code>写入<code>redo log file</code>实际上是先写入<code>OS Buffer</code>，然后再通过系统调用<code>fsync()</code>将其刷到<code>redo log file</code>中，过程如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc4395ebadf4dbd87e1c64a6bdb68e0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>mysql</code>支持三种将<code>redo log buffer</code>写入<code>redo log file</code>的时机，可以通过<code>innodb_flush_log_at_trx_commit</code>参数配置，各参数值含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>事务提交时不会将<code>redo log buffer</code>中日志写入到<code>os buffer</code>，而是每秒写入<code>os buffer</code>并调用<code>fsync()</code>写入到<code>redo log file</code>中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</td></tr><tr><td>1（实时写，实时刷）</td><td>事务每次提交都会将<code>redo log buffer</code>中的日志写入<code>os buffer</code>并调用<code>fsync()</code>刷到<code>redo log file</code>中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次提交都仅写入到<code>os buffer</code>，然后是每秒调用<code>fsync()</code>将<code>os buffer</code>中的日志写入到<code>redo log file</code>。</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfbc08983004721bfa445ea3cc9777d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a>redo log记录形式</h2><p>前面说过，<code>redo log</code>实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此<code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd580611e99442a8037c9b5f0b519bc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>同时我们很容易得知，<strong>在innodb中，既有redo log需要刷盘，还有数据页也需要刷盘，redo log存在的意义主要就是降低对数据页刷盘的要求</strong>。在上图中，<code>write pos</code>表示<code>redo log</code>当前记录的<code>LSN</code>(逻辑序列号)位置，<code>check point</code>表示<strong>数据页更改记录</strong>刷盘后对应<code>redo log</code>所处的<code>LSN</code>(逻辑序列号)位置。<code>write pos</code>到<code>check point</code>之间的部分是<code>redo log</code>空着的部分，用于记录新的记录；<code>check point</code>到<code>write pos</code>之间是<code>redo log</code>待落盘的数据页更改记录。当<code>write pos</code>追上<code>check point</code>时，会先推动<code>check point</code>向前移动，空出位置再记录新的日志。</p><p>启动<code>innodb</code>的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为<code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如<code>binlog</code>)要快很多。 重启<code>innodb</code>时，首先会检查磁盘中数据页的<code>LSN</code>，如果数据页的<code>LSN</code>小于日志中的<code>LSN</code>，则会从<code>checkpoint</code>开始恢复。 还有一种情况，在宕机前正处于<code>checkpoint</code>的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的<code>LSN</code>大于日志中的<code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p><h2 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h2><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>文件大小</td><td><code>redo log</code>的大小是固定的。</td><td><code>binlog</code>可通过配置参数<code>max_binlog_size</code>设置每个<code>binlog</code>文件的大小。</td></tr><tr><td>实现方式</td><td><code>redo log</code>是<code>InnoDB</code>引擎层实现的，并不是所有引擎都有。</td><td><code>binlog</code>是<code>Server</code>层实现的，所有引擎都可以使用 <code>binlog</code>日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>适用场景</td><td><code>redo log</code>适用于崩溃恢复(crash-safe)</td><td><code>binlog</code>适用于主从复制和数据恢复</td></tr></tbody></table><p>由<code>binlog</code>和<code>redo log</code>的区别可知：<code>binlog</code>日志只用于归档，只依靠<code>binlog</code>是没有<code>crash-safe</code>能力的。但只有<code>redo log</code>也不行，因为<code>redo log</code>是<code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要<code>binlog</code>和<code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>数据库事务四大特性中有一个是<strong>原子性</strong>，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。实际上，<strong>原子性</strong>底层就是通过<code>undo log</code>实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条<code>INSERT</code>语句，对应一条<code>DELETE</code>的<code>undo log</code>，对于每个<code>UPDATE</code>语句，对应一条相反的<code>UPDATE</code>的<code>undo log</code>，这样在发生错误时，就能回滚到事务之前的数据状态。同时，<code>undo log</code>也是<code>MVCC</code>(多版本并发控制)实现的关键，这部分内容在<a href="https://juejin.im/post/6855129007336521741">面试中的老大难-mysql事务和锁，一次性讲清楚！</a>中有介绍，不再赘述。</p><p>参考：</p><p><a href="https://juejin.cn/post/6844903662888697864">https://juejin.cn/post/6844903662888697864</a></p><p><a href="https://juejin.cn/post/6860252224930070536">https://juejin.cn/post/6860252224930070536</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL explain详解</title>
      <link href="2021/01/17/database/mysql/mysql-explain%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/01/17/database/mysql/mysql-explain%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Explain命令-关键字"><a href="#Explain命令-关键字" class="headerlink" title="Explain命令(关键字)"></a>Explain命令(关键字)</h1><h2 id="explain简单示例"><a href="#explain简单示例" class="headerlink" title="explain简单示例"></a>explain简单示例</h2><p><img src="/2021/01/17/database/mysql/mysql-explain%E8%AF%A6%E8%A7%A3/1611820132873.png" alt="1611820132873"></p><blockquote><p>在查询中的每个”表”会输出一行，这里的“表”的意义非常广泛，不仅仅是数据库表，还可以是子查询、一个union 结果等。</p></blockquote><h2 id="explain结果列说明"><a href="#explain结果列说明" class="headerlink" title="explain结果列说明"></a>explain结果列说明</h2><h3 id="【id列】"><a href="#【id列】" class="headerlink" title="【id列】"></a>【id列】</h3><ul><li>id 列是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。</li><li>id 的顺序是按 select 出现的顺序增长的。</li><li>id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id列的值为NULL最后执行。</li></ul><h3 id="【select-type列】"><a href="#【select-type列】" class="headerlink" title="【select_type列】"></a>【select_type列】</h3><ul><li>select_type列的值标明查询的类型：<ul><li>simple：表明当前行对应的select是简单查询，不包含子查询和union</li><li>primary：表明当前行对应的select是复杂查询中最外层的 select</li><li>subquery：表明当前行对应的select是包含在 select 中的子查询（不在 from 子句中）</li><li>derived：表明当前行对应的select是包含在 from 子句中的子查询。</li></ul></li></ul><p>MySQL会创建一个临时表来存放子查询的查询结果。用如下的语句示例说明：</p><p>explain select (select 1 fromt_user where user_id=1) from (select * from t_group where group_id=1) tmp;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86b790131c14981a666ae62658b766a~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>*注意，在资料收集过程中，发现不同版本的MySQL表现不一致，经反复对比，5.7及以后版本的输出如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef3e37ff6128454eb03cafed9bf0d6b2~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>很显然，MySQL在这方面进行了优化.</p><p>*注意，MySQL不同版本Explain表现差异很大，有些场景，从语句层面看，是要使用到索引，但经过优化器分析，结合表中现有数据，如果MySQL认为全表扫描性能更优，则会使用全表扫描。</p><p>5）union：表明当前行对应的select是在 union 中的第二个和随后的 select</p><p>6）union result：表明当前行对应的select是从 union 临时表检索结果的 select</p><p>explain select 1 union all select 2 fromdual;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03afcc789ca047e7ba09a1a67736205d~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>MySQL5.7及以后同样做了优化</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8ca7daa833549d0a4c83bb6d3080b93~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><h3 id="【table列】"><a href="#【table列】" class="headerlink" title="【table列】"></a>【table列】</h3><p>table列的结果表明当前行对应的select正在访问哪个表。当查询的子句中有子查询时，table列是  格式，表示当前的select依赖 id=N结果行对应的查询，要先执行 id序号=N 的查询。当存在 union 时，UNION RESULT 的 table 列的值为&lt;unionN1,N2&gt;，N1和N2表示参与 union 的select 行的id序号。</p><h3 id="【type列】"><a href="#【type列】" class="headerlink" title="【type列】"></a>【type列】</h3><p>type列的结果表明当前行对应的select的关联类型或访问类型，也就是优化器决定怎么查找数据表中的行，以及查找数据行记录的大概范围。该列的取值优化程度的优劣，从最优到最差依次为：null&gt;system&gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。一般来说，要保证查询达到range级别，最好达到ref。</p><p>1）null，MySQL优化器在优化阶段分解查询语句，在优化过程中就已经可以得到结果，那么在执行阶段就不用再访问表或索引。</p><p>explain select min(user_id) from t_user;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8473e4e550034a29b6f6ff1828c9920e~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>这时的函数min，在索引列user_id中选取最小值，可以直接查找索引来完成，不需要执行时再访问数据表。</p><p>2）const和system：const出现在用 primary key（主键） 或 unique key（唯一键） 的所有列与常数比较时，优化器对查询进行优化并将其部分查询转化成一个常量。最多有一个匹配行，读取1次，速度非常快。而system是const的特例，表中数据只有一条匹配时为system。此时可以用explain extended+show warnings查看执行结果。</p><p>explain extended select * from (select * from t_user where user_id = 1) tmp;</p><p>show warnings;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/427b9dc99e734b0ca81c235b315497e1~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e24360a2995455eb959dbf89dd14ffc~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>MySQL5.7及以后版本优化后：</p><p>![什么是MySQL的执行计划（Explain关键字）？](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"/>)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f8d0e9bb4394cf981a45b1550997c29~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>3）eq_ref：primary key（主键）或 unique key（唯一键） 索引的所有构成部分被join使用 ，只会返回一条符合条件的数据行。这是仅次于const的连接类型。</p><p>explain select * from t_group_user gu left join t_group g ong.group_id = gu.group_id;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fab8585a1014329b53ba5c3dcc7639f~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><ol><li>ref：与eq_ref相比，ref类型不是使用primary key（主键） 或 unique key（唯一键）等唯一索引，而是使用普通索引或者联合唯一性索引的部分前缀，索引和某个值相比较，可能会找到符合条件的多个数据行。</li></ol><p>\1. 如下示例，使用的group_name是普通索引</p><p>explain select * from t_group where group_name= ‘group1’;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b5642927e9e43ae9967725a1f745c63~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>2.关联表查询</p><p>explain select g.group_id from t_group gleft join t_group_user gu on gu.group_id = g.group_id;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d96b1385344a1990475e4abdfce79a~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>5）range：出现在 in(),between ,&gt; ,&lt;, &gt;= 等操作符中。使用一个索引来查询给定范围的行。</p><p>6）index：扫描全表索引（index是从索引中读取的,所有字段都有索引，而all是从硬盘中读取），比ALL要快。</p><p>explain select * from t_group;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60db736b28254fc2acf4a5feb867ea7f~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>7）all：即全表扫描，需要从头到尾去查找所需要的行。一般这种情况下这需要增加索引来进行查询优化了</p><p>explain select * from t_user;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86b76d71a622405ebf32950b87d38413~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><h3 id="【possible-keys列】"><a href="#【possible-keys列】" class="headerlink" title="【possible_keys列】"></a>【possible_keys列】</h3><p>这一列的结果表明查询可能使用到哪些索引。但有些时候也会出现出现possible_keys 列有结果，而 后面的key列显示 null 的情况，这是因为此时表中数据不多，优化器认为查询索引对查询帮助不大，所以没有走索引查询而是进行了全表扫描。</p><p>如果possible_keys列的结果是null，则表明没有相关的索引。这时，可以通过优化where子句，增加恰当的索引来提升查询性能。</p><h3 id="【key列】"><a href="#【key列】" class="headerlink" title="【key列】"></a>【key列】</h3><p>这一列表明优化器实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 null。</p><h3 id="【key-len列】"><a href="#【key-len列】" class="headerlink" title="【key_len列】"></a>【key_len列】</h3><p>这一列表明了在索引里使用的字节数，通过这个值可以大致估算出具体使用了联合索引中的前几个列。</p><p>key_len计算规则这里不再赘述，不同的数据类型所占的字节数是不一致的。</p><h3 id="【ref列】"><a href="#【ref列】" class="headerlink" title="【ref列】"></a>【ref列】</h3><p>这一列表明了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名，如user.user_id</p><h3 id="【rows列】"><a href="#【rows列】" class="headerlink" title="【rows列】"></a>【rows列】</h3><p>这一列表明优化器大概要读取并检测的行数。跟实际的数据行数大部分情况是不一致的。</p><h3 id="【Extra列】"><a href="#【Extra列】" class="headerlink" title="【Extra列】"></a>【Extra列】</h3><p>顾名思义，这一列表明的是额外信息,这一列的取值对优化SQL非常有参考意义。常见的重要取值如下：</p><p>1）using index：所有被查询的字段都是索引列(称为覆盖索引),并且where条件是索引的前导列，出现这样的结果，是性能高的表现。</p><p>explainselect group_id,group_name from t_group;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7781181d7da8427aba349f88bbc65e24~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>2）using where：被查询的列未被索引覆盖，where条件也并非索引的前导列，表示 MySQL 执行器从存储引擎接收到查询数据,再进行“后过滤”（Post-filter）。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。</p><p>explain select * from t_user whereuser_name=’user1’;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d6d7306e0f49cab730c5e4fdcb240b~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>3）using where Using index：被查询的列被索引覆盖，并且where条件是索引列之一但是不是索引的前导列，也就是没有办法直接通过索引来查询到符合条件的数据</p><p>explain select * from t_group where group_name = ‘group1’;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2980ab6376e64998a09c16b4f928d811~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>4）null：被查询的列没有被索引覆盖，但where条件是索引的前导列，此时用到了索引，但是部分列未被索引覆盖，必须通过“回表查询”来实现，不是纯粹地用到了索引，也不是完全没用到索引</p><p>explain select * from t_user where user_id=’1’;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59bb02b737e44cf1a133562f8fc2bf48~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>5）using index condition：与using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；这种情况未能通过示例显现，可能跟MySQL版本有关系。</p><p>6） using temporary：这表明需要通过创建临时表来处理查询。出现这种情况一般是要进行优化的，用索引来优化。创建临时表的情况：distinct，group by，orderby，子查询等</p><p>explain select distinct user_name from t_user;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57cd61274e7c4a64b4f7d3cf22953035~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>explain select distinct group_name fromt_group; –group_name是索引列</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f062a6ec67342a5a4e9a23069b0fefb~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><ol><li>usingfilesort：在使用order by的情况下出现，mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据连接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下要考虑使用索引来优化的。</li></ol><p>explain select * from t_user orderby user_name;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85e75e3ba6fb41f997b0e4a9c78e00c1~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>explain select * from t_group order bygroup_name; –group_name是索引列</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b11f3b828ca14fddae669a18d79acf23~tplv-k3u1fbpfcp-zoom-1.image" alt="什么是MySQL的执行计划（Explain关键字）？"></p><p>参考：</p><p><a href="https://juejin.cn/post/6898356430802255879">https://juejin.cn/post/6898356430802255879</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务</title>
      <link href="2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要事务"><a href="#为什么要事务" class="headerlink" title="为什么要事务"></a>为什么要事务</h1><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><ul><li><p>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库在异常状态下仍能保持一致性的方法。</p></li><li><p>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，保证彼此的操作互相干扰。</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>​        简单的说，事务就是一组原子性的 SQL 查询，这一组 SQL 要么全部执行成功，要么全部执行失败。</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul><li><p><strong>原子性</strong>：一个事务是不可分割的最小工作单元，整个事务要么全部成功，要么全部失败，不可能只执行中间的一部分操作。</p></li><li><p><strong>一致性</strong>：执行事务是使得数据库从一个一致性状态到另一个一致性状态，如果事务最终没有被提交，那么事务所做的修改也不会保存到数据库中。</p></li><li><p><strong>隔离性</strong>：通常来说，一个事务提交之前对其他事务是不可见的，但是这里所说的不可见需要考虑隔离级别，比如未提交读在提交前对于其他事务来说也是可见的，隔离级别，在下面会详细讲。</p></li><li><p><strong>持久性</strong>：事务一旦被提交，那么对数据库的修改会被永久的保存，即使数据库崩溃修改后的数据也不会丢失。</p></li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读 ( Read uncommited )</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交读 ( Read commited )</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读 ( Repeatable read )</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化 ( Serializable )</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li><p>多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。<strong>SQL 标准中定义了四种隔离级别</strong>，这里简单介绍一下这四种隔离级别。</p><ul><li><strong>未提交读</strong>：未提交读的意思是，事务中的修改，即使没有提交，对其他事务也都是可见的，但是这样会出现脏读，一般情况下，通常都不会使用未提交读。</li><li><strong>提交读</strong>：提交读的意思是，一个事务所做的修改在提交之前对其他事务都是不可见的，这个级别也叫做“不可重复读”，因为执行两次相同的操作，可能会得到不同的结果。</li><li><strong>可重复读</strong>：可重复读解决了脏读的问题，这个级别保证了同一个事务多次读取同样记录的结果是一致的，但是这个隔离级别无法解决幻读的问题，所谓幻读就是说，当某个事务读取范围数据时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围数据时，会产生幻行。InnoDB 存储引擎通过 MVCC 解决了幻读的问题，可重复读是 MySQL 默认的事务隔离级别。</li><li><strong>可串行化</strong>：是最高的隔离级别，避免了前面说到的幻读问题。可串行化会给读取的每一行都加锁，所以可能导致大量超时和锁争用的问题，实际中很少使用这个隔离级别。</li></ul></li><li><p>事务不考虑隔离性可能会引发的问题</p><ul><li><strong>脏读</strong>：指一个事务读取了另外一个事务未提交的数据</li><li><strong>不可重复读</strong>：指在一个事务内读取表中的某一行数据，多次读取结果不同。</li><li>**虚读(幻读)**：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</li></ul></li></ul><h2 id="MySQL-数据库中操作事务的命令"><a href="#MySQL-数据库中操作事务的命令" class="headerlink" title="MySQL 数据库中操作事务的命令"></a>MySQL 数据库中操作事务的命令</h2><ul><li>开启事务：start transaction</li><li>提交事务：commit </li><li>回滚事务：rollback </li></ul><blockquote><ul><li>默认情况下， MySQL 事务是自动提交（Autocommit）的，若果需要明确的 Commit 和 Rollback 来提交和回滚事务，那么就需要明确的事务控制命令来开始事务。</li><li>SET AUTOCOMMIT 可以修改当前连接的提交方式，如果设置了 set autocommi t= 0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。</li><li>如果只是对某些语句需要进行事务控制，则使用 start transaction 语句开始一个事务比较方便，这样事务结束之后可以自动回到自动提交的方式，如果希望所有的事务都不是自动提交的，那么通过修改 AUTOCOMMIT 来控制事务比较方便，这样不用在每个事务开始的时候再执行 start transaction。</li></ul></blockquote><h2 id="事务隔离级别验证"><a href="#事务隔离级别验证" class="headerlink" title="事务隔离级别验证"></a>事务隔离级别验证</h2><h3 id="准备表"><a href="#准备表" class="headerlink" title="准备表"></a>准备表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建账户表</span><br><span class="line">CREATE TABLE &#96;t_account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;money&#96; float DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>验证事务隔离级别可能需要用到的 sql 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 设置 RU（未提交读）</span><br><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">-- 设置 RC（已提交读）</span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line">-- 设置 RR（可重复读）</span><br><span class="line">set session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line">select @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">commit;</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">-- 查询与关闭事务自动提交</span><br><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line">set @@autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">select * from t_account;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;1&#39;, &#39;A&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;2&#39;, &#39;B&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;3&#39;, &#39;C&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br><span class="line">UPDATE t_account set money &#x3D; money - 100 where id &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="未提交读（RU）"><a href="#未提交读（RU）" class="headerlink" title="未提交读（RU）"></a>未提交读（RU）</h3><table><thead><tr><th align="left">会话1</th><th align="left">会话2</th></tr></thead><tbody><tr><td align="left">设置隔离级别</td><td align="left">设置隔离级别</td></tr><tr><td align="left">开启事务</td><td align="left">开启事务</td></tr><tr><td align="left"></td><td align="left">查询表数据（结果为空）</td></tr><tr><td align="left">插入数据</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">查询表数据（有 “会话1” 的插入结果）</td></tr><tr><td align="left">回滚事务</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">查询数据（结果为空）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611658431742.png" alt="1611658431742"></p><blockquote><p>小结：</p><p>​        在RU模式下，一个事务可以读取到另一个未提交事务的数据，导致了脏读。如果另一个事务回滚了，就会造成数据的不一致性。RU是事务隔离级别中最低的。</p></blockquote><h3 id="读提交（RC）"><a href="#读提交（RC）" class="headerlink" title="读提交（RC）"></a>读提交（RC）</h3><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>设置隔离级别</td><td>设置隔离级别</td></tr><tr><td>开启事务</td><td>开启事务（先开启事务）</td></tr><tr><td>查询数据</td><td>查询数据</td></tr><tr><td>修改数据</td><td></td></tr><tr><td>查询数据（数据改变）</td><td>查询数据（数据无改变）</td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>查询数据（数据改变）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611659480293.png" alt="1611659480293"></p><blockquote><p>小结：</p><p>​        在RC模式下，我们发现，当另一个事务没有提交数据修改时，当前事务时读不到修改后的数据的，这就避免了读未提交模式的脏读。但有一个问题，在当前事务中，两次select的数据不一样，这就存在了不可重复读的问题。</p><p>​        PS：RC隔离级别是Oracle数据库默认的隔离级别。</p></blockquote><h3 id="可重复读（RR）"><a href="#可重复读（RR）" class="headerlink" title="可重复读（RR）"></a>可重复读（RR）</h3><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>设置隔离级别</td><td>设置隔离级别</td></tr><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>查询数据</td><td>查询数据</td></tr><tr><td>修改数据</td><td></td></tr><tr><td></td><td>查询数据（数据无改变）</td></tr><tr><td>修改数据</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>查询数据（数据无改变）</td></tr><tr><td></td><td>提交事务</td></tr><tr><td></td><td>查询数据（数据改变）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611645479829.png" alt="1611645479829"></p><blockquote><p>小结：</p><p>​        在 RR 模式下，我们解决了不可重复读的问题，即在这种隔离级别下，一个事务中我们能够保证获取一样的数据（即使有其他事务正在改当前的数据行）。但是无法避免幻读，<strong>幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致</strong>但是不同数据库对不同的RR级别有不同的实现，有时候加上间隙锁来避免幻读。</p></blockquote><h3 id="InnoDB解决了幻读"><a href="#InnoDB解决了幻读" class="headerlink" title="InnoDB解决了幻读"></a>InnoDB解决了幻读</h3><blockquote><p><strong>在RR的隔离级别下</strong>，InnoDB使用MVCC和next-key locks(间隙锁)解决幻读。MVCC解决的是普通读（快照读）的幻读，间隙锁解决的是当前读情况下的幻读。</p></blockquote><h4 id="幻读是什么"><a href="#幻读是什么" class="headerlink" title="幻读是什么"></a>幻读是什么</h4><blockquote><p>​    幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。</p></blockquote><p><strong>以下是修改情况下的幻读问题</strong>： mvcc 默认解决了读情况下的幻读，但是未解决修改情况下的幻读。</p><blockquote><p>幻读现象：事务2中没有id为4的数据，但是能修改成功。</p></blockquote><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611662492067.png" alt="1611662492067"></p><h4 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h4><ul><li>不可重复读：多次读取一条记录，发现该记录中某些列值被修改过。</li><li>幻读：只要是说多次读取一个范围内的记录（包括直接查询所有记录结果或者做聚合统计），发现结果不一致（一般指的是记录增多，记录的减少应该也算是幻读）。</li></ul><h4 id="避免幻读"><a href="#避免幻读" class="headerlink" title="避免幻读"></a>避免幻读</h4><h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><blockquote><p>​        多版本并发控制( Multi-Version Concurrency Control , MVCC ) 是 MySQL 中基于乐观锁理论实现隔离级别的方式，用于实现读已提交和可重复读取隔离级别的实现。 MVCC 可以看做是行锁的一个变种，在很多情况下 MVCC 可以避免加锁，因此开销更小，不同事务型存储引擎对于 MVCC 的实现各有不同。 <strong>MVCC 的实现是通过保存数据在某个时间点的快照来实现的</strong>。也就是说，不管执行多长时间，每个事务看到的数据都是一致的。根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p></blockquote><h6 id="InnoDB-的-MVCC-实现-隔离级别为可重复读"><a href="#InnoDB-的-MVCC-实现-隔离级别为可重复读" class="headerlink" title="InnoDB 的 MVCC 实现(隔离级别为可重复读)"></a>InnoDB 的 MVCC 实现(隔离级别为可重复读)</h6><p>在说到如何实现前先引入两个概念：</p><blockquote><ul><li><p>系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p></li><li><p>事务版本号：事务开始时的系统版本号。</p></li></ul></blockquote><p>在MySQL中，会在表中每一条数据后面添加两个字段：</p><blockquote><ul><li>创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值</li><li>删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值</li></ul></blockquote><p>InnoDB 的 MVCC <strong>通过在每行记录后面保存两个隐藏的列来实现</strong>。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，存储的不是实际的时间，而是<strong>版本号</strong>。每开始一个新的事务，系统版本号都会自动递增。<strong>事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作对比</strong>。下面详细介绍一下在可重复读隔离级别下，MVCC 的具体操作。</p><ul><li>SELECT <ul><li>InnoDB 会根据以下两个条件检查每条记录： <ul><li>只查找版本小于等于事务版本号的行</li><li>只查找未定义删除时间或者删除时间大于事务版本号的行</li></ul></li></ul></li><li>INSERT <ul><li>InnoDB 为新插入的每一行保存当前的系统版本号作为行版本号</li></ul></li><li>DELETE <ul><li>InnoDB 为删除的每一行保存当前的系统版本号作为行的删除版本号</li></ul></li><li>UPDATE <ul><li>InnoDB 新增一条记录，保存当前系统版本号作为新增行的版本号</li><li>在被删除记录的原始行，保存当前系统版本号作为被删除记录行的删除版本号</li></ul></li></ul><blockquote><p>优点：</p><ol><li>因为有了两个隐藏列来记录数据的状态，所以大多数读操作都可以不加锁</li><li>性能好，同时可以保证读取的数据是正确的</li></ol><p>缺点：</p><ol><li>需要额外的空间记录每行的状态</li><li>需要行状态的维护和检查</li></ol></blockquote><h4 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h4><p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p><ul><li>使用串行化读的隔离级别</li><li>MVCC + next-key locks ： next-key  locks 由 record locks (索引加锁) 和 gap locks (间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li></ul><blockquote><p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p></blockquote><p>参考：</p><p><a href="https://juejin.cn/post/6844903827255066631">https://juejin.cn/post/6844903827255066631</a></p><p><a href="https://juejin.cn/post/6844903994188365831">https://juejin.cn/post/6844903994188365831</a></p><p><a href="https://juejin.cn/post/6844903799534911496">https://juejin.cn/post/6844903799534911496</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句执行顺序</title>
      <link href="2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8</span>)  <span class="keyword">SELECT</span> </span><br><span class="line">(<span class="number">9</span>)  <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">1</span>)  <span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">3</span>)  <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">2</span>)  <span class="keyword">ON</span><span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">4</span>)  <span class="keyword">WHERE</span><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">5</span>)  <span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line">(6)  WITH &#123;CUBE|ROLLUP&#125;</span><br><span class="line">(<span class="number">7</span>)  <span class="keyword">HAVING</span><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">11</span>) LIMIT<span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>查询语句中的序号为该查询语句的处理顺序</p><blockquote><p>可以看到一共有11个步骤，最先执行的是FROM操作，最后执行的是LIMIT操作。<strong>每个操作都会产生一张虚拟表，该虚拟表作为一个处理的输入。这些虚拟表对用户是透明的，只有最后一步生成的虚拟表才会返回给用户</strong>。如果没有在查询中指定某一子句，则将跳过相应的步骤。</p></blockquote><p><strong>具体分析查询处理的各个阶段</strong>：</p><ol><li><strong>FROM</strong>：对 FROM 子句中的左表 <left_table> 和右表 <right_table> 执行笛卡儿积（ Cartesianproduct ），产生虚拟表 VT1</right_table></left_table></li><li><strong>ON</strong>：对虚拟表 VT1 应用 ON 筛选，只有那些符合 <join_condition> 的行才被插入虚拟表 VT2 中</join_condition></li><li><strong>JOIN</strong>：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止</li><li><strong>WHERE</strong>：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中</where_condition></li><li><strong>GROUP BY</strong>：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5</li><li><strong>CUBE|ROLLUP</strong>：对表VT5进行CUBE或ROLLUP操作，产生表VT6</li><li><strong>HAVING</strong>：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。</having_condition></li><li><strong>SELECT</strong>：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中</li><li><strong>DISTINCT</strong>：去除重复数据，产生虚拟表VT9</li><li><strong>ORDER BY</strong>：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。11）</order_by_list></li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11，并返回给查询用户</li></ol><p>参考：<a href="https://juejin.cn/post/6864555988873707527">https://juejin.cn/post/6864555988873707527</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句执行流程</title>
      <link href="2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语句执行过程详解"><a href="#SQL语句执行过程详解" class="headerlink" title="SQL语句执行过程详解"></a>SQL语句执行过程详解</h1><blockquote><p>当向 MySQL 发送一个请求的时候，MySQL 到底做了什么：</p></blockquote><ol><li>客户端发送一条查询给 MySQL 服务器。</li><li> MySQL 服务器先检查<strong>查询缓存</strong>，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>MySQL 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li><li>MySQL 根据优化器生成的执行计划，再调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端。</li></ol><p><strong>MySQL 架构图</strong></p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1611364747576.png" alt="1611364747576"></p><p><strong>MySQL 语句执行流程</strong></p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1611366694959.png" alt="1611366694959"></p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ol><li><p>MySQL查询缓存保存查询返回的完整结构。</p></li><li><p>当查询命中该缓存时，MySQL 会立刻返回结果，跳过了解析、优化和执行阶段。  </p></li><li><p>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。</p></li><li><p>MySQL 将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。</p></li><li><p>当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。</p></li><li><p>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。</p></li><li><p>有一点需要注意， MySQL 并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL 解析查询语句，所以也无法知道语句中是否有不确定的函数。</p></li><li><p>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。</p></li><li><p>有关查询缓存的配置如下所示。</p><blockquote><ul><li>query_cache_type:是否打开查询缓存。可以设置为OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。</li><li>query_cache_size:查询缓存使用的总内存空间。</li><li>query_cache_min_res_unit:在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li><li>query_cache_limit:MySQL能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，MySQL才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li></ul></blockquote></li></ol><p> 对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1652e56415f8dc20" alt="查询缓存判断流程图"></p><p> 缓存命中率可以通过如下公式计算： Qcache_hits / ( Qcache_hits + Com_select ) 来计算。</p><h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><ul><li>解析器通过关键字将 SQL 语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。</li><li>预处理器则根据一些 MySQL 规则进行进一步检查解析树是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</li></ul><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><ul><li>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。</li><li>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条 SQL 语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过 SQL 语句生成执行计划的整个过程，进而可以提高语句的执行速度。</li></ul><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1652e56416132c0d" alt="执行计划缓存"></p><blockquote><ul><li><p> MySQL使用基于成本的查询优化器( Cost-Based Optimizer，CBO )。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。</p></li><li><p>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后 CBO 会根据统计信息和代价模型( Cost Model )计算每个执行计划的 Cost，从中挑选 Cost 最小的执行计划。由上可知， CBO 中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响 CBO 选择最优计划。</p></li><li><p>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p></li></ul></blockquote><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><ul><li>在解析和优化阶段， MySQL 将生成查询对应的执行计划， MySQL 的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</li></ul><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><ul><li>如果查询可以被缓存，那么 MySQL 在这个阶段也会将结果存放到查询缓存中。</li><li>MySQL 将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时， MySQL 就可以开始向客户端逐步返回结果集了。</li></ul><p>参考：</p><p><a href="https://juejin.cn/post/6844903655439597582">https://juejin.cn/post/6844903655439597582</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot启动流程分析（一）：SpringApplication类初始化过程</title>
      <link href="2021/01/15/java/spring/java-spring-springBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>2021/01/15/java/spring/java-spring-springBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SpringBoot项目的mian函数"><a href="#一、SpringBoot项目的mian函数" class="headerlink" title="一、SpringBoot项目的mian函数"></a>一、SpringBoot项目的mian函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、-SpringBootApplication"><a href="#1、-SpringBootApplication" class="headerlink" title="1、@SpringBootApplication"></a>1、@SpringBootApplication</h2><p>后续 SpringBoot 自动装配中详解</p><h2 id="2、SpringApplication-run-DemoApplication-class-args"><a href="#2、SpringApplication-run-DemoApplication-class-args" class="headerlink" title="2、SpringApplication.run(DemoApplication.class, args);"></a>2、SpringApplication.run(DemoApplication.class, args);</h2><p>根据 <code>run()</code> 方法查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified source using default settings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySource the primary source to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">/* 静态助手，可以使用默认设置从指定的源运行&#123;@link SpringApplication&#125;。 @param primarySource加载的主要源@param args应用程序参数（通常从Java main方法传递）@返回运行中的&#123;@link ApplicationContext&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySources the primary sources to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">/* 静态帮助程序，可用于使用默认设置和用户提供的参数从指定的源运行&#123;@link SpringApplication&#125;。 @param primarySources提供要加载的主要源@param args应用程序参数（通常从Java main方法传递）@returning正在运行的&#123;@link ApplicationContext&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication  的 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/hello-shf/p/10976646.html">https://www.cnblogs.com/hello-shf/p/10976646.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring，SpringMVC，SpringBoot，SpringCloud的理解</title>
      <link href="2021/01/15/java/spring/java-spring-spring-SpringMVC-SpringBoot-SpringCloud/"/>
      <url>2021/01/15/java/spring/java-spring-spring-SpringMVC-SpringBoot-SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><ul><li> Spring 是一个轻量级的控制反转( IoC )和面向切面( AOP )的容器框架。 Spring 使你能够编写更干净、更可管理、并且更易于测试的代码。</li><li> Spring MVC 是 Spring 的一个模块，一个 web 框架。通过 Dispatcher Servle ,  ModelAndView 和 View Resolver ，开发 web 应用变得很容易。主要针对的是网站应用程序或者服务开发—— URL 路由、 Session 、模板引擎、静态 Web 资源等等。</li><li> Spring 配置复杂，繁琐，所以推出了 Spring boot ，约定优于配置，简化了 Spring 的配置流程。</li><li> Spring Cloud 构建于 Spring Boot 之上，是一个关注全局的服务治理框架。</li></ul></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="Spring-VS-SpringMVC"><a href="#Spring-VS-SpringMVC" class="headerlink" title="Spring VS SpringMVC"></a>Spring VS SpringMVC</h2><ul><li><p>Spring 是一个一站式的轻量级的 java 开发框架，核心是控制反转（ IOC ）和面向切面（ AOP ），针对于开发的WEB 层( SpringMVC )、业务层( Ioc )、持久层( jdbcTemplate )等都提供了多种配置解决方案；</p></li><li><p>SpringMVC 是 Spring 基础之上的一个 MVC 框架，主要处理 web 开发的路径映射和视图渲染，属于 Spring 框架中 WEB 层开发的一部分；</p></li></ul><h2 id="SpringMVC-VS-SpringBoot"><a href="#SpringMVC-VS-SpringBoot" class="headerlink" title="SpringMVC VS SpringBoot"></a>SpringMVC VS SpringBoot</h2><ul><li><p> SpringMVC 属于一个企业 WEB 开发的 MVC 框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等， XML、 config 等配置相对比较繁琐复杂；</p></li><li><p> SpringBoot 框架相对于 SpringMVC 框架来说，更专注于开发微服务后台接口，不开发前端视图；</p></li></ul><h2 id="SpringBoot-和-SpringCloud"><a href="#SpringBoot-和-SpringCloud" class="headerlink" title="SpringBoot 和 SpringCloud"></a>SpringBoot 和 SpringCloud</h2><ul><li><p> SpringBoot 使用了默认大于配置的理念，集成了快速开发的 Spring 多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消 xml 配置，是一套快速配置开发的脚手架，能快速开发单个微服务；</p></li><li><p> SpringCloud 大部分的功能插件都是基于 SpringBoot 去实现的， SpringCloud 关注于全局的微服务整合和管理，将多个 SpringBoot 单体微服务进行整合以及管理； SpringCloud 依赖于 SpringBoot 开发，而 SpringBoot 可以独立开发；</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Spring是核心，提供了基础功能；</li><li>Spring MVC 是基于 Spring 的一个 MVC 框架 ；</li><li>Spring Boot 是为简化 Spring 配置的快速开发整合包；</li><li>Spring Cloud 是构建在 Spring Boot 之上的服务治理框架。</li></ul><p>参考：</p><p><a href="https://juejin.cn/post/6844903956284440583">https://juejin.cn/post/6844903956284440583</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired 注解实现原理（Spring的自动装配）</title>
      <link href="2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h1><ul><li>@Autowired 注解是如何实现自动装配的？</li><li>当为类型为 A 的 Bean 装配类型为 B 的属性时，如果此时 Spring 容器中存在多个类型为 B 的 bean ，此时 Spring 是如何处理的？</li><li>自动装配的模型是什么？有哪几种？和 Autowired 注解有什么关联？</li></ul><h1 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h1><ol><li>pom依赖</li><li>配置类 <code>AppConfig</code>，在配置类中指定扫描哪些包下的文件</li><li>定义两个 service 接口以及实现类，然后在 <code>ClassAServiceImpl</code> 中为其注入 <code>ClassBService</code> 的实现类</li><li>启动类 <code>TestApplication</code> ，在启动类中通过调用 <code>getBean()</code> 方法获取到 <code>ClassAService</code> 类，然后调用 <code>find()</code> 方法，在 <code>find()</code> 方法中会打印注入的 <code>ClassBrService</code> 对象</li><li>运行 main() 方法，最终会在 query() 方法中打印出 ClassBService 对象。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 指定扫描哪些包下的文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.yangl.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassAService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassAService;</span><br><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassBService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAServiceImpl</span> <span class="keyword">implements</span> <span class="title">ClassAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassAServiceImpl 注入 ClassBService</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ClassBService classBService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(classBService);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassBService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassBService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassBServiceImpl</span> <span class="keyword">implements</span> <span class="title">ClassBService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassAService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">ClassAService classAService = applicationContext.getBean(ClassAService.class);</span><br><span class="line">classAService.find();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.yangl.test.service.impl.ClassBServiceImpl@453da22c</span><br></pre></td></tr></table></figure></blockquote><h1 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h1><h2 id="3-1、入口，源码分析"><a href="#3-1、入口，源码分析" class="headerlink" title="3.1、入口，源码分析"></a>3.1、入口，源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a constructor, field, setter method, or config method as to be autowired by</span></span><br><span class="line"><span class="comment"> * Spring&#x27;s dependency injection facilities. This is an alternative to the JSR-330</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> javax.inject.Inject&#125; annotation, adding required-vs-optional semantics.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Constructors&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Only one constructor of any given bean class may declare this annotation with the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #required&#125; attribute set to &#123;<span class="doctag">@code</span> true&#125;, indicating &lt;i&gt;the&lt;/i&gt; constructor</span></span><br><span class="line"><span class="comment"> * to autowire when used as a Spring bean. Furthermore, if the &#123;<span class="doctag">@code</span> required&#125;</span></span><br><span class="line"><span class="comment"> * attribute is set to &#123;<span class="doctag">@code</span> true&#125;, only a single constructor may be annotated</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125;. If multiple &lt;i&gt;non-required&lt;/i&gt; constructors declare the</span></span><br><span class="line"><span class="comment"> * annotation, they will be considered as candidates for autowiring. The constructor</span></span><br><span class="line"><span class="comment"> * with the greatest number of dependencies that can be satisfied by matching beans</span></span><br><span class="line"><span class="comment"> * in the Spring container will be chosen. If none of the candidates can be satisfied,</span></span><br><span class="line"><span class="comment"> * then a primary/default constructor (if present) will be used. Similarly, if a</span></span><br><span class="line"><span class="comment"> * class declares multiple constructors but none of them is annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125;, then a primary/default constructor (if present) will be used.</span></span><br><span class="line"><span class="comment"> * If a class only declares a single constructor to begin with, it will always be used,</span></span><br><span class="line"><span class="comment"> * even if not annotated. An annotated constructor does not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Fields&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Fields are injected right after construction of a bean, before any config methods</span></span><br><span class="line"><span class="comment"> * are invoked. Such a config field does not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Methods&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Config methods may have an arbitrary name and any number of arguments; each of</span></span><br><span class="line"><span class="comment"> * those arguments will be autowired with a matching bean in the Spring container.</span></span><br><span class="line"><span class="comment"> * Bean property setter methods are effectively just a special case of such a general</span></span><br><span class="line"><span class="comment"> * config method. Such config methods do not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Parameters&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Although &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125; can technically be declared on individual method</span></span><br><span class="line"><span class="comment"> * or constructor parameters since Spring Framework 5.0, most parts of the</span></span><br><span class="line"><span class="comment"> * framework ignore such declarations. The only part of the core Spring Framework</span></span><br><span class="line"><span class="comment"> * that actively supports autowired parameters is the JUnit Jupiter support in</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> spring-test&#125; module (see the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di&quot;&gt;TestContext framework&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * reference documentation for details).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Multiple Arguments and &#x27;required&#x27; Semantics&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In the case of a multi-arg constructor or method, the &#123;<span class="doctag">@link</span> #required&#125; attribute</span></span><br><span class="line"><span class="comment"> * is applicable to all arguments. Individual parameters may be declared as Java-8 style</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.Optional&#125; or, as of Spring Framework 5.0, also as &#123;<span class="doctag">@code</span> <span class="doctag">@Nullable</span>&#125;</span></span><br><span class="line"><span class="comment"> * or a not-null parameter type in Kotlin, overriding the base &#x27;required&#x27; semantics.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowiring Arrays, Collections, and Maps&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In case of an array, &#123;<span class="doctag">@link</span> java.util.Collection&#125;, or &#123;<span class="doctag">@link</span> java.util.Map&#125;</span></span><br><span class="line"><span class="comment"> * dependency type, the container autowires all beans matching the declared value</span></span><br><span class="line"><span class="comment"> * type. For such purposes, the map keys must be declared as type &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment"> * which will be resolved to the corresponding bean names. Such a container-provided</span></span><br><span class="line"><span class="comment"> * collection will be ordered, taking into account</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered Ordered&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order <span class="doctag">@Order</span>&#125; values of the target</span></span><br><span class="line"><span class="comment"> * components, otherwise following their registration order in the container.</span></span><br><span class="line"><span class="comment"> * Alternatively, a single matching target bean may also be a generally typed</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Collection&#125; or &#123;<span class="doctag">@code</span> Map&#125; itself, getting injected as such.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Not supported in &#123;<span class="doctag">@code</span> BeanPostProcessor&#125; or &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that actual injection is performed through a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; which in turn means that you &lt;em&gt;cannot&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125; to inject references into</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * types. Please consult the javadoc for the &#123;<span class="doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * class (which, by default, checks for the presence of this annotation).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Qualifier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declares whether the annotated dependency is required.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明是否需要带注释的依赖项,默认 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1、AutowiredAnnotationBeanPostProcessor"><a href="#3-1-1、AutowiredAnnotationBeanPostProcessor" class="headerlink" title="3.1.1、AutowiredAnnotationBeanPostProcessor"></a>3.1.1、AutowiredAnnotationBeanPostProcessor</h3><p>由 Autowired 注释可以看到</p><blockquote><p>Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor} class (which, by default, checks for the presence of this annotation)</p><p>请咨询{@link AutowiredAnnotationBeanPostProcessor}类的javadoc（默认情况下，该类检查此注释的存在）。</p></blockquote><p>AutowiredAnnotationBeanPostProcessor 继承关系如下图：</p><p><img src="/2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1611021808079.png" alt="1611021808079"></p><p><strong>可见它间接</strong></p><ul><li><strong>实现 InstantiationAwareBeanPostProcessor ，就具备了实例化前后(而不是初始化前后)管理对象的能力，</strong></li><li><strong>实现了 BeanPostProcessor ，具有初始化前后管理对象的能力，</strong></li><li><strong>实现 BeanFactoryAware ，具备随时拿到 BeanFactory 的能力，</strong></li></ul><p><strong>也就是说这个 AutowiredAnnotationBeanPostProcessor 具备一切后置处理器的能力。</strong></p><h2 id="3-2、源码分析"><a href="#3-2、源码分析" class="headerlink" title="3.2、源码分析"></a>3.2、源码分析</h2><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p><strong>在容器启动，为对象赋值的时候，遇到@Autowired注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是Autowired的原理。</strong></p><p>参考：</p><p><a href="https://juejin.cn/post/6844903957135884295">https://juejin.cn/post/6844903957135884295</a></p><p><a href="https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w">https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w</a></p><p><a href="https://juejin.cn/post/6844904032784515086">https://juejin.cn/post/6844904032784515086</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 的 Controller 是单例还是多例？怎么保证并发的安全</title>
      <link href="2021/01/15/java/spring/java-spring-springController%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84/"/>
      <url>2021/01/15/java/spring/java-spring-springController%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    <strong>controller 默认是单例的，正因为单例所以不是线程安全的</strong>。不要使用非静态的成员变量，否则会发生数据逻辑混乱</p><h1 id="怎么保证并发的安全"><a href="#怎么保证并发的安全" class="headerlink" title="怎么保证并发的安全"></a>怎么保证并发的安全</h1><ul><li>不要在 controller 中定义成员变量。</li><li>万一必须要定义一个非静态成员变量时候，则通过注解 @Scope(“prototype”) ，将其设置为多例模式。</li><li>在 Controller 中使用 ThreadLocal 变量</li></ul><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>Spring bean 作用域有以下5个：</p><p><strong>singleton:</strong> 单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；</p><p><strong>prototype：</strong> 原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；</p><p>（下面是在web项目下才用到的）</p><p><strong>request：</strong> 搞web的大家都应该明白 request 的域了吧，就是每次请求都新产生一个实例，和 prototype 不同就是创建后，接下来的管理，spring 依然在监听；</p><p><strong>session:</strong> 每次会话，同上；</p><p><strong>global session:</strong> 全局的web域，类似于 servlet 中的 application 。</p><p>参考：</p><p><a href="https://juejin.cn/post/6908685222116605965">https://juejin.cn/post/6908685222116605965</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory和FactoryBean的区别</title>
      <link href="2021/01/15/java/spring/java-spring-springBeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/01/15/java/spring/java-spring-springBeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><ul><li><code>BeanFactory</code>：Spring Bean 容器的根接口</li><li><code>FactoryBean</code>：各个对象的工厂接口，如果bean实现了这个接口，它将被用作对象的工厂，而不是直接作为bean实例。</li></ul></blockquote><h1 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a>1、BeanFactory</h1><blockquote><ul><li><p> <strong><code>BeanFacotry</code> 是 Spring 中比较原始的 Factory 。</strong>如 <code>XMLBeanFactory</code> 就是一种典型的 <code>BeanFactory</code> 。原始的 <code>BeanFactory</code> 无法支持 Spring 的许多插件，如 AOP 功能、 Web 应用等。</p></li><li><p> <strong><code>ApplicationContext</code> 接口，它由 <code>BeanFactory</code> 接口派生而来。</strong> <code>ApplicationContext</code> 包含<code>BeanFactory</code> 的所有功能。</p></li></ul></blockquote><h2 id="1-1-源码"><a href="#1-1-源码" class="headerlink" title="1.1 源码"></a>1.1 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line"><span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean实例的Class类型</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ul><li>从 IoC 容器中获取 Bean ( byName or byType )</li><li>检索 IoC 容器中是否包含指定的 Bean</li><li>判断 Bean 是否为单例</li></ul><h1 id="2、FactoryBean"><a href="#2、FactoryBean" class="headerlink" title="2、FactoryBean"></a>2、FactoryBean</h1><h2 id="2-1源码"><a href="#2-1源码" class="headerlink" title="2.1源码"></a>2.1源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从工厂中获取bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean工厂创建的对象是否是单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        从它定义的接口可以看出，<code>FactoryBean </code>表现的是一个工厂的职责。   <strong>即一个 Bean A 如果实现了<code>FactoryBean</code> 接口，那么 A 就变成了一个工厂，根据 A 的名称获取到的实际上是工厂调用 <code>getObject()</code> 返回的对象，而不是 A 本身，如果要获取工厂 A 自身的实例，那么需要在名称前面加上 ‘&amp;’ 符号。</strong></p><ul><li>getObject(‘name’)返回工厂中的实例</li><li>getObject(‘&amp;name’)返回工厂本身的实例</li></ul><p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p><h2 id="2-2、使用场景"><a href="#2-2、使用场景" class="headerlink" title="2.2、使用场景"></a>2.2、使用场景</h2><p>说了这么多，为什么要有 <code>FactoryBean</code> 这个东西呢，有什么具体的作用吗？<br>FactoryBean 在 Spring 中最为典型的一个应用就是用来<strong>创建AOP的代理对象</strong>。</p><p>我们知道 AOP 实际上是 Spring 在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说， AOP 代理对象通过 Java 的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在 Spring 中就是——<code>ProxyFactoryBean</code>。所以， FactoryBean 为我们实例化 Bean 提供了一个更为灵活的方式，我们可以通过 FactoryBean 创建出更为复杂的 Bean 实例。</p><h1 id="3、区别"><a href="#3、区别" class="headerlink" title="3、区别"></a>3、区别</h1><p><code>BeanFactory</code> 是接口，提供了 IoC 容器最基本的形式，给具体的 IoC 容器的实现提供了规范，</p><p><code>FactoryBean</code> 也是接口，为 IoC 容器中 Bean 的实现提供了更加灵活的方式， <code>FactoryBean</code> 在 IoC 容器的基础上给 Bean 的实现加上了一个简单<strong>工厂模式</strong>和<strong>装饰模式</strong>(如果想了解装饰模式参考：修饰者模式(装饰者模式， Decoration ) 我们可以在 getObject() 方法中灵活配置。其实在 Spring 源码中有很多 FactoryBean 的实现类.</p><p><strong>区别：</strong> BeanFactory 是个 Factory ，也就是 IoC 容器或对象工厂， FactoryBean 是个 Bean 。在 Spring 中，<strong>所有的 Bean 都是由 BeanFactory (也就是 IoC 容器)来进行管理的。</strong></p><p>但<strong>对 FactoryBean 而言，这个 Bean 不是简单的 Bean ，而是一个能生产或者修饰对象生成的工厂 Bean ,它的实现与设计模式中的工厂模式和修饰器模式类似</strong></p><blockquote><ul><li><code>BeanFactory</code> 是 Spring 容器的顶层接口， <code>FactoryBean</code> 更类似于用户自定义的工厂接口。</li><li> 他们两个都是个工厂，但 <code>FactoryBean</code> 本质上还是一个 Bean，也归 <code>BeanFactory</code> 管理</li></ul></blockquote><p>参考：</p><p><a href="https://juejin.cn/post/6844903967600836621">https://juejin.cn/post/6844903967600836621</a></p><p><a href="https://juejin.cn/post/6844904099662544903">https://juejin.cn/post/6844904099662544903</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 解决循环依赖的问题</title>
      <link href="2021/01/15/java/spring/java-spring-spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/15/java/spring/java-spring-spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ul><li><p>通常来说，如果问Spring内部如何解决循环依赖，一定是单默认的<strong>单例</strong> Bean 中，属性互相引用的场景</p></li><li><p><strong>原型</strong>( Prototype )的场景是<strong>不支持</strong>循环依赖的，通常会走到 <code>AbstractBeanFactory</code>类中下面的判断，抛出异常</p></li><li><p>构造器的循环依赖，就更不用说了，<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependency-resolution">官方文档</a>都摊牌了，你想让构造器注入支持循环依赖，是不存在的，不如把代码改了。</p></li></ul></blockquote><h1 id="Spring解决循环依赖"><a href="#Spring解决循环依赖" class="headerlink" title="Spring解决循环依赖"></a><strong>Spring</strong>解决循环依赖</h1><p>在 Spring 的 <code>DefaultSingletonBeanRegistry</code> 类中，维护了三个 <strong>Map</strong> ，也就是我们通常说的<strong>三级缓存</strong>（三级缓存并非官方文档描述，只是一种对代码的理解称呼）</p><blockquote><p>个人认为并不能理解为缓存，缓存的最终目的是为了解决性能，而这三个map的目的更多的是标识一个bean的创建状态。</p><p><code>singletonObjects</code> 表示bean已经完整的被创建</p><p><code>singletonFactories</code> 在单例工厂中的表示bean正在被创建</p><p><code>earlySingletonObjects</code> 在early中的表示已经被创建但完整</p></blockquote><ul><li><code>singletonObjects</code> 它是我们最熟悉的朋友，俗称“<strong>单例池</strong>”“<strong>容器</strong>”，缓存创建完成单例Bean的地方。</li><li><code>singletonFactories</code> 映射创建Bean的原始工厂</li><li><code>earlySingletonObjects</code> 映射Bean的<strong>早期</strong>引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为“<strong>Bean</strong>”，只是一个<strong>Instance</strong>.</li></ul><blockquote><p><code>singletonFactories</code>  与 <code>earlySingletonObjects</code> 只是临时保存数据的集合，bean创建完毕后，就会清除里面的内容</p></blockquote><h1 id="循环依赖的本质"><a href="#循环依赖的本质" class="headerlink" title="循环依赖的本质"></a>循环依赖的本质</h1><ol><li>利用缓存识别已经遍历过的节点；</li><li>利用Java引用，先提前设置对象地址，后完善bean；</li></ol><p>参考：<a href="https://juejin.cn/post/6844904122160775176">https://juejin.cn/post/6844904122160775176</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 的生命周期</title>
      <link href="2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h1><p><img src="/2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/162465267a0c2c59" alt="img"></p><p><strong>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</strong></p><ol><li>Spring 启动，查找并加载需要被 Spring 管理的 bean，进行 Bean 的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了 DisposableBean 接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ol><h1 id="Bean-完整的生命周期"><a href="#Bean-完整的生命周期" class="headerlink" title="Bean 完整的生命周期"></a>Bean 完整的生命周期</h1><p><img src="/2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/585cbd557cb14e9b987f874012847d28_tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 的作用域</title>
      <link href="2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-bean的作用域"><a href="#Spring-bean的作用域" class="headerlink" title="Spring bean的作用域"></a>Spring bean的作用域</h2><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><pre><code>什么是 spring bean？    在 Spring 中，那些组成应用程序的主体及由 Spring IoC 容器所管理的对象，被称之为 bean 。简单地讲，bean 就是由 IoC 容器初始化、装配及管理的对象</code></pre><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>singleton（单例模式）</td><td>在 Spring Ioc 容器中仅存在一个 Bean 实例，Bean 以单例方式存在，默认模式下即为单例</td></tr><tr><td>prototype（原型模式）</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用 <code>getBean()</code> 时，相等于执行 <code>new XxxBean()</code></td></tr><tr><td>request（HTTP请求）</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于 <code>WebApplicationContext</code>环境</td></tr><tr><td>session（会话）</td><td>同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同 Bean，仅适用于<code>WebApplicationContext</code> 环境</td></tr><tr><td>globalSession（全局会话）</td><td>一般用于 <code>Portlet</code> 应用环境，该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr></tbody></table><p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于 <code>web的Spring ApplicationContext</code> 环境。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="2021/01/13/java/spring/java-spring-springAOP/"/>
      <url>2021/01/13/java/spring/java-spring-springAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h1><ul><li>AOP是一种编程范式，通过添加切面点，在不改动已有核心逻辑代码的前提下，添加功能或更改代码流程。</li></ul><h1 id="AOP用来做什么？"><a href="#AOP用来做什么？" class="headerlink" title="AOP用来做什么？"></a>AOP用来做什么？</h1><ul><li>我们可以将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非业务逻辑的方法中，进而在这些行为改变的时候不影响业务逻辑的代码</li></ul><h1 id="AOP的两种代理方式"><a href="#AOP的两种代理方式" class="headerlink" title="AOP的两种代理方式"></a>AOP的两种代理方式</h1><ul><li><p>以 AspectJ 为代表的静态代理。</p><blockquote><p>​        静态代理是指 AOP 框架在编译阶段生成 AOP 代理类，因此也称为编译时增强。ApsectJ 是静态代理的实现之一，也是最为流行的。静态代理由于在编译时就生成了代理类，效率相比动态代理要高一些。AspectJ 可以单独使用，也可以和 Spring 结合使用。</p></blockquote></li><li><p>以 Spring AOP 为代表的动态代理。</p><blockquote><p>​        与静态代理不同，动态代理就是说 AOP 框架不会去修改编译时生成的字节码，而是在运行时在内存中生成一个 AOP 代理对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>​        Spring AOP 中的动态代理主要有两种方式：<strong>JDK 动态代理</strong> 和 <strong>CGLIB 动态代理</strong>。</p><p>​        JDK 代理通过反射来处理被代理的类，并且要求被代理类必须实现一个接口。核心类是 <code>InvocationHandler</code> 接口 和 <code>Proxy</code> 类。  </p><p>​        而当目标类没有实现接口时，Spring AOP 框架会使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。</p><p>​        CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code>，那么它是无法使用 CGLIB 做动态代理的。核心类是 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类</p></blockquote></li></ul><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><h2 id="1-切面-Aspect"><a href="#1-切面-Aspect" class="headerlink" title="(1)切面(Aspect)"></a>(1)切面(Aspect)</h2><blockquote><p>​        切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</p></blockquote><ul><li><strong>使用 <code>@Aspect</code> 注解的类就是切面</strong></li></ul><h2 id="2-目标对象-Target"><a href="#2-目标对象-Target" class="headerlink" title="(2) 目标对象(Target)"></a>(2) 目标对象(Target)</h2><blockquote><p>      目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p></blockquote><h2 id="3-连接点-JoinPoint"><a href="#3-连接点-JoinPoint" class="headerlink" title="(3) 连接点(JoinPoint)"></a>(3) 连接点(JoinPoint)</h2><blockquote><p> 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p><ul><li>方法(表示程序执行点，即在哪个目标方法)</li><li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li></ul><p>  简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。</p></blockquote><ul><li>使用 <code>@Before(&quot;pointcut()&quot;)</code> 实现</li></ul><h2 id="4-切入点-PointCut"><a href="#4-切入点-PointCut" class="headerlink" title="(4) 切入点(PointCut)"></a>(4) 切入点(PointCut)</h2><blockquote><p>切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。   </p><p>   一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。</p></blockquote><ul><li>使用 <code>@Pointcut(&quot;execution(* com.yangl.test.aop.service..*(..))&quot;)</code> 实现</li><li>匹配规则是 <code>com.yangl.test.aop.service</code>包下的所有类的所有函数。</li></ul><h2 id="5-通知-Advice"><a href="#5-通知-Advice" class="headerlink" title="(5) 通知(Advice)"></a>(5) 通知(Advice)</h2><blockquote><p>通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before说明这是一个前置通知，log函数中是要前置执行的代码，JoinPoint是连接点，</span></span><br><span class="line"><span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-织入-Weaving"><a href="#6-织入-Weaving" class="headerlink" title="(6) 织入(Weaving)"></a>(6) 织入(Weaving)</h2><blockquote><p>​        织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p></blockquote><h1 id="7-增强器-Adviser"><a href="#7-增强器-Adviser" class="headerlink" title="(7) 增强器(Adviser)"></a>(7) 增强器(Adviser)</h1><p>  Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。  </p><p>  Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPointcutAdvisor是默认接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Advice advice; <span class="comment">//Advice</span></span><br><span class="line"><span class="keyword">private</span> Pointcut pointcut; <span class="comment">//切入点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">publicvoidinit() &#123;</span><br><span class="line"><span class="comment">// AnnotationMatchingPointcut 是依据修饰类和方法的注解进行拦截的切入点。</span></span><br><span class="line"><span class="keyword">this</span>.pointcut = newAnnotationMatchingPointcut((Class) <span class="keyword">null</span>, Log.class);</span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="keyword">this</span>.advice = newLogMethodInterceptor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC</title>
      <link href="2021/01/13/java/spring/java-spring-springIOC/"/>
      <url>2021/01/13/java/spring/java-spring-springIOC/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-IoC"><a href="#什么是-IoC" class="headerlink" title="什么是 IoC"></a>什么是 IoC</h1><ul><li>控制反转，是一种思想，不是一种实现。Java 领域中描述的是对象的创建和管理的问题。</li><li>传统开发，A 中要使用 B 的对象，需要在 A 中 new 出 B 的对象</li><li>IoC 思想实现：不通过 new 关键字来创建对象，而是通过 IoC 容器( Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面获取即可。</li><li>控制 ：指的是对象创建（实例化、管理）的权力</li><li>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</li><li>IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。</li></ul><h1 id="IoC-解决了什么问题"><a href="#IoC-解决了什么问题" class="headerlink" title="IoC 解决了什么问题"></a>IoC 解决了什么问题</h1><p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p><ul><li>对象之间的耦合度或者说依赖程度降低；</li><li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li></ul><h1 id="DI（依赖注入）Dependency-Injection"><a href="#DI（依赖注入）Dependency-Injection" class="headerlink" title="DI（依赖注入）Dependency Injection"></a>DI（依赖注入）Dependency Injection</h1><p>是Ioc的一种实现方式，<strong>3种方式</strong></p><ul><li>构造器注入<ul><li>有参构造</li></ul></li><li>setter方法注入</li><li>接口注入</li></ul><h1 id="Spring-IOC的初始化过程："><a href="#Spring-IOC的初始化过程：" class="headerlink" title="Spring IOC的初始化过程："></a><strong>Spring IOC的初始化过程：</strong></h1><p><img src="/2021/01/13/java/spring/java-spring-springIOC/165fea36b569d4f4" alt="img"></p><ol><li>首先初始化上下文，生成 <code>ClassPathXmlApplicationContext</code> 对象</li><li>再获取 <code>resourcePatternResolver</code> 对象将 <code>xml</code> 解析成 <code>Resource</code> 对象。</li><li>利用1生成的 <code>context</code> 、 <code>resource</code> 初始化工厂，并将 <code>resource</code> 解析成 <code>beandefinition</code> </li><li>再将 <code>beandefinition</code> 注册到 <code>beanfactory</code> 中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务(二)</title>
      <link href="2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/"/>
      <url>2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h1><h2 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a>@Transactional 的作用范围</h2><ul><li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li><li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li>接口 ：不推荐在接口上使用。</li></ul><h2 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a>@Transactional 的常用配置参数</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED</td></tr><tr><td>isolation</td><td>事务的隔离级别，默认值采用 DEFAULT</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>readOnly</td><td>指定事务是否为只读事务，默认值为 false。</td></tr><tr><td>rollbackFor</td><td>用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td></tr></tbody></table><h2 id="Transactional-事务注解原理"><a href="#Transactional-事务注解原理" class="headerlink" title="@Transactional 事务注解原理"></a>@Transactional 事务注解原理</h2><ul><li>@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</li><li>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</li><li>Spring AOP 自调用问题<ul><li>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</li><li>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</li></ul></li></ul><h1 id="Transactional注有哪些属性"><a href="#Transactional注有哪些属性" class="headerlink" title="@Transactional注有哪些属性"></a>@Transactional注有哪些属性</h1><h2 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a><strong>propagation属性</strong></h2><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li></ul><h2 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a><strong>isolation 属性</strong></h2><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h2 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a><strong>timeout 属性</strong></h2><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><h2 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a><strong>readOnly 属性</strong></h2><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h2 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a><strong>rollbackFor 属性</strong></h2><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h2 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性"></a><strong>noRollbackFor</strong>属性</h2><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p><h1 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h1><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p><h2 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h2><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。 </p><p><img src="/2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/170f0e025a51a1b4.png" alt="在这里插入图片描述"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p><strong>注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p><h2 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h2><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 <code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 <code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h2 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional  注解属性 rollbackFor 设置错误"></a>3、@Transactional  注解属性 rollbackFor 设置错误</h2><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p><p><img src="/2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/170f0e025b17b3ca.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span></span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Class&lt;?&gt; exceptionClass, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exceptionClass.getName().contains(<span class="keyword">this</span>.exceptionName)) &#123;</span><br><span class="line">            <span class="comment">// Found it!</span></span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h2><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由<code>Spring</code>生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.insertB();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> insert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h2><p>这种情况是最常见的一种@Transactional注解失效场景，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insert = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h2 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h2><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Transactional 注解的看似简单易用，但如果对它的用法一知半解，还是会踩到很多坑的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务(一)</title>
      <link href="2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%B8%80)/"/>
      <url>2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><ul><li>事务是一组逻辑上的操作，要么都执行，要么都不执行</li><li>事务能否生效需要数据库引擎的支持，比如常用的 MySQL 数据库默认使用支持事务的innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了。</li></ul><h1 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h1><ul><li>原子性：一个事务的操作，要么全部执行，要么全部不执行</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：一个事务的执行不受其他事务的影响</li><li>持久性：事务提交后对数据库的影响是永久的</li></ul><h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul><li>多个任务对同一个数据进行操作</li><li>丢失修改：多个事务对同一个数据进行修改，之后的事务修改的结果覆盖了之前的。</li><li><strong>脏读</strong>：一个事务对数据的修改还没有提交，另一个事务就访问使用了这个数据。</li><li><strong>不可重复读</strong>：一个事务多次对一个数据读取，在这个中间另一个事务修改了该数据，导致，前一个前后读取的结果不一样。</li><li><strong>幻读</strong>：前一个事务读了几条记录，后一个事务插入或删除了记录，导致前一个事务再次读的时候数据多了或少了。</li></ul><h1 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别"></a>SQL 标准定义了四个隔离级别</h1><ul><li>READ-UNCOMMITTED(<strong>读取未提交</strong>)： 最低的隔离级别，<strong>允许读取尚未提交的数据变更</strong>，可能会导致脏读、幻读或不可重复读</li><li>READ-COMMITTED(<strong>读取已提交</strong>): <strong>允许读取并发事务已经提交的数据</strong>，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li>REPEATABLE-READ（<strong>可重读</strong>）: <strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(<strong>可串行化</strong>): 最高的隔离级别，完全服从ACID的隔离级别。<strong>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</strong>，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><h1 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h1><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><ul><li>通过TransactionTemplate和TransactionManager手动管理事务</li></ul><h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><ul><li>使用 @Transactional注解进行事务管理，基于AOP实现的</li></ul><h1 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h1><ul><li>PlatformTransactionManager： （平台）事务管理器接口，Spring 事务策略的核心。<ul><li>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</li><li>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是： PlatformTransactionManager 。通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransactionDefinition： 事务（属性）定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。<ul><li>这个类就定义了一些基本的事务属性</li><li>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>TransactionStatus： 事务运行状态<ul><li>TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TransactionDefinition接口中定义五个隔离级别"><a href="#TransactionDefinition接口中定义五个隔离级别" class="headerlink" title="TransactionDefinition接口中定义五个隔离级别"></a><strong>TransactionDefinition接口中定义五个隔离级别</strong></h1><blockquote><p><strong>ISOLATION_DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别</strong>，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应；</p><p><strong>ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别</strong>，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p><p><strong>ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取</strong>。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p><p><strong>ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读</strong>。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p><p><strong>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别</strong>。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p></blockquote><ul><li><h1 id="TransactionDefinition接口中定义了七个事务传播行为"><a href="#TransactionDefinition接口中定义了七个事务传播行为" class="headerlink" title="TransactionDefinition接口中定义了七个事务传播行为"></a>TransactionDefinition接口中定义了七个事务传播行为</h1></li></ul><blockquote><p>事务传播行为：</p><ul><li>解决业务层方法之间相互调用的事务问题</li><li>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</li></ul></blockquote><h2 id="TransactionDefinition-PROPAGATION-REQUIRED"><a href="#TransactionDefinition-PROPAGATION-REQUIRED" class="headerlink" title="TransactionDefinition.PROPAGATION_REQUIRED"></a>TransactionDefinition.PROPAGATION_REQUIRED</h2><ul><li>使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。<strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</strong>。也就是说：</li><li>如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被Propagation.REQUIRED的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于<strong>同一事务 ，只要一个方法回滚，整个事务均回滚</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-REQUIRES-NEW"><a href="#TransactionDefinition-PROPAGATION-REQUIRES-NEW" class="headerlink" title="TransactionDefinition.PROPAGATION_REQUIRES_NEW"></a>TransactionDefinition.PROPAGATION_REQUIRES_NEW</h2><ul><li>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW修饰的内部方法会<strong>新开启自己的事务</strong>，且开启的事务相互独立，互不干扰。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NESTED"><a href="#TransactionDefinition-PROPAGATION-NESTED" class="headerlink" title="TransactionDefinition.PROPAGATION_NESTED"></a>TransactionDefinition.PROPAGATION_NESTED</h2><ul><li>如果当前存在事务，则创建一个事务作为当前事务的<strong>嵌套事务</strong>来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li><li>也就是说：在外部方法未开启事务的情况下Propagation.NESTED和Propagation.REQUIRED作用相同，修饰的内部方法都会<strong>新开启自己的事务</strong>，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务的话，Propagation.NESTED修饰的内部方法属于<strong>外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-MANDATORY"><a href="#TransactionDefinition-PROPAGATION-MANDATORY" class="headerlink" title="TransactionDefinition.PROPAGATION_MANDATORY"></a>TransactionDefinition.PROPAGATION_MANDATORY</h2><ul><li>如果当前存在事务，则加入该事务；<strong>如果当前没有事务，则抛出异常</strong>。（mandatory：强制性）</li></ul><h2 id="TransactionDefinition-PROPAGATION-SUPPORTS"><a href="#TransactionDefinition-PROPAGATION-SUPPORTS" class="headerlink" title="TransactionDefinition.PROPAGATION_SUPPORTS"></a>TransactionDefinition.PROPAGATION_SUPPORTS</h2><ul><li>如果当前存在事务，则加入该事务；<strong>如果当前没有事务，则以非事务的方式继续运行</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NOT-SUPPORTED"><a href="#TransactionDefinition-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="TransactionDefinition.PROPAGATION_NOT_SUPPORTED"></a>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</h2><ul><li><strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NEVER"><a href="#TransactionDefinition-PROPAGATION-NEVER" class="headerlink" title="TransactionDefinition.PROPAGATION_NEVER"></a>TransactionDefinition.PROPAGATION_NEVER</h2><ul><li>以非事务方式运行，<strong>如果当前存在事务，则抛出异常</strong>。</li></ul><h1 id="配置事务的属性"><a href="#配置事务的属性" class="headerlink" title="配置事务的属性"></a>配置事务的属性</h1><blockquote><ul><li>isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</li><li>propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。</li><li>timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</li><li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中concorrentHashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk8-concorrentHashMap/"/>
      <url>2021/01/04/java/map/java-map-jdk8-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中concorrentHashMap源码解析"><a href="#JDK8中concorrentHashMap源码解析" class="headerlink" title="JDK8中concorrentHashMap源码解析"></a>JDK8中concorrentHashMap源码解析</h1><h1 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap()"></a>ConcurrentHashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the default initial table size (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用默认的初始表大小（16）创建一个新的空Map。 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity"><a href="#ConcurrentHashMap-int-initialCapacity" class="headerlink" title="ConcurrentHashMap(int initialCapacity)"></a>ConcurrentHashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment">    * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment">    * to dynamically resize.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个具有初始表大小的新的空映射*容纳指定数量的元素，而无需</span></span><br><span class="line"><span class="comment">    * 动态调整大小。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity该实现执行内部大小调整以容纳许多元素。 </span></span><br><span class="line"><span class="comment">    * 如果元素的初始容量为负，则抛出IllegalArgumentException </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                  MAXIMUM_CAPACITY :</span><br><span class="line">                  tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">       <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment">  * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;) and</span></span><br><span class="line"><span class="comment">  * initial table density (&#123;<span class="doctag">@code</span> loadFactor&#125;).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">  * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment">  * given the specified load factor.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment">  * establishing the initial table size</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">  * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment"> * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;), table</span></span><br><span class="line"><span class="comment"> * density (&#123;<span class="doctag">@code</span> loadFactor&#125;), and number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads (&#123;<span class="doctag">@code</span> concurrencyLevel&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment"> * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment"> * given the specified load factor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment"> * establishing the initial table size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads. The implementation may use this value as</span></span><br><span class="line"><span class="comment"> * a sizing hint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment"> * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment"> * nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、put方法"><a href="#2、put方法" class="headerlink" title="2、put方法"></a>2、put方法</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putVal-K-key-V-value-boolean-onlyIfAbsent"><a href="#putVal-K-key-V-value-boolean-onlyIfAbsent" class="headerlink" title="putVal(K key, V value, boolean onlyIfAbsent)"></a>putVal(K key, V value, boolean onlyIfAbsent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果table为空， 初始化table,</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前hash 的位置有没有值，没有值， 直接使使cas 无阻塞设置</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果正在扩容中</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁住单个 node</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检查是否有变更</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个节点hash 值不为0， 意思是当前节点为普通节点的时候， 这里应该比较容易理解， 比较hash 值， key equals 是否相等， 如果hash 冲突就添加链表， 记录链表长度(binCount)，之后会根据长度调整， 是否使用红黑树代替链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek !=   &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 尾插法</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果已经是树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 阀值，默认是8， 超过会转换成树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 转化为 tree</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ol><li>若数组空，则初始化，完成之后，转2</li><li>计算当前桶位是否有值 </li></ol><ul><li>无,则 CAS 创建,失败后继续自旋,直到成功</li><li>有,转3</li></ul><ol start="3"><li>判断桶位是否为转移节点(扩容ing) </li></ol><ul><li>是,则一直自旋等待扩容完成,之后再新增</li><li>否,转4</li></ul><ol start="4"><li>桶位有值,对当前桶位加synchronize锁 </li></ol><ul><li>链表，新增节点到链尾</li><li>红黑树，红黑树版方法新增</li></ul><ol start="5"><li>新增完成之后,检验是否需要扩容</li></ol></blockquote><h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用sizeCtl中记录的大小初始化表 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// sizeCtl: table 初始化和resize的标志位，表初始化和调整大小控件。</span></span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// sizeCtl为负值时，将初始化或调整表的大小</span></span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin(丢失了初始化竞赛；旋转一下)</span></span><br><span class="line">           <span class="comment">// 设置SIZECTL为-1，设置成功开始初始化， 不成功继续循环。</span></span><br><span class="line">           <span class="comment">// compareAndSwapInt 非阻塞同步原语： arg0, arg1, arg2, arg3 分别为对象实例，目标对象属性，当前预期值，要设的值, 设置成功返回 true, 失败 false</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><p>执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，而其它线程只能通过Thread.yield()让出CPU时间片等待table初始化完成。</p></blockquote><h1 id="3、图解流程"><a href="#3、图解流程" class="headerlink" title="3、图解流程"></a>3、图解流程</h1><p><img src="/2021/01/04/java/map/java-map-jdk8-concorrentHashMap/1610412313108.png" alt="1610412313108"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="jdk7-和-jdk8-的差异"><a href="#jdk7-和-jdk8-的差异" class="headerlink" title="jdk7 和 jdk8 的差异"></a>jdk7 和 jdk8 的差异</h2><ul><li>jdk7 使用 ReentrantLock + segment + hashentry + unsafe</li><li>jdk8 使用 Synchronized + CAS + Node + NodeTree + Unsafe</li></ul><h2 id="jdk8-总结"><a href="#jdk8-总结" class="headerlink" title="jdk8 总结"></a>jdk8 总结</h2><ul><li>jdk8 用 Synchronized + CAS + Node + NodeTree 代替 Segment ，只有在hash 冲突， 或者修改已经值的时候才去加锁， 锁的粒度更小，大幅减少阻塞</li><li>jdk8 链表节点数量大于8时，会将链表转化为红黑树进行存储，查询时间复杂度从O(n)，变成遍历红黑树O(logN)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中concorrentHashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk7-concorrentHashMap/"/>
      <url>2021/01/04/java/map/java-map-jdk7-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中concorrentHashMap源码解析"><a href="#JDK7中concorrentHashMap源码解析" class="headerlink" title="JDK7中concorrentHashMap源码解析"></a>JDK7中concorrentHashMap源码解析</h1><h1 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h1><p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h1 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h1><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default initial capacity for this table,</span></span><br><span class="line"><span class="comment">    * used when not otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认的数组大小16(HashMap里的那个数组)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default load factor for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 扩容因子0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default concurrency level for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认并发标准16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The minimum capacity for per-segment tables.  Must be a power</span></span><br><span class="line"><span class="comment">    * of two, at least two to avoid immediate resizing on next use</span></span><br><span class="line"><span class="comment">    * after lazy construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 每段表的最小容量。必须为2的幂，至少为2的幂，以免在延迟构造后立即调整下次使用时的大小。*/</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// ConcurrentHashMap中的数组</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">    * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">    * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 段是哈希表的专用版本。该子类是ReentrantLock的机会子类，只是为了简化一些锁定并避免单独构造。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">        * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/* 每个细分表。元素通过提供可变语义的entryAtsetEntryAt访问。 */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment">        * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The total number of mutative operations in this segment.</span></span><br><span class="line"><span class="comment">        * Even though this may overflows 32 bits, it provides</span></span><br><span class="line"><span class="comment">        * sufficient accuracy for stability checks in CHM isEmpty()</span></span><br><span class="line"><span class="comment">        * and size() methods.  Accessed only either within locks or</span></span><br><span class="line"><span class="comment">        * among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table is rehashed when its size exceeds this threshold.</span></span><br><span class="line"><span class="comment">        * (The value of this field is always &lt;tt&gt;(int)(capacity *</span></span><br><span class="line"><span class="comment">        * loadFactor)&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The load factor for the hash table.  Even though this value</span></span><br><span class="line"><span class="comment">        * is same for all segments, it is replicated to avoid needing</span></span><br><span class="line"><span class="comment">        * links to outer object.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">       Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">           <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">           <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">           <span class="keyword">this</span>.table = tab;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">    * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* ConcurrentHashMap列表条目。请注意，它永远不会作为用户可见的Map.Entry导出。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;</span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造**默认值是 16。</li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>。</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15。</li><li><strong>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 20.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap()"></a>ConcurrentHashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">    * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用默认的初始容量（16），</span></span><br><span class="line"><span class="comment">   * 负载因子（0.75）和concurrencyLevel（16）创建一个新的空映射。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity"><a href="#ConcurrentHashMap-int-initialCapacity" class="headerlink" title="ConcurrentHashMap(int initialCapacity)"></a>ConcurrentHashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity,</span></span><br><span class="line"><span class="comment">    * and with default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 创建一个具有指定初始容量，默认负载因子（0.75）和concurrencyLevel（16）的新的空映射。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果元素的初始容量为负，则IllegalArgumentException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity</span></span><br><span class="line"><span class="comment">    * and load factor and with the default concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量和负载因子以及默认的concurrencyLevel（16）创建一个新的空映射。 @param initialCapacity该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @throws IllegalArgumentException如果元素的初始容量为负或负载系数为非正值（从1.6开始）*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">    * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">    * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">    * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">    * nonpositive.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量，负载因子和并发级别创建一个新的空映射。 @param initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @param concurrencyLevelLevel并发更新线程的估计数量。该实现执行内部大小调整以尝试容纳这么多线程。如果初始容量为负，或者负载系数或concurrencyLevel为非正值，则@throws IllegalArgumentException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 参数检验</span></span><br><span class="line">       <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂次方数（例如 concurrencyLevel=16，sshift 则为 4 ）</span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂数（例如 concurrencyLevel=16，ssize 则为 16）</span></span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">           ++sshift;</span><br><span class="line">           <span class="comment">// ssize 右移两位 即 ssize = ssize * 2</span></span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 32 - 4 = 28 (段位移)</span></span><br><span class="line">       <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">       <span class="comment">// 16 - 1 = 15 （段 mask）</span></span><br><span class="line">       <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 计算 segment 段内最小的数组长度，2的幂次方倍</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">       <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">           ++c;</span><br><span class="line">       <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">       <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create segments and segments[0]</span></span><br><span class="line">       <span class="comment">// 创建 segments=Segment[ssize] 数组并初始化 segments[0]</span></span><br><span class="line">       Segment&lt;K,V&gt; s0 =</span><br><span class="line">           <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                            (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">       Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">       UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">       <span class="keyword">this</span>.segments = ss;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li><p>根据 initialCapacity, loadFactor, concurrencyLevel 创建 Segment 数组并初始化 Segment[0]</p></li><li><p>计算出段位移：this.segmentShift = 32 - sshift;</p></li><li><p>计算出段Mask :  this.segmentMask = ssize - 1;</p></li></ul></blockquote><h2 id="ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment">    * The map is created with a capacity of 1.5 times the number</span></span><br><span class="line"><span class="comment">    * of mappings in the given map or 16 (whichever is greater),</span></span><br><span class="line"><span class="comment">    * and a default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用与给定map相同的map创建一个新map。创建的映射的容量是给定映射中映射数量的1.5倍或16（最大），默认加载因子（0.75）和concurrencyLevel（16）。map中的@param m */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">            DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">       putAll(m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、put方法"><a href="#3、put方法" class="headerlink" title="3、put方法"></a>3、put方法</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment">    * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment">    * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** 将指定的键映射到此表中的指定值。键或值都不能为null。 &lt;p&gt;可以通过使用等于原始键的键调用&lt;tt&gt; get &lt;tt&gt;方法来检索该值。 <span class="doctag">@param</span>与指定值关联的键key @ param与指定键关联的值@返回与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值如果指定的键或值为null，则&lt;tt&gt; key &lt;tt&gt;没有映射<span class="doctag">@throws</span> NullPointerException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// value 值为空，直接抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 经过一系列的计算得出 key 的 hash 值 (为了更好的均匀散列表的下标)</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Segment[] 数组中下标所在的位置</span></span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="comment">// 如果 Segment[] 数组为空则创建一个 Segment&lt;&gt; 元素，若不为空则直接 put</span></span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ensureSegment-int-k"><a href="#ensureSegment-int-k" class="headerlink" title="ensureSegment(int k)"></a>ensureSegment(int k)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">    * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 返回给定索引的段，创建它并记录在段表中（通过CAS）（如果尚不存在）。 @param k索引 @返回 段 */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">       <span class="comment">// raw offset 原始偏移</span></span><br><span class="line">       <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">       Segment&lt;K,V&gt; seg;</span><br><span class="line">       <span class="comment">// 根据原始偏移获取指定段的值，如果为空</span></span><br><span class="line">       <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 复制一份和segment 0一样的segment （使用 segment0 作为原型）</span></span><br><span class="line">           Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">           <span class="keyword">int</span> cap = proto.table.length;<span class="comment">// 段数组大小</span></span><br><span class="line">           <span class="keyword">float</span> lf = proto.loadFactor;<span class="comment">// 加载因子</span></span><br><span class="line">           <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);<span class="comment">// 阈值</span></span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">           <span class="comment">// 再次根据原始偏移量获取指定段的值，如果为空</span></span><br><span class="line">           <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">               == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">               <span class="comment">// 根据已有属性创建段 Segment s</span></span><br><span class="line">               Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">               <span class="comment">// 再次根据原始偏移量获取指定段的值，为空则循环</span></span><br><span class="line">               <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                      == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 利用 cas 进行赋值</span></span><br><span class="line">                   <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> seg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li>如果指定段 segments[j] 为空，则复制 segments[0] 到指定段 segments[j]</li><li>UNSAFE.compareAndSwapObject 原子性操作保证线程安全 （利用了CAS）</li></ul></blockquote><h1 id="4、Segment内置方法解析"><a href="#4、Segment内置方法解析" class="headerlink" title="4、Segment内置方法解析"></a>4、Segment内置方法解析</h1><h2 id="put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="put(K key, int hash, V value, boolean onlyIfAbsent)"></a>put(K key, int hash, V value, boolean onlyIfAbsent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryLock() 尝试获取锁，获取不到执行 scanAndLockForPut 方法</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取当前 hash 值在改 tab 中的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取执行 tab 中的头节点 Entry</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// key 存在</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="comment">// 记录当前值为旧值</span></span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 如果不是设置的空值替换，则直接替换原有值。</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 转向下一个节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 头插法</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 不存在则创建节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">// 键值对的数量 +1</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 键值对数量达到阈值，（并且数组长度要小于最大定义长度）</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 为超过阈值，直接将 node 放在指定位置</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改成功，返回原值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scanAndLockForPut-K-key-int-hash-V-value"><a href="#scanAndLockForPut-K-key-int-hash-V-value" class="headerlink" title="scanAndLockForPut(K key, int hash, V value)"></a>scanAndLockForPut(K key, int hash, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment"> * acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment"> * return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment"> * methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment"> * traversal speed doesn&#x27;t matter, we might as well help warm</span></span><br><span class="line"><span class="comment"> * up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在尝试获取锁的同时扫描包含给定 key 的节点，如果找不到则创建并返回一个节点。返回时，保证锁定被保持。与大多数方法不同，不筛选对方法等于的调用：由于遍历速度并不重要，因此我们也可能会帮助预热关联的代码和访问。 </span></span><br><span class="line"><span class="comment">@ reurn 如果找不到 key ，则返回一个新节点，否则返回null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Gets the table entry for the given segment and hash</span></span><br><span class="line">       <span class="comment">// 根据 segment 和 hash 获取 entry</span></span><br><span class="line">       HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">       HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">       HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 重试次数</span></span><br><span class="line">       <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">       <span class="comment">// 循环尝试获取锁</span></span><br><span class="line">       <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">           HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">           <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                       <span class="comment">// 创建节点</span></span><br><span class="line">                       node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   retries = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                   <span class="comment">// 头结点就是</span></span><br><span class="line">                   retries = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">// 转向下一个节点</span></span><br><span class="line">                   e = e.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">               <span class="comment">// 尝试了MAX_SCAN_RETRIES次还没拿到锁,</span></span><br><span class="line">               <span class="comment">// TODO</span></span><br><span class="line">               lock();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">               <span class="comment">// 验证头结点是否改变，如果改变，retries重置，从头开始</span></span><br><span class="line">               e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">               retries = -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rehash-HashEntry-lt-K-V-gt-node"><a href="#rehash-HashEntry-lt-K-V-gt-node" class="headerlink" title="rehash(HashEntry&lt;K,V&gt; node)"></a>rehash(HashEntry&lt;K,V&gt; node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment"> * given node to new table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 双倍扩容，将原有数据放入新 table 中 */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reclassify nodes in each list to new table.  Because we</span></span><br><span class="line"><span class="comment"> * are using power-of-two expansion, the elements from</span></span><br><span class="line"><span class="comment"> * each bin must either stay at same index, or move with a</span></span><br><span class="line"><span class="comment"> * power of two offset. We eliminate unnecessary node</span></span><br><span class="line"><span class="comment"> * creation by catching cases where old nodes can be</span></span><br><span class="line"><span class="comment"> * reused because their next fields won&#x27;t change.</span></span><br><span class="line"><span class="comment"> * Statistically, at the default threshold, only about</span></span><br><span class="line"><span class="comment"> * one-sixth of them need cloning when a table</span></span><br><span class="line"><span class="comment"> * doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="comment"> * collectable as soon as they are no longer referenced by</span></span><br><span class="line"><span class="comment"> * any reader thread that may be in the midst of</span></span><br><span class="line"><span class="comment"> * concurrently traversing table. Entry accesses use plain</span></span><br><span class="line"><span class="comment"> * array indexing because they are followed by volatile</span></span><br><span class="line"><span class="comment"> * table write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/** 将每个列表中的节点重新分类为新表。因为我们使用的是2的幂次展开，所以每个bin中的元素必须保持相同的索引或以2个偏移量的幂移动。通过捕获旧节点因为其下一个字段不会更改而可以重复使用的情况，我们消除了不必要的节点创建。从统计上讲，在默认阈值下，当表加倍时，仅其中的六分之一需要克隆。一旦它们被并发遍历表中的任何读取器线程不再引用，它们替换的节点将立即被垃圾回收。条目访问使用纯数组索引，因为它们后面是易失表写入。 */</span></span><br><span class="line">   <span class="comment">// 旧数组的引用</span></span><br><span class="line">HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 旧数组的长度</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新数组的阈值</span></span><br><span class="line">threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">(HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line"><span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历就数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算旧数组值在新数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 单节点直接放到新的数组上</span></span><br><span class="line">newTable[idx] = e;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot(重用同一插槽中的连续序列)</span></span><br><span class="line">                <span class="comment">// 拷贝第一个节点到新的数组节点上（方便后面头插法）</span></span><br><span class="line">HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line"><span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line"> last != <span class="keyword">null</span>;</span><br><span class="line"> last = last.next) &#123;</span><br><span class="line"><span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">lastIdx = k;</span><br><span class="line">lastRun = last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newTable[lastIdx] = lastRun;</span><br><span class="line"><span class="comment">// Clone remaining nodes（拷贝剩余节点）</span></span><br><span class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">V v = p.value;</span><br><span class="line"><span class="keyword">int</span> h = p.hash;</span><br><span class="line"><span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">// 添加新的节点(链表头插入方式)</span></span><br><span class="line">node.setNext(newTable[nodeIndex]);</span><br><span class="line">newTable[nodeIndex] = node;</span><br><span class="line">table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、图解流程"><a href="#5、图解流程" class="headerlink" title="5、图解流程"></a>5、图解流程</h1><p><img src="/2021/01/04/java/map/java-map-jdk7-concorrentHashMap/concurrentHashMap.jpg" alt="1610410777381"></p><p>参考：<a href="https://juejin.cn/post/6844903520957644808#heading-4">https://juejin.cn/post/6844903520957644808#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中hashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk8-hashmap/"/>
      <url>2021/01/04/java/map/java-map-jdk8-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中hashMap源码解析"><a href="#JDK8中hashMap源码解析" class="headerlink" title="JDK8中hashMap源码解析"></a>JDK8中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>因为主要说的是1.8版本中的实现。而1.8中HashMap是数组+链表+红黑树实现的，大概如下图所示。后面还是主要介绍Hash Map中主要的一些成员以及方法原理。</p><p>那么上述图示中的结点Node具体类型是什么，源码如下。Node是HashMap的内部类，实现了Map.Entery接口，主要就是存放我们put方法所添加的元素。其中的next就表示这可以构成一个单向链表，这主要是通过链地址法解决发生hash冲突问题。而当桶中的元素个数超过阈值的时候就换转为红黑树。</p><h2 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">    * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基本哈希箱节点，用于大多数条目。 （请参阅下面的</span></span><br><span class="line"><span class="comment">    * TreeNode子类，以及LinkedHashMap中的Entry子类。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// hash桶中的结点Node,实现了Map.Entry</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;<span class="comment">// 链表的next指针</span></span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重写Object的hashCode</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// equals方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeNode-lt-k-v-gt"><a href="#TreeNode-lt-k-v-gt" class="headerlink" title="TreeNode&lt;**k**,**v**&gt;"></a><strong>TreeNode</strong>&lt;**k**,**v**&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;<span class="comment">//左子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;<span class="comment">//右子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;<span class="comment">// 颜色属性</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 返回当前节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2、HashMap中的成员变量以及含义"><a href="#2、HashMap中的成员变量以及含义" class="headerlink" title="2、HashMap中的成员变量以及含义"></a>2、HashMap中的成员变量以及含义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量初始化=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量 = 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认加载因子.一般HashMap的扩容的临界点是当前HashMap的大小 &gt; DEFAULT_LOAD_FACTOR * </span></span><br><span class="line"><span class="comment">//DEFAULT_INITIAL_CAPACITY = 0.75F * 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数大于该值的时候，会由链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数小于该值的时候，红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash算法,计算传入的key的hash值，下面会有例子说明这个计算的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。下面会有例子说明</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash桶</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存的entrySet</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶的实际元素个数 != table.length</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容或者更改了map的计数器。含义：表示这个HashMap结构被修改的次数，结构修改是那些改变HashMap中的映射数量或者</span></span><br><span class="line"><span class="comment">//修改其内部结构（例如，重新散列rehash）的修改。 该字段用于在HashMap失败快速（fast-fail）的Collection-views</span></span><br><span class="line"><span class="comment">//上创建迭代器。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临界值，当实际大小（cap*loadFactor）大于该值的时候，会进行扩充</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="3、HashMap构造方法"><a href="#3、HashMap构造方法" class="headerlink" title="3、HashMap构造方法"></a>3、HashMap构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量</span></span><br><span class="line"><span class="comment">    *（16）和默认的加载因子（0.75）构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;，它具有指定的初始*容量和默认负载因子（0.75）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。 </span></span><br><span class="line"><span class="comment"> * @如果初始容量为负，则抛出IllegalArgumentException。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用指定的初始*容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor负载系数</span></span><br><span class="line"><span class="comment">    * @如果初始容量为负*或负载系数为非正数，则抛出IllegalArgumentException </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的&lt;tt&gt; HashMap &lt;/ tt&gt;。 &lt;tt&gt; HashMap &lt;/ tt&gt;是使用默认负载因子（0.75）和足以将*映射保存在指定的&lt;tt&gt; Map &lt;/ tt&gt;中的初始容量创建的。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>要在其地图中放置其映射的地图*如果指定的地图为null，则抛出NullPointerException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">    * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.putAll和Map构造函数。映射时的</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>最初构造此映射时，返回<span class="doctag">@false</span>，否则为true（中继到afterNodeInsertion方法）。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//该函数将传递的map集合中的所有元素加入本map实例中</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果本map实例的table为null，没有初始化，那么需要初始化</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">               <span class="comment">// 实际大小：ft = m.size() / 0.75 + 1;</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">// 判断刚刚计算的大小是否小于最大值1&lt;&lt;&lt;30</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//计算的实际大小ft大于当前的阈值threshhold，那么将threshhold重新计算，tableSizeFor传递的</span></span><br><span class="line">           <span class="comment">//参数是计算的大小，即重新计算大于ft的最小二次幂</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果table!=null，并且m.size() &gt; threshhold，直接进行扩容处理</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">// 将map中的所有元素加入本map实例中</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、put-方法"><a href="#4、put-方法" class="headerlink" title="4、put 方法"></a>4、put 方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定值与该映射中的指定键相关联。</span></span><br><span class="line"><span class="comment">    * 如果该映射先前包含键的映射，则将替换旧</span></span><br><span class="line"><span class="comment">    * 值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>键与指定值关联的键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>值与指定键关联的值</span></span><br><span class="line"><span class="comment">    * @返回与&lt;tt&gt; key &lt;/ tt&gt;关联的先前值，或者</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt; null &lt;/ tt&gt;（如果没有&lt;tt&gt; key &lt;/ tt&gt;的映射）。</span></span><br><span class="line"><span class="comment">    * （返回&lt;tt&gt; null &lt;/ tt&gt;还可以表明该地图</span></span><br><span class="line"><span class="comment">    * 先前将&lt;tt&gt; null &lt;/ tt&gt;与&lt;tt&gt; key &lt;/ tt&gt;关联。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现Map.put和相关方法。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 哈希键的哈希值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 键的键</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 值的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> only如果为true，则不更改现有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 退出，如果为false，则表处于创建模式。 </span></span><br><span class="line"><span class="comment">   * @返回上一个值；如果没有，则返回null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//table == null 或者table的长度为0，调用resize方法进行扩容</span></span><br><span class="line"><span class="comment">//这里也说明：table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里就是调用了Hash算法的地方，具体的计算可参考后面写到的例子</span></span><br><span class="line"> <span class="comment">// 这里定位坐标的做法在上面也已经说到过</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 如果计算得到的桶下标值中的Node为null，就新建一个Node加入该位置(这个新的结点是在</span></span><br><span class="line">     <span class="comment">// table数组中)。而该位置的hash值就是调用hash()方法计算得到的key的hash值</span></span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//这里表示put的元素用自己key的hash值计算得到的下表和桶中的第一个位置元素产生了冲突，具体就是</span></span><br><span class="line"> <span class="comment">//(1)key相同，value不同</span></span><br><span class="line"> <span class="comment">//(2)只是通过hash值计算得到的下标相同，但是key和value都不同。这里处理的方法就是链表和红黑树</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//上面已经计算得到了该hash对应的下标i，这里p=tab[i]。这里比较的有：</span></span><br><span class="line">     <span class="comment">//(1)tab[i].hash是否等于传入的hash。这里的tab[i]就是桶中的第一个元素</span></span><br><span class="line">     <span class="comment">//(2)比较传入的key和该位置的key是否相同</span></span><br><span class="line">     <span class="comment">//(3)如果都相同，说明是同一个key，那么直接替换对应的value值(在后面会进行替换)</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">// 将桶中的第一个元素赋给e，用来记录第一个位置的值</span></span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             <span class="comment">// 这里判断为红黑树。hash值不相等，key不相等；为红黑树结点</span></span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//判断为链表结点</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//如果达到链表的尾部</span></span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 在尾部插入新的结点</span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 前面的binCount是记录链表长度的，如果该值大于8，就会转变为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//如果在遍历链表的时候，判断得出要插入的结点的key和链表中间的某个结点的key相</span></span><br><span class="line">             <span class="comment">//同，就跳出循环,后面也会更新旧的value值</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">//e = p.next。遍历链表所用</span></span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断插入的是否存在HashMap中，上面e被赋值，不为空，则说明存在，更新旧的键值对</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value; <span class="comment">// 用传入的参数value更新旧的value值</span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;<span class="comment">// 返回旧的value值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// modCount修改</span></span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 容量超出就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>​    可以看到主要逻辑在put方法中调用了putVal方法，传递的参数是调用了hash()方法计算key的hash值，主要逻辑在putVal中。可以结合注释熟悉这个方法的执行，我在这里大概总结一下这个方法的执行：</p><ol><li><p>首先 <strong>(tab = table) == null || (n = tab.length) == 0</strong>这一块判断hash桶是否为null，如果为null那么会调用resize方法扩容。后面我们会说到这个方法</p></li><li><p>定位元素在桶中的位置，具体就是通过<strong>key的hash值和hash桶的长度</strong>计算得到下标i，如果计算到的位置处没有元素(null)，那么就新建结点然后添加到该位置。</p></li><li><p>如果table[i]处不为null，已经有元素了，那么就表明产生hash冲突,这里可能是三种情况</p><p>①判断key是不是一样，如果key一样，那么就将新的值替换旧的值；</p><p>②如果不是因为key一样，那么需要判断当前该桶是不是已经转为了红黑树，是的话就构造一个TreeNode结点插入红黑树；</p><p>③不是红黑树，就使用链地址法处理冲突问题。这里主要就是遍历链表，如果在遍历过程中也找到了key一样的元素，那么久还是使用新值替换旧值。否则会遍历到链表结尾处，到这里就直接新添加一个Node结点插入链表，插入之后还需要判断是不是已将超过了转换为红黑树的阈值8，如果超过就会转为红黑树。</p></li><li><p>最后需要修改modCount的值。</p></li><li><p>判断插入后的size大小是不是超过了threshhold，如果超过需要进行扩容。</p></li></ol></blockquote><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化或加倍表大小。如果为null，则根据字段阈值中保持的初始容量目标分配。 </span></span><br><span class="line"><span class="comment">    * 否则，因为我们使用的是2的幂，所以每个bin中的</span></span><br><span class="line"><span class="comment">    * 元素必须保持相同的索引，或者在新表中以2的偏移量移动。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @返回 table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// oldTab 指向旧的 table 数组</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// oldTab 不为 null 的话，oldCap 为原 table 的长度，oldTab为null的话，oldCap为0</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">// 阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果数组的长度在扩容后小于最大容量 并且oldCap大于默认值16(这里的newCap也是在原来的</span></span><br><span class="line">       <span class="comment">// 长度上扩展两倍)</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           <span class="comment">// 这里的oldThr=tabSizeFor(initialCapacity),从上面的构造方法看出，如果不是调用的</span></span><br><span class="line">       <span class="comment">// 无参构造，那么threshhold肯定都会是经过tabSizeFor运算得到的2的整数次幂的,所以可以将</span></span><br><span class="line">       <span class="comment">// 其作为Node数组的长度(个人理解)</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="comment">// 这里说的是我们调用无参构造函数的时候(table == null,threshhold = 0)，新的容量等于默</span></span><br><span class="line">       <span class="comment">// 认的容量，并且threshhold也等于默认加载因子*默认初始化容量</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 计算新的resize上限</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//容量 * 加载因子</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       <span class="comment">//以新的容量作为长度，创建一个新的Node数组存放结点元素</span></span><br><span class="line">   <span class="comment">//当然，桶数组的初始化也是在这里完成的</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//原来的table不为null</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// 原table中下标j位置不为null</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//将原来的table[j]赋为null</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果该位置没有链表，即只有数组中的那个元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">// 通过新的容量计算在新的table数组中的下标：(n-1)&amp;hash</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">// 如果是红黑树结点，重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">//遍历链表，进行重新映射</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 原位置</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// loTail处为null，那么直接加到该位置</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// loTail为链表尾结点，添加到尾部</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 原位置+旧容量</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// hiTail处为null，就直接点添加到该位置</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// hiTail为链表尾结点，尾插法添加</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                   <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 旧链表迁移新链表,链表元素相对位置没有变化; </span></span><br><span class="line">                       <span class="comment">// 实际是对对象的内存地址进行操作 </span></span><br><span class="line">                           loTail.next = <span class="keyword">null</span>; <span class="comment">// 链表尾元素设置为null</span></span><br><span class="line">                           newTab[j] = loHead; <span class="comment">// 数组中位置为j的地方存放链表的head结点</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断当前oldTab长度是否为空，如果为空，则进行初始化桶数组，也就回答了<strong>无参构造函数初始化为什么没有对容量和阈值进行赋值</strong>，如果不为空，则进行位运算，左移一位，2倍运算扩容。</p><p>扩容，创建一个新容量的数组，遍历旧的数组： </p><ul><li>如果节点为空，直接赋值插入</li><li>如果节点为红黑树，则需要进行进行拆分操作（个人对红黑树还没有理解，所以先不说明）</li><li>如果为链表，根据hash算法进行重新计算下标，将链表进行拆分分组（相信看到这里基本上也知道链表拆分的大致过程了）</li></ul></blockquote><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode(int hash, Object key)"></a><strong>getNode</strong>(<strong>int</strong> hash, Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.get和相关方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">    * @返回节点，如果没有则返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">//计算存放在数组table中的位置.具体计算方法上面也已经介绍了</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//先查找是不是就是数组中的元素</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//该位置为红黑树根节点或者链表头结点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="comment">//如果first为红黑树结点，就在红黑树中遍历查找</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="comment">//不是树结点，就在链表中遍历查找</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中hashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk7-hashmap/"/>
      <url>2021/01/04/java/map/java-map-jdk7-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中hashMap源码解析"><a href="#JDK7中hashMap源码解析" class="headerlink" title="JDK7中hashMap源码解析"></a>JDK7中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>hashMap底层数据结构是数组 + 单链表，对 key 计算 hashCode 散列到数组中， 相同的 hashCode 的 key 添加到同一个链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash标中的结点Node,实现了Map.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Entry构造器，需要key的hash，key，value和next指向的结点</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object的hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、HashMap-对象的属性"><a href="#2、HashMap-对象的属性" class="headerlink" title="2、HashMap 对象的属性"></a>2、HashMap 对象的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 默认初始容量-必须为2的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 最大容量，如果两个构造函数都使用参数隐式指定了更高的值，则使用该容量。必须是两个&lt;= 1 &lt;&lt; 30的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在构造函数中未指定时使用的负载系数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当表未膨胀时要共享的空表实例。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 该表，根据需要调整大小。长度必须始终为2的幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 此映射中包含的键-值映射数。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 下一个要调整大小的大小值（容量负载因子）。</span></span><br><span class="line"><span class="comment">// If table == EMPTY_TABLE then this is the initial capacity at which the</span></span><br><span class="line"><span class="comment">// table will be created when inflated.</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 哈希表的负载因子。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 对该HashMap进行结构修改的次数结构修改是指更改HashMap中的映射次数或以其他方式修改其内部结构（例如重新哈希）的修改。此字段用于使HashMap的Collection-view上的迭代器快速失败。 （请参见ConcurrentModificationException）。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default threshold of map capacity above which alternative hashing is</span></span><br><span class="line"><span class="comment"> * used for String keys. Alternative hashing reduces the incidence of</span></span><br><span class="line"><span class="comment"> * collisions due to weak hash code calculation for String keys.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * This value may be overridden by defining the system property</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> jdk.map.althashing.threshold&#125;. A property value of &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment"> * forces alternative hashing to be used at all times whereas</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> -1&#125; value ensures that alternative hashing is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 映射容量的默认阈值，高于该阈值时，字符串键将使用替代哈希。备用哈希可减少由于字符串键的哈希码计算能力较弱而导致的冲突发生率。 &lt;p&gt;可以通过定义系统属性&#123;@code jdk.map.althashing.threshold&#125;来覆盖此值。属性值&#123;@code 1&#125;强制始终使用替代哈希，而&#123;@code -1&#125;值确保从不使用替代哈希。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure><h1 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;，它具有默认的初始容量（16）和默认的负载系数（0.75）。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//使用指定的初始容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;。 @param initialCapacity初始容量@param loadFactor负载系数@throws IllegalArgumentException如果初始容量为负或负载系数为非正</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">       inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">       putAllForCreate(m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="4、put方法"><a href="#4、put方法" class="headerlink" title="4、put方法"></a>4、put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 将指定值与该映射中的指定键相关联。如果该映射先前包含该键的映射，则将替换旧值。 </span></span><br><span class="line"><span class="comment">// @param 与指定值关联的键key </span></span><br><span class="line"><span class="comment">// @param 与指定键关联的值</span></span><br><span class="line"><span class="comment">// @return 与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值&lt;tt&gt; key &lt;tt&gt;没有映射。 （返回&lt;tt&gt; null &lt;tt&gt;也可以表明该映射先前将&lt;tt&gt; null &lt;tt&gt;与&lt;tt&gt; key &lt;tt&gt;关联。）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次调用时，table是空的，进行初始化</span></span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 如果 key 值为空，则调用 putForNullKey 的方法</span></span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 计算 hash 值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Entry 数组数组中的位置，相当于对该数组取余。</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 遍历该位置上的链表</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 如果存在相同的 key 值， 则直接覆盖并返回旧值</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 没有找到，则添加该 entity</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="inflateTable-threshold"><a href="#inflateTable-threshold" class="headerlink" title="inflateTable(threshold)"></a>inflateTable(threshold)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inflates the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 填充表</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次初始化时调用</span></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="comment">// 找到 &gt;= 2 size的2的幂方数（ 例如：15 则是 16 , 17 则是 32）</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 计算阈值，16 * 0.75 = 12 （&gt;=size的2的幂方数 * 加载因子）</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putForNullKey-V-value"><a href="#putForNullKey-V-value" class="headerlink" title="putForNullKey(V value)"></a>putForNullKey(V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 空键的put方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 遍历下标是 0 的数组</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           <span class="comment">// 如果存在键值为 null ， 则覆盖原有的值，并且返回原始值 </span></span><br><span class="line">           <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 如果不存在，则添加元素节点</span></span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hash-Object-k"><a href="#hash-Object-k" class="headerlink" title="hash(Object k)"></a>hash(Object k)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">    * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">    * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">    * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">    * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检索对象哈希码，并将补充哈希函数应用于</span></span><br><span class="line"><span class="comment">    * 结果哈希，以防止质量差的哈希函数。 </span></span><br><span class="line"><span class="comment">    * 这很关键，因为HashMap使用2的幂的哈希表，否则</span></span><br><span class="line"><span class="comment">    * 哈希码的冲突在低位没有区别。注意：空键始终映射到哈希0，因此索引为0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       <span class="comment">// 此函数可确保在每个位位置仅相差</span></span><br><span class="line">       <span class="comment">// 恒定倍数的hashCode具有有限的冲突次数（默认负载因子为约8）。</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="indexFor-int-h-int-length"><a href="#indexFor-int-h-int-length" class="headerlink" title="indexFor(int h, int length)"></a>indexFor(int h, int length)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回哈希码h的索引。</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// hashCode 逻辑与(length-1)   所以要长度必须为2的非零幂</span></span><br><span class="line">       <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="addEntry(int hash, K key, V value, int bucketIndex)"></a>addEntry(int hash, K key, V value, int bucketIndex)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment">    * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment">    * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     将具有指定键，值和哈希码的新条目添加到指定存储桶。如果有必要，此方法负责调整表的大小。 </span></span><br><span class="line"><span class="comment">  子类重写此方法以更改put方法的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 添加元素， bucketIndex 表示数组下标</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 元素个数大于阈值，并且数组元素不为空</span></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           <span class="comment">// 2倍扩容</span></span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 扩容后重新计算数组的下标值</span></span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建元素节点</span></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="resize-int-newCapacity"><a href="#resize-int-newCapacity" class="headerlink" title="resize(int newCapacity)"></a>resize(int newCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">    * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">    * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">    * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">    * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">    *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">    *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">    *        is irrelevant).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">/ ** </span><br><span class="line">* 将此映射的内容重新映射为</span><br><span class="line">* 具有更大容量的新数组。当此映射中的</span><br><span class="line">* 键数达到其阈值时，将自动调用此方法。 </span><br><span class="line">* </span><br><span class="line">   * 如果当前容量为MAXIMUM_CAPACITY，则此方法不会</span><br><span class="line">* 调整地图大小，而是将阈值设置为Integer.MAX_VALUE。 </span><br><span class="line">* 这样可以防止将来的通话。 </span><br><span class="line">* </span><br><span class="line">   * <span class="meta">@param</span> newCapacity新容量，必须是<span class="number">2</span>的幂； </span><br><span class="line">   * 必须大于当前容量，除非当前</span><br><span class="line">   * 容量为MAXIMUM_CAPACITY（在这种情况下，无关紧要）。</span><br><span class="line">   * /</span><br><span class="line">   <span class="comment">// 扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="comment">// 数组最大扩容到2的30次方</span></span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       <span class="comment">// 把旧数组的所有元素拷贝到新数组里</span></span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       <span class="comment">// 扩容后，重新计算阈值</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="transfer-Entry-newTable-boolean-rehash"><a href="#transfer-Entry-newTable-boolean-rehash" class="headerlink" title="transfer(Entry[] newTable, boolean rehash)"></a>transfer(Entry[] newTable, boolean rehash)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有条目从当前表传输到newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 重新计算新数组的下标位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">// 头插法</span></span><br><span class="line">               e.next = newTable[i];</span><br><span class="line">               newTable[i] = e;</span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="createEntry(int hash, K key, V value, int bucketIndex)"></a>createEntry(int hash, K key, V value, int bucketIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment">    * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment">    * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment">    * clone, and readObject.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 与addEntry相似，只是在创建条目时将使用此版本</span></span><br><span class="line"><span class="comment">* 作为Map构造或“伪构造”（克隆，</span></span><br><span class="line"><span class="comment">* 反序列化）的一部分。此版本无需担心调整表的大小。 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">   * 子类重写此方法，以更改HashMap（Map），</span></span><br><span class="line"><span class="comment">   * clone和readObject的行为。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 创建元素，放在头节点</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">       table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="getForNullKey"><a href="#getForNullKey" class="headerlink" title="getForNullKey()"></a>getForNullKey()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Offloaded version of get() to look up null keys.  Null keys map</span></span><br><span class="line"><span class="comment"> * to index 0.  This null case is split out into separate methods</span></span><br><span class="line"><span class="comment"> * for the sake of performance in the two most commonly used</span></span><br><span class="line"><span class="comment"> * operations (get and put), but incorporated with conditionals in</span></span><br><span class="line"><span class="comment"> * others.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Entry-lt-K-V-gt-getEntry-Object-key"><a href="#Entry-lt-K-V-gt-getEntry-Object-key" class="headerlink" title="Entry&lt;K,V&gt; getEntry(Object key)"></a>Entry&lt;K,V&gt; getEntry(Object key)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the entry associated with the specified key in the</span></span><br><span class="line"><span class="comment">  * HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment">  * for the key.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">             ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="6-常见面试题"><a href="#6-常见面试题" class="headerlink" title="6. 常见面试题"></a>6. 常见面试题</h1><h2 id="6-1-HashMap的put方法逻辑"><a href="#6-1-HashMap的put方法逻辑" class="headerlink" title="6.1 HashMap的put方法逻辑"></a>6.1 HashMap的put方法逻辑</h2><ol><li>判断entry是否是空数组，如果是初始化一个长度是16，阈值是12的数组</li><li>判断key是否等于null，如果是null，就放在下标是0的数组位置上，并插入头结点</li><li>对key的hashCode二次hash，并对(length-1)逻辑与，算出数组下标位置</li><li>遍历该下标位置上的链表，如果找到该key，就覆盖旧值并返回</li><li>判断当前元素个数是否大于阈值，如果大于就执行2倍扩容，把原数组的元素重新hash到新数组中</li><li>用当前key创建一个节点，插到下标数组链表的头结点</li></ol><h2 id="6-2-为什么HashMap的容量必须是2的倍数"><a href="#6-2-为什么HashMap的容量必须是2的倍数" class="headerlink" title="6.2 为什么HashMap的容量必须是2的倍数"></a>6.2 为什么HashMap的容量必须是2的倍数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算机中，与运算比求余运算更快，采用了 hashCode &amp; (length-1)。</strong> </p><blockquote><p> 假如length是16，(length-1)的二进制就是 1111，比15小的数逻辑与之后就是自身，比15大的数，只有低4位的数才能运算出值。是为了更方便与运算。</p></blockquote><h2 id="6-3-HashMap线程不安全体现在哪些方面？"><a href="#6-3-HashMap线程不安全体现在哪些方面？" class="headerlink" title="6.3 HashMap线程不安全体现在哪些方面？"></a>6.3 HashMap线程不安全体现在哪些方面？</h2><p>由于hash冲突的时候插入链表，采用的是头插法，导致扩容后链表的顺序和原来顺序相反，多个线程同时扩容会出现环形链表，get的时候陷入死循环。</p><h1 id="7-HashMap还有哪些缺点"><a href="#7-HashMap还有哪些缺点" class="headerlink" title="7. HashMap还有哪些缺点"></a>7. HashMap还有哪些缺点</h1><ol><li>使用单链表解决hash冲突，导致最坏的情况get的效率降至O(N)</li><li>链表采用头插法，导致多线程扩容出现环形链表</li><li>扩容需要把每个元素重新hash放到新数组里，性能太差</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--线程池</title>
      <link href="2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul><li>线程池提供了一种限制和管理资源</li><li>好处：<ul><li>降低资源消耗：线程的创建和销毁需要消耗资源</li><li>提高响应速度：当任务达到的时候，任务可以不用等待线程创建就能立即执行</li><li>提高线程的可管理性：线程是稀缺资源，不可以无限创建，需要统一分配和调度、监控</li></ul></li></ul><h1 id="Runable接口和Callable接口的区别"><a href="#Runable接口和Callable接口的区别" class="headerlink" title="Runable接口和Callable接口的区别"></a>Runable接口和Callable接口的区别</h1><ul><li>Runable 接口没有返回结果和抛出异常</li><li>Callable 接口偶返回结果和抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h1><h2 id="使用-Executors"><a href="#使用-Executors" class="headerlink" title="使用 Executors"></a>使用 Executors</h2><blockquote><p>// 允许创建线程的数量为 Integer.MAX_VALUE，可能会导致创建大量线程，从而导致 OOM</p><p>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</p><p>// 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM<br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</p><p>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</p><p>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</p></blockquote><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><ul><li>FixedThreadPool ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的数量始终不变。当有一个新的任务提交时，线程池中若有空闲的线程，则立即执行。若没有，则新的任务会暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>FixedThreadPool ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li><li>因为最大线程数固定，不会拒绝任务，在任务比较多的时候会导致 OOM</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610064973712.png" alt="1610064973712"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul><li>SingkeThreadExecutor：方法返回<strong>一个只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会碑额保存在一个队列中，等待线程空闲，按先入先出的顺序执行队列中的任务。</li><li>SingleThreadExecutor ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065305945.png" alt="1610065305945"></p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><ul><li>CachedThreadPool：<strong>可以根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可以复用的线程。若所有的线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<ul><li>CachedThreadPool 的 corePoolSize 被设置为空 (0) , maxinumPoolSize 被设置为 Integer.MAX_VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maxinunPool 中线程处理任务的速度时， CacheThreadPool 会不断创建新的线程，极端情况下，这样会导致耗尽 CPU 和 内存资源。</li><li>CacheThreadPool 允许创建的线程数量为 Integer.MAX_VALUE , 可能会创建大量线程，造成 OOM.</li></ul></li></ul><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><ul><li>ScheduledThreadPool：创建一个定长线程池，支持 定时及周期性任务执行</li><li>ScheduledThreadPoolExecutor ：使用的任务队列 DelayQueue 封装了一个 PriortyQueue 会对队列中的任务进行排序，执行所需时间段的放在前面先被执行 （ScheduleFuture 的 time 变量小的先执行），如果执行所需时间相同则先提交的任务将被先执行 （ScheduleFuture 的 squenceNumber 变量小的先执行）。</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065993004.png" alt="1610065993004"></p><h2 id="使用-ThreadPoolExecutor"><a href="#使用-ThreadPoolExecutor" class="headerlink" title="使用 ThreadPoolExecutor"></a>使用 ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>corePoolSize：核心线程数线程数定义了<strong>最小可以同时运行的线程数量</strong>。</p></li><li><p>maxinumPoolSize：当<strong>队列中存在的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</strong>。</p></li><li><p>workQueue：当<strong>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放在队列中</strong>。</p></li><li><p>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</p></li><li><p>unit：keepAliveTime 参数的时间单位。</p></li><li><p>threadFactory：executor 创建新线程的时候会用到</p></li><li><p>handler ：饱和策略，<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略</strong></p><ul><li>ThreadPoolExecutor.<strong>AbortPolicy</strong>：抛出  RejectedExecutionException 来拒绝新任务的处理。</li><li>ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>：调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行 (run) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务的提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.<strong>DiscardPolicy</strong>： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.<strong>DiscardOldestPolicy</strong>： 此策略将丢弃最早的未处理的任务请求。</li></ul></li></ul><h3 id="ThreadPoolExecutor中的execute方法和submit方法区别"><a href="#ThreadPoolExecutor中的execute方法和submit方法区别" class="headerlink" title="ThreadPoolExecutor中的execute方法和submit方法区别"></a>ThreadPoolExecutor中的execute方法和submit方法区别</h3><ul><li>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li><li>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值， get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h3 id="shutdown-和shutDownNow"><a href="#shutdown-和shutDownNow" class="headerlink" title="shutdown()和shutDownNow()"></a>shutdown()和shutDownNow()</h3><ul><li>shutdown()：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow()：关闭线程池，线程的状态变为 STOP。线程池会终止正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h3><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                MAX_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                KEEP_ALIVE_TIME,<span class="comment">//</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//  executor.execute(worker);</span></span><br><span class="line">            Future&lt;?&gt; result = executor.submit(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h1><p>需要根据实际业务场景来划分</p><ul><li>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存泄漏--ThreadLocal</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>内存泄漏是堆内存中不再使用的对象，但是垃圾收集器没有将它们删除的情况，因此它们将会被不必要的一直存在。这样会消耗内存资源，降低系统性能，最终可能导致OOM发生。</li></ul><h1 id="Java中内存泄漏的类型"><a href="#Java中内存泄漏的类型" class="headerlink" title="Java中内存泄漏的类型"></a>Java中内存泄漏的类型</h1><h2 id="static字段引起内存泄漏"><a href="#static字段引起内存泄漏" class="headerlink" title="static字段引起内存泄漏"></a>static字段引起内存泄漏</h2><ul><li>静态的资源一般与整个应用拥有相匹配的生命周期</li><li>尽量减少使用。</li></ul><h2 id="未关闭的资源导致内存泄漏"><a href="#未关闭的资源导致内存泄漏" class="headerlink" title="未关闭的资源导致内存泄漏"></a>未关闭的资源导致内存泄漏</h2><ul><li>创建连接或打开流时，JVM会为这些资源分配内存。如果连接没有关闭，会导致占有内存。</li><li>可以在finally块中或try-with-resources块中关闭</li></ul><h2 id="不正确的hashCode和equals"><a href="#不正确的hashCode和equals" class="headerlink" title="不正确的hashCode和equals"></a>不正确的hashCode和equals</h2><ul><li>重写不合理会导致内存泄漏</li><li>用最佳的方式重写hashCode和equals</li></ul><h2 id="引用了外部类的内部类"><a href="#引用了外部类的内部类" class="headerlink" title="引用了外部类的内部类"></a>引用了外部类的内部类</h2><ul><li>使用了一个非静态的内部类对象，这个时候内部类依赖于外部类对象。即使用完了内部类，这个对象也不会被收集</li><li>如果内部类不访问外部类的成员，可以转换为静态类</li></ul><h2 id="重写了finalize方法"><a href="#重写了finalize方法" class="headerlink" title="重写了finalize方法"></a>重写了finalize方法</h2><h2 id="ThreadLoacl造成内存泄漏"><a href="#ThreadLoacl造成内存泄漏" class="headerlink" title="ThreadLoacl造成内存泄漏"></a>ThreadLoacl造成内存泄漏</h2><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><ul><li>每个线程拥有自己本地专属的变量，可以用ThreadLoal类。</li><li>ThreadLoal类让每个线程绑定自己的值，存储线程私有数据。避免线程出现竞争。</li><li>ThreadLocal类是使用ThreadLoalMap类来实现定制化的HashMap的。调用ThreadLocal类的set或get方法，实际调用的是ThreadLocalMap类的get、set方法。</li><li>变量最终是存在ThreadLocalMap中。</li><li>ThreadLocalMap可以存以ThreadLocal为key，Object对象为value的值对。</li><li>ThreadLocalMap中的key是ThreadLocal的弱引用，而value是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。</li><li>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录<strong>。使用完 ThreadLocal方法后 最好手动调用remove()方法</strong></li></ul><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><blockquote><ul><li><p>每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行set方法中，是从当前线程的<code>threadLocals</code>变量获取。</p></li><li><p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p></li></ul></blockquote><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><blockquote><p>没有链表结构，那发生hash冲突了怎么办？</p><ol><li>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小<code>0x61c88647</code>。</li><li>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：<ol><li>如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； </li><li>不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value； </li><li>很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</li></ol></li><li>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</li><li>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--AQS</title>
      <link href="2020/12/31/java/juc/java-juc-AQS/"/>
      <url>2020/12/31/java/juc/java-juc-AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><ul><li>AQS 是一个用来构建锁和同步器的框架</li></ul><h1 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h1><ul><li><p>如果请求的资源空闲，当前请求资源的线程就可以获取资源，并且给资源加上锁。如果当前请求的资源被暂用，就需要一套阻塞和唤醒机制，AQS使用CLH队列实现，将目前获取不到资源的锁的现场，加入到队列中</p></li><li><p>CLH 队列</p><ul><li>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个节点 （Node） 来实现锁的分配。</li><li>虚拟的双向队列，并没有队列实例，仅存在节点间的指向关系。</li></ul></li><li><p>AQS 使用一个volatile int state 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。 AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p></li></ul><h1 id="AQS-资源共享方式"><a href="#AQS-资源共享方式" class="headerlink" title="AQS 资源共享方式"></a>AQS 资源共享方式</h1><ul><li> Exclusive (独占)：：只有一个线程能执行， 如 ReentantLock</li><li>Share（共享）：多个线程可同时执行， 如 Semaphore/CountDownLatch</li></ul><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>在 AQS 独占式资源共享方式中</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到先拿到锁。</li><li>非公平锁：当线程要获取锁时，无视队列的顺序直接去抢锁（CAS），谁先抢到就是谁的</li></ul><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><ul><li>以 ReentrantLock 为例， state 初始化为 0 ， 表示未锁定状态。 A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 share +1 。此后，其他现场再 tryAcquire() 时就会失败， 直到 A 线程 unlock() 到 state = 0 （即释放锁）为止， 其他线程才有机会获取该锁。当然，锁释放之前， A 线程自己是可以重复获取此锁的 （state 会累加），这就是可重入的概念。但是要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的</li></ul><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><ul><li>再以 CountDownLatch 为例，任务分配为 N 个线程去执行， state 也初始化为 N（注意 N 要与线程个数一致）。 该 N 个子线程是并行执行的， 每个子线程执行完后 countDown() 一次， state 会 CAS 减1。等到所有子线程都执行完后 （即 state =0）, 会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</li><li>（倒计时器）： CountDownLatch 是一个同步工具类， 用来协调多个线程之间同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，在开始执行。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><ul><li>Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源， Semaphore （信号量）可以指定多个线程同时访问某个资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> num = i;</span><br><span class="line">       cachedThreadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//请求获得许可，如果有可获得的许可则继续往下执行，许可数减1。否则进入阻塞状态</span></span><br><span class="line">                   semaphore.acquire();</span><br><span class="line">                   <span class="comment">//执行</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;Accessing: &quot;</span> + num);</span><br><span class="line">                   Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 模拟随机执行时长</span></span><br><span class="line">                   <span class="comment">//释放</span></span><br><span class="line">                   semaphore.release();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Release...&quot;</span> + num);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cachedThreadPool.shutdown();</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h1><ul><li>可以实现线程间的技术等待</li><li>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--JMM和volatile关键字</title>
      <link href="2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM和volatile关键字"><a href="#JMM和volatile关键字" class="headerlink" title="JMM和volatile关键字"></a>JMM和volatile关键字</h1><h1 id="JMM相关"><a href="#JMM相关" class="headerlink" title="JMM相关"></a>JMM相关</h1><h2 id="CPU缓存模型"><a href="#CPU缓存模型" class="headerlink" title="CPU缓存模型"></a>CPU缓存模型</h2><blockquote><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。<strong>于是就有了在CPU和主内存之间增加缓存的设计</strong>。最靠近CPU的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p><ul><li>CPU访问数据 -&gt; L1 L2 高速缓存 -&gt; 一致性协议 -&gt; 内存</li></ul></blockquote><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609942893338.png" alt="1609942893338"></p><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><ul><li><p>JMM描述的是变量存储到内存和从内存中读取变量的细节。</p></li><li><p>Java中实例变量和类变量都是存在于主内存，是线程共享的。</p><blockquote><ul><li>每个线程都有一个自己的工作内存，它从主内存读取数据到工作内存中进行使用。这样就可能造成了一个线程在主内存中修改了一个变量的值，而另一个线程还在使用之前拷贝的值，就造成了数据的不一致型。</li><li>解决：把变量声明为volatile，指示这个变量是不稳定的，没用使用的时候需要从主内存中读取。</li></ul></blockquote></li></ul><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609943944217.png" alt="1609943944217"></p><blockquote><ul><li>主内存 所有线程共享的内存区域 线程内存 线程自己私有的内存区域 主内存和线程内存通过save和load操作进行交互 所有提到的内存区域并不是真实存在的，而是虚拟存在的，就和虚拟机的运行时数据区一样。</li></ul></blockquote><h2 id="JMM-的八种内存交互操作"><a href="#JMM-的八种内存交互操作" class="headerlink" title="JMM 的八种内存交互操作"></a>JMM 的八种内存交互操作</h2><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609946346742.png" alt="1609946346742"></p><ol><li>lock(锁定)：作用于<strong>主内存</strong>中的变量，一个变量在同一时间只能被一个线程锁定，即把变量标识为线程<strong>独占</strong>状态。</li><li>read(读取)：作用于<strong>主内存</strong>变量，表示把一个变量值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。</li><li>load(载入)：作用于线程的<strong>工作内存</strong>的变量，表示把 read 操作从主内存中读取的变量值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</li><li>use(使用)：作用于线程的<strong>工作内存</strong>中的变量，表示把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</li><li>assign(赋值)：作用于线程的<strong>工作内存</strong>的变量，表示把执行引擎返回的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</li><li>store(存储)：作用于线程的<strong>工作内存</strong>中的变量，把工作内存中的一个变量的值传递给主内存，以便下一步的 write 操作使用。</li><li>write(写入)：作用于<strong>主内存</strong>的变量，表示把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，表示把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ol><p>JMM 还规定了以上八种操作需按照如下规则进行：</p><ul><li>不允许read 和 load、store 和 write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许线程将没有 assign 的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施 use 和 store 操作之前，必须经过 load 和 assign 操作。</li><li>一个变量同一时间只能有一个线程对其进行 lock 操作。但 lock 操作可以被同一条线程重复执行多次，多次 lock 之后，必须执行相同次数 unlock 才可以解锁。</li><li>如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。</li><li>如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="JMM-三大特征"><a href="#JMM-三大特征" class="headerlink" title="JMM 三大特征"></a>JMM 三大特征</h2><blockquote><p>JMM 三大特征分别是：原子性，可见性，有序性。整个 JMM 实际上也是围绕着这三个特征建立起来的，并且也是 Java 并发编程的基础。</p></blockquote><p><strong>原子性</strong>：原子性是指一个操作是不可分割、不可中断的，要么全部执行成功要么全部执行失败。</p><ul><li>synchronized 修饰的代码块之间的操作都是原子性的，<strong>volatile不保证原子性</strong></li></ul><p><strong>可见性</strong>：可见性是指所有线程都能看到共享内存的最新状态。即当一个线程修改了一个共享变量的值时，其他线程能够立即看到该变量的最新值。</p><ul><li>volatile 关键字之外，final 和 synchronized 也能实现可见性。</li></ul><p><strong>有序性</strong>：有序性是指程序执行的顺序按照代码的先后顺序执行。</p><ul><li><p>可以通过 volatile 和 synchronized 关键字来保证多线程之间操作的有序性。</p><ul><li><p>volatile 关键字是通过在主存中加入内存屏障来达到禁止指令重排序，来保证有序性。</p></li><li><p>synchronized 关键字原理是，一个变量在同一时刻只能被一个线程 lock，并且必须 unlock 后，其他线程才可以重新 lock，使得被 synchronized 修饰的代码块在多线程之间是串行执行的。</p></li></ul></li></ul><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li>volatitle可以保证变量的可见性。</li></ul><h2 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h2><ul><li>volatile写是在前⾯和后⾯分别插⼊<strong>内存屏障</strong>，⽽volatile读操作是在后⾯插⼊两个内存屏障。</li></ul><h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><blockquote><p>compare-and-swap–比较并替换</p></blockquote><ul><li>CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：如果当前值等于预期值，则将内存修改为新值，否则不做任何操作。</li><li>Java中Unsafe类</li><li>每次在执行CAS操作时，线程会根据valueOffset去内存中获取当前值去跟expect的值做对比如果一致则修改并返回true，如果不一致说明有别的线程也在修改此对象的值，则返回false</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><ul><li>一个线程对变量进行了修改，然后又修改会原来的值，对于其他线程来说好像没有变化。</li><li>解决ABA最简单的方案就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号</li></ul><h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><ul><li>volatile是线程同步的轻量级实现，只能修饰变量；而synchronized可以修饰方法及代码块</li><li>volatile关键字能够保证数据的可见性，不能保证数据的原子性；synchronized两者都可以保证</li><li>volatile解决的是多个线程访问变量的可见性；synchronized解决的是多线程之间访问资源的同步性</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--synchronized</title>
      <link href="2020/12/31/java/juc/java-juc-synchronized/"/>
      <url>2020/12/31/java/juc/java-juc-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>synchronized 是为了解决多线程同步访问资源的问题。 synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li><li>Java多线程依赖于操作系统原生线程，所以挂起或者唤醒一个线程，需要操作系统帮忙完成。而操作系统需要从用户状态切换成内核状态，时间相对较长，时间成本高。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>修改实例方法：作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</p><blockquote><p>多个线程操作同一个实例的加锁方法时，线程安全</p></blockquote></li><li><p>修饰静态方法：作用于当前类对象(Class对象，每个类都有一个Class对象)，进入同步代码前要获得当前类对象（Class对象）的锁。</p><blockquote><p>多个线程操作同一个Class的多个实例时，线程安全。（如果是非静态方法加的synchronized那么则是不安全的，因为不是同一把锁）</p></blockquote></li><li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><blockquote><ul><li><p>synchronized(this){}，当前实例对象锁</p></li><li><p>synchronized(ObjA.class){}，class对象锁</p></li></ul></blockquote></li></ul><blockquote><ul><li>在 java 中，每一个对象有且仅有一个同步锁。这也意味着：同步锁是依赖于对象存在的。</li><li>当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。（例如：synchronized(ObjA) 就获取了 “ObjA这个对象” 的同步锁）</li><li>不同线程对同步锁的访问是互斥的。（也就是说：某个时间点，对象的同步锁只能被一个线程获取到，通过同步锁，能实现多线程间 “对象/方法” 的互斥访问）</li></ul></blockquote><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头</strong>（Header），<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong></p><ul><li>普通对象的对象头包含两个部分：<strong>Mark Word</strong> 和 <strong>Class Metadata Address</strong> （类型指针）</li><li>如果是数组的对象头还额外包括 <strong>Array length</strong> 数组长度部分</li></ul><h3 id="Mark-word："><a href="#Mark-word：" class="headerlink" title="Mark word："></a>Mark word：</h3><ul><li>用于存储对象自身的运行时数据，如 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li></ul><h3 id="Class-Metadata-Address：类型指针"><a href="#Class-Metadata-Address：类型指针" class="headerlink" title="Class Metadata Address：类型指针"></a>Class Metadata Address：类型指针</h3><ul><li>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪一个类的实例</li></ul><h3 id="Array-length：数组长度"><a href="#Array-length：数组长度" class="headerlink" title="Array length：数组长度"></a>Array length：数组长度</h3><ul><li>如果对象是数组类型。则虚拟机用3个 Word （字宽）存储对象头，如果对象是非数组类型，则用 2 字节宽存储对象头。在 32 位虚拟机中，一字节宽等于 4 字节，及 32bit。</li></ul><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象hashCode或锁信息等运行时数据。</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><h4 id="Mark-Word详解"><a href="#Mark-Word详解" class="headerlink" title="Mark Word详解"></a>Mark Word详解</h4><p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><blockquote><p>例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，MarkWord的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，</p><p>在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p></blockquote><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609892506114.png" alt="1609892506114"></p><h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><ul><li><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做<strong>内部锁</strong>或者<strong>Monitor锁</strong>。</p></li><li><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系又存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header       = <span class="literal">NULL</span>;</span><br><span class="line">   _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">   _waiters      = <span class="number">0</span>,</span><br><span class="line">   _recursions   = <span class="number">0</span>;</span><br><span class="line">   _object       = <span class="literal">NULL</span>;</span><br><span class="line">   _owner        = <span class="literal">NULL</span>;</span><br><span class="line">   _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">   _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">   _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">   _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609893330560.png" alt="1609893330560"></p><h2 id="synchronized-关键字底层原理是JVM层面的"><a href="#synchronized-关键字底层原理是JVM层面的" class="headerlink" title="synchronized 关键字底层原理是JVM层面的**"></a>synchronized 关键字底层原理是JVM层面的**</h2><h3 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h3><ol><li>synchronized 同步语句块的实现使用的是 <strong>monitorenter</strong> 和 <strong>monitoreexit</strong> 指令， 其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置</li><li>当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor 对象的特有权。<strong>当计数器为 0 则可以成功获取monitor</strong>，获取后将锁计数器设为 1 就是 加1 （<strong>重入时计数器的值也会加 1</strong>）， 。相对应的在执行 monitorexit 指令后， 所得计数器就会 -1，当锁计数器变为0，标明锁被释放。</li><li>如果获取对象的锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li><li>（monitor 对象存在于每个 java 对象的对象头中 ，synchronized 锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因）</li></ol><h3 id="synchronized-修饰方法的情况"><a href="#synchronized-修饰方法的情况" class="headerlink" title="synchronized 修饰方法的情况"></a>synchronized 修饰方法的情况</h3><ol><li><p>JVM 通过 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p></li><li><p>用的是一个隐式的 monitorenter 和 monitorexit 指令。</p><blockquote><ol><li>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。</li><li>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</li><li>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词），然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</li><li>在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</li></ol></blockquote></li></ol><h2 id="synchronized-锁优化的过程（锁升级）"><a href="#synchronized-锁优化的过程（锁升级）" class="headerlink" title="synchronized 锁优化的过程（锁升级）"></a>synchronized 锁优化的过程（锁升级）</h2><ul><li>锁的状态有：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，随着锁竞争的激烈而逐渐升级。锁只可以升级不可以降级，这种策略是为了提高获取锁和释放锁的效率。</li></ul><blockquote><p>Synchronized的实现依赖于与某个对象向关联的monitor（监视器）实现，而monitor是基于底层操作系统的Mutex Lock实现的，而基于Mutex Lock实现的同步必须经历从用户态到核心态的转换，这个开销特别大，成本非常高。所以频繁的通过Synchronized实现同步会严重影响到程序效率，而这种依赖于Mutex Lock实现的锁机制也被称为“重量级锁”，为了减少重量级锁带来的性能开销，JDK对Synchronized进行了种种优化。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>单个线程重复访问资源的时候没有必要向操作系统重新申请轻量级锁。</li></ul><h4 id="获取锁："><a href="#获取锁：" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><h4 id="释放锁："><a href="#释放锁：" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><p><strong>偏向锁的释放采用了一种只有竞争才会释放锁的机制</strong>，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><blockquote><p>在有锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里?</p><p>下面先看偏向锁的情况，偏向锁时，mark word中记录了线程id，没有足够的额外空间存储hashcode，所以，答案是：</p><ol><li>当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；</li><li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li><li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。</li></ol><p>因为mark word里没地方同时放bias信息和identity hash code。 HotSpot VM是假定“实际上只有很少对象会计算identity hash code”来做优化的；换句话说如果实际上有很多对象都计算了identity hash code的话，HotSpot VM会被迫使用比较不优化的模式。</p></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>多个线程重复访问资源的时候，可以使用指针竞争的方式来获取轻量级锁</li></ul><h4 id="获取锁：-1"><a href="#获取锁：-1" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><h4 id="释放锁：-1"><a href="#释放锁：-1" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><pre><code>&gt; 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</code></pre><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p><blockquote><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p></blockquote><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><ul><li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li>如果没有在第一时间获取到轻量级锁，可能需要等一会儿就可以获取锁。这时使用 CAS 的操作不断自旋该线程。默认限定 10 次，没有获取锁，就用传统方式挂起线程。</li><li>在自旋的基础上， Java1.6 引入了适应性自旋锁。它的等待时间不是固定的，而是由前一次操作的时间以及锁拥有的状态来决定。</li></ul><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><ul><li><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p></li><li><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法。</li></ul><h3 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h3><ul><li>偏向锁：通常只有一个线程访问临界区</li><li>轻量级锁：可以有多个线程交替进入临界区，竞争不激烈的时候，稍微自旋就能获得锁</li><li>重量级锁：线程间出现激烈的竞争就需要重量级锁，未获得锁的线程就会进入阻塞队列，需要操作系统介入。</li></ul><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的开销，和执行非同步方法比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td><td>追求响应时间。同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>锁竞争不适用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="锁的膨胀流程图解"><a href="#锁的膨胀流程图解" class="headerlink" title="锁的膨胀流程图解"></a>锁的膨胀流程图解</h3><p><img src="/2020/12/31/java/juc/java-juc-synchronized/165adaeab7580a64.png" alt="165adaeab7580a64"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--基本概念</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程：程序的一次执行过程，程序的运行就是一个进程从创建、运行到消亡的过程。进程是计算机运行的基本单位，进程之间是相互独立的。</li><li>线程：线程是 CPU 执行的基本单位，一个进程可以分为多个线程，多个线程对进程的资源使用存在竞争关系。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>创建：线程 new 之后进入创建状态，调用 start() 方法进入就绪状态。</li><li>就绪：线程就绪状态需要等待 CPU 调用执行</li><li>运行：线程获取了 CPU 时间，进入运行中状态</li><li>等待：wait、join、LockSupport.park 进入等待状态，需要其他线程通知才能进入运行状态 （notify、notifyAll、LockSupport.unPark）</li><li>超时等待：在等待的基础上加了一个超时时间，超时时间到了就自动进入运行状态（sleep，wait（long），LockSupport.pariUntil，LockSupport.parkNanos）</li><li>阻塞：线程调用同步方法或者代码块，未获得锁时，进入阻塞状态</li><li>终止：线程执行完 run 方法后进入终止状态</li></ul><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li>并行：多个处理器上，执行多个任务</li><li>并发：单个处理器上，多个任务交替执行。线程通过轮询获取 CPU 的执行时间。</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>多个线程同时被阻塞，他们中的一个或者多个都在等待某个资源被释放。由于无限期的阻塞，线程无法正常终止。</li></ul><h2 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件"></a>线程死锁的四个必要条件</h2><ul><li>互斥条件：某一个资源某一时刻只能有一个线程使用</li><li>请求和保持条件：一个线程在请求其他资源的时候，对其中持有的资源不释放</li><li>不可剥夺条件：线程已获得的资源在未使用的情况下不能被其他线程强行剥夺，只能由该线程使用完毕后自己释放</li><li>循环等待条件：多个线程形成的一种首位相接的等待资源的关系。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul><li><p>破坏线程死锁产生的四个条件之一</p><blockquote><ul><li>破坏互斥条件：这个条件我们没法破坏，因为我们用锁本来就是想让他们互斥（临界资源需要互斥访问）</li><li>破坏请求和保持条件：一次性申请所有的资源。</li><li>破坏不可剥夺条件：占用部分资源的现场进一步申请其他资源时，如果申请不到，可以主动释放他自己占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。</li></ul></blockquote></li></ul><h2 id="sleep和yeild方法"><a href="#sleep和yeild方法" class="headerlink" title="sleep和yeild方法"></a>sleep和yeild方法</h2><ul><li>sleep方法在超时等待一定时间后会自动唤醒，进入就绪状态；yield方法是当前线程进入就绪状态线程调</li><li>sleep方法后，无论其他线程的优先级都有机会运行；执行yield方法，只会给相同优先级或更高优先级的方法的线程运行的机会</li><li>sleep方法会抛出InterruptedException异常，而yield方法没有任何异常声明</li><li>循环中调用yield方法，yield死循环：线程yield之后有获得了cpu，导致其他线程无法获取资源</li></ul><h2 id="调用start方法，为什么不直接调用run方法"><a href="#调用start方法，为什么不直接调用run方法" class="headerlink" title="调用start方法，为什么不直接调用run方法"></a>调用start方法，为什么不直接调用run方法</h2><ul><li>调用 start 方法方可启动线程并使线程进入就绪状态，</li><li>而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li></ul><h2 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h2><ul><li>继承Thread类</li><li>实现Runable接口，实现run方法</li><li>实现Callable接口，实现call方法</li><li>使用线程池</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式id</title>
      <link href="2020/12/21/java/distributed/java-distributed-id/"/>
      <url>2020/12/21/java/distributed/java-distributed-id/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式ID生成器"><a href="#分布式ID生成器" class="headerlink" title="分布式ID生成器"></a>分布式ID生成器</h1><h2 id="一、需求缘起"><a href="#一、需求缘起" class="headerlink" title="一、需求缘起"></a><strong>一、需求缘起</strong></h2><p>几乎所有的业务系统，都有生成一个唯一记录标识的需求，例如：</p><ul><li>消息标识：message-id</li><li>订单标识：order-id</li><li>帖子标识：tiezi-id</li></ul><p>这个记录标识往往就是数据库中的<strong>主键</strong>，数据库上会建立<strong>聚集索引</strong>（cluster index），即在物理存储上以这个字段排序。</p><p>这个记录标识上的查询，往往又有分页或者排序的业务需求，例如：</p><ul><li><p>拉取最新的一页消息</p><p>select message-id/ order by time/ limit 100</p></li><li><p>拉取最新的一页订单</p><p>select order-id/ order by time/ limit 100</p></li><li><p>拉取最新的一页帖子</p><p>select tiezi-id/ order by time/ limit 100</p></li></ul><p>所以往往要有一个time字段，并且在time字段上建立<strong>普通索引</strong>（non-cluster index）。</p><p>普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：</p><p>select message-id/ (order by message-id)/limit 100</p><p>强调，能这么做的前提是，message-id的生成基本是<strong>趋势时间递增的</strong>。</p><p>这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：</p><ul><li>全局唯一</li><li>趋势有序</li></ul><p>这也是本文要讨论的核心问题：<strong>如何高效生成趋势有序的全局唯一ID。</strong></p><h2 id="二、常见方法、不足与优化"><a href="#二、常见方法、不足与优化" class="headerlink" title="二、常见方法、不足与优化"></a><strong>二、常见方法、不足与优化</strong></h2><h3 id="方法一：使用数据库的-auto-increment-来生成全局唯一递增ID"><a href="#方法一：使用数据库的-auto-increment-来生成全局唯一递增ID" class="headerlink" title="方法一：使用数据库的 auto_increment 来生成全局唯一递增ID"></a><strong>方法一：使用数据库的 auto_increment 来生成全局唯一递增ID</strong></h3><p><strong>优点：</strong></p><ul><li>简单，使用数据库已有的功能</li><li>能够保证唯一性</li><li>能够保证递增性</li><li>步长固定</li></ul><p><strong>缺点：</strong></p><ul><li>可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了</li><li>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展</li></ul><p><strong>改进方法：</strong></p><ul><li>冗余主库，避免写入单点</li><li>数据水平切分，保证各主库生成的ID不重复</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f37346638636339373866393034366533386536313364346430643330363938642e6a7067" alt="img"></p><p>如上图所述，由1个写库变成3个写库，<strong>每个写库设置不同的auto_increment初始值，以及相同的增长步长</strong>，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）</p><p>改进后的架构保证了可用性，但<strong>缺点</strong>是：</p><ul><li>丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增）</li><li>数据库的写压力依然很大，每次生成ID都要访问数据库</li></ul><p>为了解决上述两个问题，引出了第二个常见的方案。</p><h3 id="方法二：单点批量ID生成服务"><a href="#方法二：单点批量ID生成服务" class="headerlink" title="方法二：单点批量ID生成服务"></a><strong>方法二：单点批量ID生成服务</strong></h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</p><p>数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。</p><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f39336165303932633465386334643361613932613539616661383161626235332e6a7067" alt="img"></p><p>如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。</p><p>ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了。</p><p>当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。</p><p><strong>优点</strong>：</p><ul><li>保证了ID生成的绝对递增有序</li><li>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</li></ul><p><strong>缺点</strong>：</p><ul><li>服务仍然是单点</li><li>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）</li><li>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</li></ul><p><strong>改进方法</strong>：</p><p>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：</p><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f34343963323232663763333434323039616634346466383330343739646464652e6a7067" alt="img"></p><p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。</p><p>这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived，具体就不在这里展开。</p><p>另外，ID-gen-service也可以实施水平扩展，以解决上述缺点（3），但会引发一致性问题，具体解决方案详见。</p><h3 id="方法三：uuid-guid"><a href="#方法三：uuid-guid" class="headerlink" title="方法三：uuid/guid"></a><strong>方法三：uuid/guid</strong></h3><p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。</p><p>有没有一种本地生成ID的方法，即高性能，又时延低呢？</p><p>uuid是一种常见的方案：</p><p>string ID =GenUUID();</p><p><strong>优点</strong>：</p><ul><li>本地生成ID，不需要进行远程调用，时延低</li><li>扩展性好，基本可以认为没有性能上限</li></ul><p><strong>缺点</strong>：</p><ul><li>无法保证趋势递增</li><li>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</li></ul><h3 id="方法四：取当前毫秒数"><a href="#方法四：取当前毫秒数" class="headerlink" title="方法四：取当前毫秒数"></a><strong>方法四：取当前毫秒数</strong></h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？</p><p>取当前毫秒数是一种常见方案：</p><p>uint64 ID = GenTimeMS();</p><p><strong>优点</strong>：</p><ul><li>本地生成ID，不需要进行远程调用，时延低</li><li>生成的ID趋势递增</li><li>生成的ID是整数，建立索引后查询效率高</li></ul><p><strong>缺点</strong>：</p><ul><li>如果并发量超过1000，会生成重复的ID</li></ul><p>这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</p><h3 id="方法五：类snowflake算法"><a href="#方法五：类snowflake算法" class="headerlink" title="方法五：类snowflake算法"></a><strong>方法五：类snowflake算法</strong></h3><p>snowflake是twitter开源的分布式ID生成算法，其<strong>核心思想为，</strong>一个long型的ID：</p><ul><li>41bit作为毫秒数</li><li>10bit作为机器编号</li><li>12bit作为毫秒内序列号</li></ul><p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p><p>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现<strong>自己的分布式ID生成算法</strong>。</p><p>举例，假设某公司ID生成器服务的需求如下：</p><ul><li>单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W</li><li>有2个机房，预计未来5年机房数量小于4个</li><li>每个机房机器数小于100台</li><li>目前有5个业务线有ID生成需求，预计未来业务线数量小于10个</li><li>…</li></ul><p>分析过程如下：</p><ul><li>高位取从2017年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数</li><li>每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号</li><li>5年内机房数小于4个，预留2bit给机房标识</li><li>每个机房小于100台机器，预留7bit给每个机房内的服务器标识</li><li>业务线小于10个，预留4bit给业务线标识</li></ul><p>这样设计的64bit标识，可以保证：</p><ul><li>每个业务线、每个机房、每个机器生成的ID都是不同的</li><li>同一个机器，每个毫秒内生成的ID都是不同的</li><li>同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的</li><li>将毫秒数放在最高位，保证生成的ID是趋势递增的</li></ul><p><strong>缺点</strong>：</p><ul><li>由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2020/12/21/java/distributed/java-distributed-transaction/"/>
      <url>2020/12/21/java/distributed/java-distributed-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>在分布式系统中实现事务，他其实是<strong>由多个本地事</strong>务组合而成。</li></ul><h2 id="分布式事务的主要实现有以下方案"><a href="#分布式事务的主要实现有以下方案" class="headerlink" title="分布式事务的主要实现有以下方案"></a>分布式事务的主要实现有以下方案</h2><ul><li>XA方案</li><li>TCC方案</li><li>SAGA方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案/XA方案"></a>两阶段提交方案/XA方案</h3><ul><li>XA方案：两阶段提交，有一个事务管理器的概念，负责协调多个数据的事务，事务管理器先访问各个数据库你准备好了吗？如果每个数数据库都回复OK，那么久正式提交事务，在各个数据库上执行操作；如果其中任何一个数据库回答NO，那么久回滚事务。</li></ul><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><ul><li><p>（Two-phase commit proticol）,中文叫二阶段提交</p></li><li><p>二阶段提交是一种强一致性设计。引入一个<strong>管理者协调各参与者</strong>（各本地资源）的提交回滚。二阶段指的是<strong>准备和提交</strong>两个阶段</p></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608561598519.png" alt="1608561598519"></p><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ul><li>2PC他在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态</li><li>3PC包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英文就是：CanConmit、PerCommit和DoCommit.</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608563608233.png" alt="1608563608233"></p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><ul><li>2PC和3PC都是数据库层面的，而TCC是业务层面的分布式事务</li><li>TCC 指的是 Try-Confirm-Cancel。<ul><li>Try 指的是预留，即资源的预留和锁定，注意是预留。</li><li>Confirm 指的是确认操作，这一步其实就是真正执行了。</li><li>Cancel 指的是撤销操作， 可以理解为把预留阶段的动作撤销了。</li></ul></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608564547571.png" alt="1608564547571"></p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><ul><li>本地消息表其实就是利用了 各系统本地的事务来实现分布式事务</li><li>有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候，将业务的执行和将消息的放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中的业务肯定是执行成功的。</li><li>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息可以直接改成已成功。如果调用失败也没事，会有后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</li></ul><h3 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h3><ul><li>RocketMQ就很好的支持了消息事务</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608565223942.png" alt="1608565223942"></p><h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><ul><li>最大努力通知其实只是表明了一种柔性事务的思想：我已经尽我的最大努力想达成事务的最终一致了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="2020/12/21/java/distributed/java-distributed-locks/"/>
      <url>2020/12/21/java/distributed/java-distributed-locks/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a><strong>基于数据库</strong></h2><blockquote><ul><li>基于数据库表记录做唯一约束（表中记录方法名称）</li><li>基于数据库表做悲观锁（InnoDB，for update）</li><li>基于数据库表做乐观锁，用于分布式锁。（version）</li></ul></blockquote><h3 id="基于数据库表数据记录做唯一约束（表中记录方法名称）"><a href="#基于数据库表数据记录做唯一约束（表中记录方法名称）" class="headerlink" title="基于数据库表数据记录做唯一约束（表中记录方法名称）"></a>基于数据库表数据记录做唯一约束（表中记录方法名称）</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</li><li>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。 创建这样一张数据库表：</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f4b2a97bdf2" alt="img"></p><ul><li>当我们想要锁住某个方法时，执行以下SQL：</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f62c5d2d91a" alt="img"></p><ul><li><p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功（原子性），那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p></li><li><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql: </p></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f4df2225419" alt="img"></p><p><strong>上面这种简单的实现有以下几个问题：</strong></p><blockquote><ol><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ol><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加两个字段，一个记录当前获得锁的机器的主机信息和线程信息，另一个是count值，用于记录重入的次数，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了，并把count加1。在释放锁的时候把count值减1，当count值为0时候，删除记录即可。</li></ul></blockquote><h3 id="基于数据库表做悲观锁（InnoDB引擎，for-update语句）"><a href="#基于数据库表做悲观锁（InnoDB引擎，for-update语句）" class="headerlink" title="基于数据库表做悲观锁（InnoDB引擎，for update语句）"></a>基于数据库表做悲观锁（InnoDB引擎，for update语句）</h3><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。 我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（<strong>这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上</strong>）。</p><p>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。 我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            select * from lock where lock_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(结果不为空)&#123;</span><br><span class="line">                <span class="comment">//代表获取到锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">        <span class="comment">//为空或者抛异常的话都表示没有获取到锁</span></span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LockException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 connection.commit() 操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p>这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</p><h3 id="基于数据库资源表做乐观锁，用于分布式锁"><a href="#基于数据库资源表做乐观锁，用于分布式锁" class="headerlink" title="基于数据库资源表做乐观锁，用于分布式锁:"></a>基于数据库资源表做乐观锁，用于分布式锁:</h3><ol><li><p>首先说明乐观锁的含义:</p><blockquote><p> 大多数是基于数据版本(VERSION)的记录机制实现的。何谓数据版本号？即为数据增加一个版本标识，<br> 在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个“VERSION”字段来实现读取出数据时<br> ，将此版本号一同读出，之后更新时，对此版本号加1。</p><p> 在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；<br> 如果版本号不一致，则会更新失败。<br>复制代码</p></blockquote></li></ol><ol start="2"><li>对乐观锁的含义有了一定的了解后，结合具体的例子，我们来推演下我们应该怎么处理：</li></ol><ul><li><p>假设我们有一张资源表，如下图所示: T_RESOURCE , 其中有6个字段ID, RESOOURCE, STATE, ADD_TIME, UPDATE_TIME, VERSION,分别表示表主键、资源、分配状态(1未分配 2已分配)、资源创建时间、资源更新时间、资源数据版本号。</p></li><li><p>假设我们现在我们对ID=5780这条数据进行分配，那么非分布式场景的情况下，我们一般先查询出来STATE=1(未分配)的数据，然后从其中选取一条数据可以通过以下语句进行，如果可以更新成功，那么就说明已经占用了这个资源 UPDATE T_RESOURCE SET STATE=2 WHERE STATE=1 AND ID=5780。</p></li><li><p>如果在分布式场景中，由于数据库的UPDATE操作是原子是原子的，其实上边这条语句理论上也没有问题，但是这条语句如果在典型的“ABA”情况下，我们是无法感知的。有人可能会问什么是“ABA”问题呢？大家可以网上搜索一下，这里我说简单一点就是，如果在你第一次SELECT和第二次UPDATE过程中，由于两次操作是非原子的，所以这过程中，如果有一个线程，先是占用了资源(STATE=2)，然后又释放了资源(STATE=1)，实际上最后你执行UPDATE操作的时候，是无法知道这个资源发生过变化的。也许你会说这个在你说的场景中应该也还好吧，但是在实际的使用过程中，比如银行账户存款或者扣款的过程中，这种情况是比较恐怖的。</p></li><li><p>那么如果使用乐观锁我们如何解决上边的问题呢？</p><blockquote><p> A. 先执行SELECT操作查询当前数据的数据版本号,比如当前数据版本号是26：<br>  SELECT ID, RESOURCE, STATE,VERSION FROM T_RESOURCE WHERE STATE=1 AND ID=5780;<br>  B. 执行更新操作：<br>  UPDATE T_RESOURE SET STATE=2, VERSION=27, UPDATE_TIME=NOW() WHERE RESOURCE=XXXXXX AND<br>  STATE=1 AND VERSION=26<br>  C. 如果上述UPDATE语句真正更新影响到了一行数据，那就说明占位成功。如果没有更新影响到一行数据<br>  ，则说明这个资源已经被别人占位了。</p></blockquote></li></ul><ol start="3"><li><p>基于数据库表做乐观锁的一些缺点:</p><ol><li> 这种操作方式，使原本一次的UPDATE操作，必须变为2次操作: SELECT版本号一次；UPDATE一次。增加了数据库操作的次数。</li><li> 如果业务场景中的一次业务流程中，多个资源都需要用保证数据一致性，那么如果全部使用基于数据库资源表的乐观锁，就要让每个资源都有一张资源表，这个在实际使用场景中肯定是无法满足的。而且这些都基于数据库操作，在高并发的要求下，对数据库连接的开销一定是无法忍受的。</li><li> 乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整，如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开。</li></ol></li></ol><p>讲了乐观锁的实现方式和缺点，是不是会觉得不敢使用乐观锁了呢？？？当然不是，在文章开头我自己的业务场景中，场景1和场景2的一部分都使用了基于数据库资源表的乐观锁，已经很好的解决了线上问题。所以大家要根据的具体业务场景选择技术方案，并不是随便找一个足够复杂、足够新潮的技术方案来解决业务问题就是好方案？！比如，如果在我的场景一中，我使用zookeeper做锁，可以这么做，但是真的有必要吗？？？答案觉得是没有必要的！！！</p><p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p><blockquote><p>数据库实现分布式锁的优点<br>    直接借助数据库，容易理解。<br>数据库实现分布式锁的缺点<br>    会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。<br>    操作数据库需要一定的开销，性能问题需要考虑。<br>    使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p></blockquote><h2 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a><strong>基于缓存</strong></h2><blockquote><ul><li>使用redis的setnx()用于分布式锁。（setNx，直接设置值为当前时间+超时时间，保持操作原子性）</li><li><del>使用memcached的add()方法，用于分布式锁。</del></li><li><del>使用Tair的put()方法，用于分布式锁。</del></li></ul></blockquote><h3 id="基于缓存实现分布式锁-Redis"><a href="#基于缓存实现分布式锁-Redis" class="headerlink" title="基于缓存实现分布式锁 Redis"></a>基于缓存实现分布式锁 Redis</h3><ul><li><p>使用redis的setnx()用于分布式锁。（原子性）</p></li><li><p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。</p><blockquote><ul><li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。</li><li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li></ul></blockquote></li></ul><p> <strong>存在死锁的问题</strong></p><p>​        SETNX实现分布式锁，可能会存在死锁的情况。与单机模式下的锁相比，分布式环境下不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。某个线程获取了锁之后，断开了与Redis 的连接，锁没有及时释放，竞争该锁的其他线程都会hung，产生死锁的情况。所以在这种情况下需要对获取的锁进行超时时间设置，即setExpire，超时自动释放锁</p><p><strong>Redission的分布式锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redission是redis官网推荐的一个redis客户端，除了基于redis的基础的CURD命令以外，重要的是就是Redission提供了方便好用的分布式锁API</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>一、 <strong>基本用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient redissonClient = RedissonTool.getInstance();</span><br><span class="line"></span><br><span class="line">      RLock distribute_lock = redissonClient.getLock(<span class="string">&quot;distribute_lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> result = distribute_lock.tryLock(<span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (distribute_lock.isLocked()) &#123;</span><br><span class="line">              distribute_lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>代码流程</strong></p><ol><li>通过 redissonClient 获取 RLock 实例</li><li>tryLock 获取尝试获取锁，第一个是等待时间，第二个是锁的超时时间，第三个是时间单位</li><li>执行完业务逻辑后，最终释放锁</li></ol><p>二、 <strong>具体实现</strong></p><blockquote><p>我们通过tryLock来分析redission分布式的实现，lock方法跟tryLock差不多，只不过没有最长等待时间的设置，会自旋循环等待锁的释放，直到获取锁为止</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">     <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">//获取当前线程ID，用于实现可重入锁</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">     <span class="comment">//尝试获取锁</span></span><br><span class="line">     Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">     <span class="comment">// lock acquired</span></span><br><span class="line">     <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     time -= (System.currentTimeMillis() - current);</span><br><span class="line">     <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">//等待时间结束，返回获取失败</span></span><br><span class="line">         acquireFailed(threadId);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     current = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">//订阅锁的队列，等待锁被其余线程释放后通知</span></span><br><span class="line">     <span class="keyword">final</span> RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">     <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">             subscribeFuture.addListener(<span class="keyword">new</span> FutureListener&lt;RedissonLockEntry&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;RedissonLockEntry&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span> (subscribeFuture.isSuccess()) &#123;</span><br><span class="line">                         unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         acquireFailed(threadId);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         time -= (System.currentTimeMillis() - current);</span><br><span class="line">         <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">             acquireFailed(threadId);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">             ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">             <span class="comment">// lock acquired</span></span><br><span class="line">             <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             time -= (System.currentTimeMillis() - currentTime);</span><br><span class="line">             <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 acquireFailed(threadId);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// waiting for message，等待订阅的队列消息</span></span><br><span class="line">             currentTime = System.currentTimeMillis();</span><br><span class="line">             <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                 getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             time -= (System.currentTimeMillis() - currentTime);</span><br><span class="line">             <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 acquireFailed(threadId);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         unsubscribe(subscribeFuture, threadId);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><ol><li>首先 tryAcquire 尝试获取锁，若返回ttl为null，说明获取到锁了</li><li>判断等待时间是否过期，如果过期，直接返回获取锁失败</li><li>通过 Redis 的 Channel 订阅监听队列，subscribe 内部通过信号量 semaphore，再通过await方法阻塞，内部其实是用 CountDownLatch 来实现阻塞，获取 subscribe 异步执行的结果，来保证订阅成功，再判断是否到了等待时间</li><li>再次尝试申请锁和等待时间的判断，循环阻塞在这里等待锁释放的消息 RedissonLockEntry 也维护了一个semaphore 的信号量</li><li>无论是否释放锁，最终都要取消订阅这个队列消息</li><li>redission 内部的 getEntryName 是客户端实例ID + 锁名称 来保证多个实例下的锁可重入</li></ol><hr><p><strong>tryAcquire获取锁</strong></p><blockquote><p>redisssion获取锁的核心代码,内部其实是异步调用，但是用get方法阻塞了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(tryAcquireAsync(leaseTime, unit, threadId));</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br><span class="line"> <span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(LOCK_EXPIRATION_INTERVAL_SECONDS, TimeUnit.SECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Long ttlRemaining = future.getNow();</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>tryLockInnerAsync方法内部是基于Lua脚本来获取锁的</p><ul><li>先判断KEYS[1]（锁名称）对应的key是否存在，不存在获取到锁，hset设置key的value，pexpire设置过期时间，返回null表示获取到锁</li><li>存在的话，锁被占，hexists判断是否是当前线程的锁，若是的话，hincrby增加重入次数，重新设置过期时间，不是当前线程的锁，返回当前锁的过期时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">       internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                 <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                   Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>Redission避免死锁的解决方案：</p><p>Redission为了避免锁未被释放，采用了一个特殊的解决方案，若未设置过期时间的话，redission默认的过期时间是30s，同时未避免锁在业务未处理完成之前被提前释放，Redisson在获取到锁且默认过期时间的时候，会在当前客户端内部启动一个定时任务，每隔internalLockLeaseTime/3的时间去刷新key的过期时间，这样既避免了锁提前释放，同时如果客户端宕机的话，这个锁最多存活30s的时间就会自动释放（刷新过期时间的定时任务进程也宕机）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock acquired，获取到锁的时候设置定期更新时间的任务</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//expirationRenewalMap的并发安全MAP记录设置过的缓存，避免并发情况下重复设置任务，internalLockLeaseTime / 3的时间后重新设置过期时间</span></span><br><span class="line">               <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                      Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">            </span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, future.cause());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), task) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>unlock解锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123;</span><br><span class="line">        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot; +</span><br><span class="line">                &quot;end;&quot; +</span><br><span class="line">                &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) &#x3D;&#x3D; 0) then &quot; +</span><br><span class="line">                    &quot;return nil;&quot; +</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;local counter &#x3D; redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +</span><br><span class="line">                &quot;if (counter &gt; 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +</span><br><span class="line">                    &quot;return 0; &quot; +</span><br><span class="line">                &quot;else &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot;+</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;return nil;&quot;,</span><br><span class="line">                Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   Redission的unlock解锁也是基于Lua脚本实现的，内部逻辑是先判断锁是否存在，不存在说明已经被释放了，发布锁释放消息后返回，锁存在再判断当前线程是否锁拥有者，不是的话，无权释放返回，解锁的话，会减去重入的次数，重新更新过期时间，若重入数捡完，删除当前key，发布锁释放消息</p><h2 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h2><blockquote><ul><li>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。</li></ul></blockquote><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><p>基于 zookeeper 临时有序节点可以实现的分布式锁。</p><p>大致思想即为：</p><blockquote><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有<br>序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。<br>当释放锁的时候，只需将这个临时节点删除即可。同时，排队的节点需要监听排在自己之前的节点，这样能<br>在节点释放时候接收到回调通知，让其获得锁。zk的session由客户端管理，其可以避免服务宕机导致的锁无<br>法释放，而产生的死锁问题，不需要关注锁超时。<br>复制代码</p></blockquote><p>来看下Zookeeper能不能解决前面提到的问题。</p><blockquote><ul><li>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul></blockquote><p>可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。</p><ul><li><p>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</p></li><li><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，<strong>那就是性能上可能并没有缓存服务那么高</strong>。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</p></li><li><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端到ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p></li></ul><p><strong>基于ZK的方案的总结</strong></p><p>使用Zookeeper实现分布式锁的优点</p><blockquote><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></blockquote><p>使用Zookeeper实现分布式锁的缺点</p><blockquote><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></blockquote><h2 id="三种方案的比较"><a href="#三种方案的比较" class="headerlink" title="三种方案的比较"></a>三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><ul><li><p>从理解的难易程度角度（从低到高）</p><blockquote><p>数据库 &gt; 缓存 &gt; Zookeeper</p></blockquote></li><li><p>从实现的复杂性角度（从低到高）</p><blockquote><p>Zookeeper &gt;= 缓存 &gt; 数据库</p></blockquote></li><li><p>从性能角度（从高到低）</p><blockquote><p>缓存 &gt; Zookeeper &gt;= 数据库</p></blockquote></li><li><p>从可靠性角度（从高到低）</p><blockquote><p>Zookeeper &gt; 缓存 &gt; 数据库</p></blockquote></li></ul><p>参考：<a href="https://juejin.cn/post/6844903726268809224">https://juejin.cn/post/6844903726268809224</a></p><p>参考：<a href="https://juejin.cn/post/6844903662762852359#heading-4">https://juejin.cn/post/6844903662762852359#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC参数和调优</title>
      <link href="2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/"/>
      <url>2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="GC参数和调优"><a href="#GC参数和调优" class="headerlink" title="GC参数和调优"></a>GC参数和调优</h2><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾分代收集</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾分代收集"><a href="#垃圾分代收集" class="headerlink" title="垃圾分代收集"></a>垃圾分代收集</h1><ul><li><p>Full GC ： 针对的是整个堆。包括：新生代、老年代、永久代。</p></li><li><p>针对HotSpot VM 的实现，他里面的GC其实准确分类只有两大类：</p><ul><li><p>部分收集器（Partial GC）：</p><ul><li>新生代收集器（Minor GC/ Yong GC）：只对新生代进行垃圾收集</li><li>老年代收集器（Major GC/Old GC）：只对老年代进行垃圾收集。</li><li>混合收集器（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区。</p></li></ul></li></ul><h1 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h1><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/1610272750274.png" alt="1610272750274"></p><h1 id="对象默认存活年龄"><a href="#对象默认存活年龄" class="headerlink" title="对象默认存活年龄"></a>对象默认存活年龄</h1><ul><li>晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6，The default value is 15 for the parallel(throughput) collector</li></ul><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><ul><li><p>对象优先在eden区分配</p></li><li><p>大对象直接进入老年代</p><ul><li>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。为了避免为大对象分配内存空间时由于分配担保机制带来的复制而降低效率</li></ul></li><li><p>长期存活的对象将进入老年代</p><ul><li>-XX:MaxTenuringThreshold</li></ul></li><li><p>动态对象年龄判定</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(HotSpot)的垃圾回收器</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾的回收作用范围"><a href="#jvm垃圾的回收作用范围" class="headerlink" title="jvm垃圾的回收作用范围"></a>jvm垃圾的回收作用范围</h1><p>下面描述的收集器是基于 JDK1.7 Update 14 之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图：如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/1610272098369.png" alt="1610272098369"></p><h1 id="jvm的7种垃圾回收器"><a href="#jvm的7种垃圾回收器" class="headerlink" title="jvm的7种垃圾回收器"></a>jvm的7种垃圾回收器</h1><h2 id="1-Serial收集器-单线程"><a href="#1-Serial收集器-单线程" class="headerlink" title="1.Serial收集器(单线程)"></a>1.Serial收集器(单线程)</h2><p>Serial收集器时最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。<br>Serial收集器依然是虚拟机运行在Cleent模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="2-ParNew收集器（Serial-多线程）"><a href="#2-ParNew收集器（Serial-多线程）" class="headerlink" title="2.ParNew收集器（Serial+多线程）"></a>2.ParNew收集器（Serial+多线程）</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The Worl、对象可分配规则、回收策略等都与Serial收集器完全一样。<br>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是除了Serial收集器之外，目前只有arNew它能与CMS收集器配合工作。</p><h2 id="3-Parallel-Scavenge-并行回收-收集器"><a href="#3-Parallel-Scavenge-并行回收-收集器" class="headerlink" title="3.Parallel Scavenge(并行回收)收集器"></a>3.Parallel Scavenge(并行回收)收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br>停顿时间越短就越适合需要与用户交互的程序良好的响应速度能提升用户体验，二高吞吐量则可用高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算二不需要太多的交互的任务。</p><p>Parallel Scavenga收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePPolicy/这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor去的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGvPauseMillis参数或者SGCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是paralel Scavenge收集器与ParNew收集器的一个重要区别</p><h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记清除算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p><p>如果在 Server 模式下，主要两大用途：</p><ol><li>在 JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器使用</li><li>作为 CMS 收集器的后备预案，在并行收集发生 Concurrent Mode Failure 时使用</li></ol><h2 id="5-Paralled-Old收集器"><a href="#5-Paralled-Old收集器" class="headerlink" title="5.Paralled Old收集器"></a>5.Paralled Old收集器</h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-清理”算法。这个收集器在 1.6 中才开始提供。</p><h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h2><p>CMS（ Concurrent Mark Sweep ） 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务器的相应速度，希望系统停顿时间最短，已给用户带来较好的体验。 CMS 收集器就非常符合这类应用需求</p><p>CMS 收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更加复杂一些，整个过程为4个步骤:</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要 “Stop the World”。</p><p>CMS 收集器的主要优点：并发收集，低停顿。</p><p>CMS 三个明显的缺点：</p><ol><li>CMS 收集器对 CPU 资源非常敏感。 CPU 个数少于4个时， CMS 对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的 CMS 收集器变种。所做的事情和单 CPU 年代 PC 机操作系统使用抢占式来模拟多线程任务机制的思想。</li><li>CMS 收集器无法处理浮动垃圾，可能出现“ Concurrent Mode Failure ”失败而导致另一次 Full Gc 的产生。在 JDK1.5 的默认设置下， CMS 收集器当老年代使用了 68% 的空间后就会被激活， 这是一个偏保守的设置， 如果在应用中老年代增长不是太快，可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK1.6 中， CMS 收集器的启动阈值已经提升到 92%。</li><li> CMS 是基于“标记-清除”算法实现的收集器，手机结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前发出 Full Gc。为了解决这个问题， CMS 收集器提供一个 -XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片整合并清理过程， 内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间变长了。虚拟机设计者还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction ，这个参数是用于设置执行多次不压缩 Full GC后，跟着来一次带压缩的FullGC（默认值为0，标识每次进入 FullGC时都进行碎片整理）</li></ol><h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h2><p>G1收集器的优势：</p><ol><li>并行与并发</li><li>分代收集</li><li>空间整理（标记整理算法，复制算法）</li><li>可预测的停顿（G1处追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M毫秒的时间片段内，消耗在垃圾收集器上的时间不超过 N 毫秒，这几乎已经实现 Java（ RTSJ ）的垃圾收集器的特征）</li></ol><p>使用 G1 收集器时， Java 堆的内存布局是整个规划为多个大小相等的独立区域（ Region ），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一小部分 Region 的集合。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个 Java 堆中进行全区域的垃圾收集。 G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值最大的 Region （这也就是 Garbage-First 名称的由来）。这种使用 Region 划分的内存空间以及优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽量可能高的效率。</p><p>G1 内存“化整为零”的思路</p><p>在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会遗漏。</p><p>如果不计算维护 Remembered Set 的操作， G1 收集器的运作大致可分为以下步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li>该算法分为 “标记” 和 “清除” 阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：<ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul></li></ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>为了解决效率问题，“复制” 收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</li></ul><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><ul><li>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li><li>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类和常量池引</title>
      <link href="2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h1><ul><li>字面量会到 java 堆中的常量池去找</li><li>new 的方式会在堆中创建</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/1610271202594.png" alt="1610271202594"></p><h1 id="String常量池的实现方式"><a href="#String常量池的实现方式" class="headerlink" title="String常量池的实现方式"></a>String常量池的实现方式</h1><ul><li>字面量：双引号括起来的</li><li>String.intern()：他的作用是：如果运行时常量池中已经包含一个等于此 Spring 对象内容的字符串，则返回常量池中该字符串的引用</li></ul><h1 id="String-s1-new-String-“abc”-；这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-；这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”)；这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”)；这句话创建了几个字符串对象？</h1><ul><li>将创建 1 或 2 个字符串，如果常量池中已存在字符串常量 “abc”，则只会在堆空间创建一个字符串常量 “abc” 。如果池中没有字符串常量 “abc” ，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共两个字符串对象。</li></ul><h1 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h1><ul><li><p>Java 基本类型的包装类的大部分都实现了常量池技术</p><ul><li> Byte、Short、Integer、Long：四种包装类默认创建了数字 [-128,127] 的相应类型的缓存数据</li><li>Character：创建了数值在[0,127]范围的缓存数据</li><li>Boolean；直接返回 True 或 False。</li></ul><blockquote><ul><li><p>如果超出对应范围仍然会去创建新的对象。</p></li><li><p>为啥把缓存设置为[-128,127]区间？ (参见issue、461)性能和资源之间的权衡。</p></li></ul></blockquote></li><li><p>算术运算符或比较运算符，对包装类型会有一个拆箱操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ul><li>加载</li><li>连接<ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/1610292210392.png" alt="1610292210392"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过类的全限定名，找到 Class 文件，将 Class 文件中的静态存储结构转换成方法区运行时数据结构，在内存中生活才能一个代表该类的 Class 对象，作为方法区这些数据的入口</li><li>数组类型不通过类加载器创建，由 JVM 直接创建</li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证字节码文件的安全性和完整性：包括：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>为类的静态变量分配内存和设置初始化值</li><li>实例变量会在对象实例化时随着对象一块分配在Java堆中。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code> 方法的过程。</li><li>类初始化的情况<ul><li>new、设置或获取类的静态资源</li><li>反射调用</li><li>子类初始化，先初始化父类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制</li><li>Java8中，接口定义了默认方法时，接口实现类发生了初始化，先初始化接口</li></ul></li></ul><h1 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h1><ul><li>卸载类是该类的Class对象被GC</li><li>满足的条件<ul><li>该类的所有实例对象都已被GC，堆中不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC：自定义加载器加载的类是可以被卸载掉的</li></ul></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader：<ul><li>BootstrapClassLoader( 启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</li><li>ExtensionClassLoader (扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</li><li>AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有jar包和类。</li></ul></li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><ul><li><strong>每一个类都有一个对应它的类加载器</strong> 。类加载的时候，会先判断这个类有没有被加载过。已经加载过的类直接返回，否则尝试加载。</li><li>加载的时候，会先委派该父类加载器的 loadClass 处理，因此所有请求都会到达顶层启动类加载器。当父类加载器无法处理时，才由自己来处理。</li><li>父类加载器为 null 时，由启动类加载器来处理。</li></ul><h2 id="双亲委派的好处"><a href="#双亲委派的好处" class="headerlink" title="双亲委派的好处"></a>双亲委派的好处</h2><ul><li>保证了 Java 程序的稳定运行，可以避免类的重复加载，也<strong>保证了 Java 的核心 API 不被篡改</strong>。</li><li>假设每个类加载器加载自己的话，就会出现我自定义一个 java.lang.Object 类的话，运行程序的时候，就有多个 Object 类了。</li></ul><h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><p>自定义加载器的话，需要继承 ClassLoader 。</p><ul><li>如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</li><li>如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的访问定位</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>java 程序通过栈上的 reference 数据来操作堆上的具体对象</p><p>对象的访问方式2种：<strong>使用句柄，直接指针</strong></p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><ul><li>如果使用句柄的话，那么java 堆中将会划分出一块内存来作为句柄池， reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据 与 类型数据各自的具体地址信息；</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270729163.png" alt="1610270729163"></p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><ul><li>如果使用直接指针访问，那么 java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 refrence 中存储的直接就是对象的地址</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270744133.png" alt="1610270744133"></p><blockquote><ul><li><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，他节约了一次指针定位的时间开销。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的内存布局</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><blockquote><p>对象的内存布局分为3块区域：<strong>对象头、实例数据</strong>和<strong>对齐填充</strong></p></blockquote><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><ul><li>包含两部分信息：第一部分专用于存储对象自身的运行时数据（hash码、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><ul><li>实例数据部分是对象真正存储的有效信息，也就是程序中定义的各种类型的字段内容。</li></ul><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><ul><li>不是必然存在，仅仅起占位作用。</li><li>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整倍数，换句话说就是对象的大小必须是8字节的整倍数。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的过程</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><ul><li>虚拟机遇到new指令时，首先去检查常量池中有没有这个类的符号应用，并且检查这个符号引用代表的类是否已被<strong>加载、验证、准备、解析、初始化</strong>过。如果没有，那么必须先执行相应的类的加载过程。</li></ul><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><ul><li>为新生对象分配内存，在类加载完成后就可以确定对象所需内存大小，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配的方式有”指针碰撞”和”空闲列表”，选择哪种方式由java堆是否规整决定，而java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定</li></ul><h3 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ul><li>适用于内存规整（没有内存碎片）</li><li>原理：用过的内存全部整理到一边，没有用过的内存放到另外一边，只要从没有用过的内存方向移动指定对象内存大小的位置即可。</li><li>GC收集器： Serial ， ParNew</li></ul><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ul><li>适用于堆内存不规整的情况下</li><li>原理：虚拟机会维护一个列表，该列表中记录哪些内存是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录</li><li>GC 收集器：CMS</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h3><ul><li>CAS + 失败重试：CAS 是一种乐观锁的实现方式。所谓乐观锁就是：每次不加锁而是假设没有冲突去完成某项操作，因为如果冲突失败就重试，直到成功为止。虚拟机采用CAS失败重试的方式保证更新操作的原子性</li><li>TLAB（Thread Local Allocation Buffer）：为每一个线程先在伊甸区分配一块内存，JVM 在给线程中对象分配内存时，首先在 TLAB 分配，当对象大于TLAB分配中的剩余内存或TLAB的内存用尽时，在采用CAS进行内存分配。</li></ul><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><ul><li>内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化零值</strong>（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段数据类型所对应的零值。</li></ul><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><ul><li>初始化零值完成之后，虚拟机需要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到<strong>类的元数据</strong>信息、对象的<strong>哈希码</strong>、对象的 <strong>GC</strong> 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如<strong>是否启用偏向锁</strong>等，对象头会有不同的设置方式。</li></ul><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><ul><li>从虚拟机的视角来看，一个新的对象已经产生了，但从java程序的视角来看，对象创建才刚开始，<code>&lt;init&gt; </code> 方法还没有执行，所有字段都还为零。所以一般来说，执行完 new 指令后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm体系结构</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​        JVM 是可运行 Java 代码的假想计算，包括<strong>一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域</strong>。 JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>完整内存模型图见：<a href="https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764">https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764</a></p><p><img src="/2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1610267566650.png" alt="1610267566650"></p><ul><li>JVM 内存区域主要分为：线程私有区域【<strong>程序计数器、虚拟机栈、本地方法区</strong>】、线程共享区域【 <strong>JAVA 堆、方法区</strong>】、直接内存。</li></ul><ul><li>线程私有区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)。</li></ul><ul><li>线程区域随虚拟机的启动/关闭而创建/销毁。</li></ul><ul><li>直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用：在 JDK1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。</li></ul><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><ul><li>字节码解释器从程序计数器中取出指令，实现对流程的控制</li></ul><ul><li><p><strong>在线程切换的过程中，保存当前线程的执行位置，以便在线程恢复执行的时候找到正确的执行位置</strong></p></li><li><p>唯一一个不会发生 OutOfMemoryError 的区域。</p></li></ul><h3 id="Java虚拟机栈（线程私有）"><a href="#Java虚拟机栈（线程私有）" class="headerlink" title="Java虚拟机栈（线程私有）"></a>Java虚拟机栈（线程私有）</h3><ul><li>由一组栈帧组成，栈帧用来保存<strong>局部变量、操作数栈、动态链接、方法出口</strong>等信息，栈帧随着方法调用而创建，随着方法结束而销毁—-无论方法是正常完成还是异常完成（抛出了在方法内未捕获的异常）都算方法结束。</li><li>局部变量表主要存放了编译期可知的各种<strong>数据类型</strong>（boolean,byte,char,short,int,float,long,double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的应用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li><li>StackOverFlowError：若 java 虚拟机的内存大小不动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li>OutOfMemory：若 java 虚拟机堆中没有空闲内存，并且垃圾收集器也无法提供更多的内存。就会抛出 OutOfMemoryError 错误。</li><li>每一次函数的调用就是对应栈帧的一次入栈到出栈的过程。</li></ul><h3 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h3><ul><li>使用到的是本地方法服务。</li><li>HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>线程私有区域，他的生命周期随着线程的创建而开始，随着线程的消亡而结束。</li></ul><h3 id="堆（-Heap-线程共享-）-运行时数据区"><a href="#堆（-Heap-线程共享-）-运行时数据区" class="headerlink" title="堆（ Heap-线程共享 ）-运行时数据区"></a>堆（ Heap-线程共享 ）-运行时数据区</h3><ul><li><p>目的是存放对象实例，几乎所有的对象实例和数组都在这里分配内存</p></li><li><p>随着JTI编译器的发展和逃逸分析技术的成熟，栈上分配、变量替换优化技术，使得所有对象在堆上的分配变得不那么绝对。<strong>如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存</strong>。</p></li><li><p>堆是垃圾收集器管理的主要区域，因此才被称为GC堆，现在垃圾收集器都是采用<strong>分代收集算法</strong>。Java堆细分：新生代和老年代，在细致一点的话就是：伊甸区，from区，to区。划分的目的是更好的回收内存，或者更快的分配内存。</p></li></ul><h3 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h3><ul><li>用于存放已被虚拟机加载的类信息，常量，静态变量，即时编译器后的代码数据。</li><li>java虚拟机规范把方法区描述为堆的一个逻辑部分，Non-Heap（非堆）</li><li>永久代就是HotsSpot虚拟机堆虚拟机规范方法区中的一种实现方式。也就是说，永久代是HotSpot的概念，方法区是java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。</li><li>-XX:PermSize=N  //方法区（永久代）初始大小</li><li>-XX:MaxPermSizze=N  //方法区（永久代）最大大小，超过这个值就会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError:PermGen</li></ul><h2 id="为什么元区间取代了永久代"><a href="#为什么元区间取代了永久代" class="headerlink" title="为什么元区间取代了永久代"></a>为什么元区间取代了永久代</h2><ul><li>永久代在 JVM 中受到 JVM 本身固定大小的限制，无法进行调整。</li><li>元空间使用的是直接内存，受本机可用内存的限制</li><li>元空间内存溢出：java.lang.OutOfMemoryError:MetaSpace</li><li>-XX:MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited ,这意味着他只受系统内存的限制</li><li>元空间里面存在的是元数据，这样加载多个类的元数据就不由 MaxPermSize 控制，而是由系统的实际可用空间来控制，这样能加载更多的类</li><li>在 JDK8 中，合并 HotSpot 和 Jrockit 的代码时，Jrockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了</li></ul><h2 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h2><ul><li>java7之前，运行时常量池包含字符串常量池。</li><li>java7，运行时常量池在永久代，字符串常量池在堆中。</li><li>java8，运行时常量池在元空间，字符串常量池在堆中。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul><li>本机的内存</li><li>JDK1.4 之后的 NIO ，引入了一种基于通道与缓存区的 I/O 方式，可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的应用操作，这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象死亡判断</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="对象死亡判断"><a href="#对象死亡判断" class="headerlink" title="对象死亡判断"></a>对象死亡判断</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的</p><blockquote><p>​    难以解决对象间的循环引用。除了对象 objA和objB相互引用这对方外，这两个对象之间再无任何引用。但是他们因为相互引用对方，导致他们的应用计数器都不为0，于是引用计数算法无法通知GC回收器回收他们。</p></blockquote></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始想下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li></ul><h4 id="可作为-GC-Roots-的对包括下面几种："><a href="#可作为-GC-Roots-的对包括下面几种：" class="headerlink" title="可作为 GC Roots 的对包括下面几种："></a>可作为 GC Roots 的对包括下面几种：</h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方发展（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>判定对象的存活与 “引用” 有关。</li><li>强引用（StrongReference）<ul><li>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。必不可少，垃圾收集器绝对不会回收他。当空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，是程序异常终止</li></ul></li><li>软引用<ul><li>如果一个对象具有软引用，可有可无，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</li></ul></li><li>弱引用<ul><li>可有可无，只具有弱引用的对象拥有更短暂的生命周期。在垃圾收集器线程扫描他所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></li><li>虚引用<ul><li>形同虚设。如果一个对象仅持有引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li></ul></li></ul><h2 id="不可达的对象并非-“不死不可”"><a href="#不可达的对象并非-“不死不可”" class="headerlink" title="不可达的对象并非 “不死不可”"></a>不可达的对象并非 “不死不可”</h2><ul><li>即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑阶段”，要真正宣告一个对象死亡，至少需要经历<strong>两次标记</strong>过程；可达性分析算法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法， 或 finalize 方法已经被虚拟机调用过时， 虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行二次标记，除非这个对象与应用链上的任何一个对象关联，否则真的会被回收。</li></ul><h2 id="如何判断一个常量是废弃的常量？"><a href="#如何判断一个常量是废弃的常量？" class="headerlink" title="如何判断一个常量是废弃的常量？"></a>如何判断一个常量是废弃的常量？</h2><ul><li>运行时常量池</li><li>加入在常量池中存在字符串 “abc” ， 如果当前没有任何 String 对象引用该字符串的话， 就说明常量 “abc” 就是废弃常量，如果这是发生内存回收的话而且有必要的话， “abc” 就会被系统清理出常量池。</li></ul><h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><ul><li>方法区主要回收的是无用的类</li><li>可以被回收<ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透与雪崩</title>
      <link href="2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/"/>
      <url>2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存穿透与雪崩"><a href="#缓存穿透与雪崩" class="headerlink" title="缓存穿透与雪崩"></a>缓存穿透与雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>在默认情况下，用户请求数据时，会先在缓存（Redis）中查找，若没找到即缓存为命中，再在数据库中查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景），缓存没有命中的话，就会将请求全部转移到数据库上，造成数据库的压力剧增，就有可能导致数据库的崩溃。</p><p>网络安全中的也有人恶意使用这种手段进行攻击称为洪水攻击</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="布隆过滤器："><a href="#布隆过滤器：" class="headerlink" title="布隆过滤器："></a>布隆过滤器：</h4><p>对所有可能查询的参数以hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截，检验不通过则直接打回，减轻了存储系统的压力</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072357498.png" alt="1609072357498"></p><h4 id="缓存空对象（查询不到）"><a href="#缓存空对象（查询不到）" class="headerlink" title="缓存空对象（查询不到）"></a>缓存空对象（查询不到）</h4><p>一次查询若在缓存与数据库中都没有查询到，就在缓存中放一个空对象用于处理后续这个请求</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072445647.png" alt="1609072445647"></p><p>这样做有一个缺陷：储存空对象也需要空间，大量空对象会消耗一定的空间，储存效率并不高。解决这个缺陷的方式就是 <strong>设置较短的过期时间</strong>。即使对空置设置了过期时间，还是会存在缓存层和储存层的数据会有一段时间的不一致，这对于需要保持一致性的业务会有影响。</p><h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时的 DB 请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个 key 的缓存不可用而导致的击穿，但是其他的 key 仍然可以使用缓存响应。</p></blockquote><p>比如热搜排行榜，一个热点新闻同时被大量访问就可能导致缓存击穿。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候，也会清理部分书，而且此种方案会暂占用空间，一旦热点数据多了起来，久会占用大量空间</p><h4 id="加互斥锁（分布式锁）"><a href="#加互斥锁（分布式锁）" class="headerlink" title="加互斥锁（分布式锁）"></a>加互斥锁（分布式锁）</h4><p>在访问 key 之前，采用 setnx （set  if  not exists）来设置另一个短期 key 来锁住当前 key 的访问，访问结束再删除改短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>大量的 key 设置了相同的过期时间，导致在缓存在同一时刻的 key 全部消失，造成瞬时 DB 请求量大、压力骤增、引起雪崩。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><p>这个思想的含义是：既然redis有可能挂掉，那就多增加几台 redis , 这样一台挂掉之后其他还可以继续工作，其实就是<strong>搭建集群</strong></p><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><p>在缓存失效后，通过加锁或者队列来控制读数据库写幻想村的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>数据预热的含义就是在正式部署之前，我先把可能的 数据先预先访问一遍，这样部门可能大量访问的数据久会加载到内存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台redis服务的数据，复制到其他的 redis 服务器。前者称为主节点（Master/Leader），后者称为从节点（Slave/Follower），数据的复制是单向的，只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台 Redis 服务器都是主节点，一个主节点可以有 0 个或者多个从节点，但是每个从节点只能有一个主节点。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式。</li><li>负载均衡：在主从复制的基础上，配合读写分离，有主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的情境下，通过多个从节点分担负载，提供并发量。</li><li>高可用基石：主从复制还是哨兵和集群能都实施的基础。</li></ol><h2 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h2><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限</li></ol><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我们在讲解配置文件的时候，注意到有一个 replication 模块（间 redis.conf 中第8条）</p><p>查看当前库的信息： info replication</p><p>// TODO</p><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改一下信息：</p><ul><li>端口号</li><li>pid 文件名</li><li>日志文件名 </li><li>rdb 文件名</li></ul><p>启动单机多服务集群：</p><p>// TODO</p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p><strong>默认情况下，每台 Redis 服务器都是主节点； 我们一般情况下只用配置从机就好了！</strong></p><p>使用 SALVEOF host port 就可以为从机配置主机了。</p><p>// TODO</p><p>然后主机上也能看到从机的状态</p><p>// TODO</p><p>我们这里使用命令搭建，是暂时的，真实开发中应该在从机配置文件中进行过配置，这样的话就是永久的。</p><p>// TODO</p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li>从机只读，不能写，主机可读可写但是多用于写。// TODO</li><li>当主机断点宕机后，默认情况下从机的角色不会发生变化，集群中只是丢失了写操作，当主机恢复以后，又会连上从机恢复原状。</li><li>当从机宕机后，若不是使用配置的配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若次吃重新配置称为从机，又可以获取到主机的所有数据。这里就是提到一个同步原理。</li><li>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：<ul><li>​    从机手动执行命令 slaveof  no  one，这样执行以后从机独立出来称为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动？</p></blockquote><p>如果主机断开了连接，我们可以使用 slaveof no one 让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大恢复了，那么就重新连接！</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>主从切换技术的方法是：<strong>当主机宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用</strong>。这不是一种推荐的方式，更多的时候，我们优先考虑哨兵模式。</p><h3 id="单机单个哨兵"><a href="#单机单个哨兵" class="headerlink" title="单机单个哨兵"></a>单机单个哨兵</h3><ul><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵检测到 master 宕机，会自动将 slave 切换成 master ， 然后通过 <strong>发布订阅模式</strong> 通知其他从服务器，修改配置文件，让它们切换成主机。</li></ul><h3 id="多哨兵模式"><a href="#多哨兵模式" class="headerlink" title="多哨兵模式"></a>多哨兵模式</h3><p>哨兵的核心配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>数字1表示：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p>// TOOD</p><p>此时哨兵模式监视着我们的主机6379，当我们断开主机后：</p><p>// TOOD</p><h3 id="哨兵的优缺点"><a href="#哨兵的优缺点" class="headerlink" title="哨兵的优缺点"></a>哨兵的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>哨兵集群，基于主从复制模式，所有的主从复制的有点，他都有</li><li>主从可以切换，故障可以转移，系统的可用性好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Redis 不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><h3 id="完整的哨兵模式配置文件-sentinel-conf"><a href="#完整的哨兵模式配置文件-sentinel-conf" class="headerlink" title="完整的哨兵模式配置文件 sentinel.conf"></a>完整的哨兵模式配置文件 sentinel.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h2 id="redis-红锁（redlock）"><a href="#redis-红锁（redlock）" class="headerlink" title="redis 红锁（redlock）"></a>redis 红锁（redlock）</h2><p>关于分布式锁，一般有三种选择，</p><ol><li><p>redis </p></li><li><p>zk</p></li><li><p>DB锁（悲观锁、乐观锁）</p><p>其中用的最多的应该是redis。</p></li></ol><p>redis常用的方式有单节点、主从模式、哨兵模式、集群模式。</p><p>单节点在生产环境基本上不会使用，因为不能达到高可用，且连RDB或AOF备份都只能放在master上，所以基本上不会使用。</p><p>另外几种模式都无法避免两个问题：</p><ol><li>异步数据丢失。</li><li>脑裂问题。</li></ol><p>所以redis官方针对这种情况提出了红锁（<strong>Redlock</strong>）的概念。</p><p>假设有5个redis节点，这些节点之间既没有主从，也没有集群关系。客户端用相同的key和随机值在5个节点上请求锁，请求锁的超时时间应小于锁自动释放时间。当在3个（超过半数）redis上请求到锁的时候，才算是真正获取到了锁。如果没有获取到锁，则把部分已锁的redis释放掉。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis发布订阅模式</title>
      <link href="2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis发布订阅模式"><a href="#Redis发布订阅模式" class="headerlink" title="Redis发布订阅模式"></a>Redis发布订阅模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Redis发布订阅（pub/sub）是一种消息通信模式：发布者（pub）,发送消息，订阅者（sub）接收消息。</p><ul><li>下图展示了频道 channel1，以及订阅这个频道的三个客户端–client1、client2和client3之间的关系：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287271460.png" alt="1609287271460"></p><ul><li>当有新的消息通过PUBLISH命令发送给频道 channel1 时，这个消息就会被发送给订阅他的三个客户端：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287501584.png" alt="1609287501584"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>// TODO</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个 redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer结构，结构的 pubsub_channels 属性是一个字典，这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287992211.png" alt="1609287992211"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度确不够快的话，那么不断积压消息会使 redis 输出缓冲区的体积变得越来越大，这可能使得 redis 本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短期时间发布者发布的消息。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>消息订阅：公众号订阅，微博关注等等（其实更多的是消息队列来进行实现）</li><li>多人在线聊天室</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ来处理。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事务</title>
      <link href="2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis 事务本质：一组命令的集合。</p><p>事务中每条命令都会被序列化，执行过程中按照顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>循序性</li><li>排他性</li></ul><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性</li></ol></blockquote><p>Redis 事务操作过程</p><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ul><p>所有事务中的命令在加入时没有被执行，直到提交时才会开始执行（Exec）一次性完成</p><p>取消事务(discurd)</p><p>事务错误</p><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><blockquote><p>代码逻辑国务（运行时异常） <strong>其他命令能正常执行，所以不保证事务的原子性</strong></p></blockquote><p>监控</p><p>悲观锁：</p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p>乐观锁：</p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用 watch key 监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于 getversion）</p></blockquote><p>我们启动另外一个客户端模拟插入线程。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="一、持久化——-RDB"><a href="#一、持久化——-RDB" class="headerlink" title="一、持久化—— RDB"></a>一、持久化—— RDB</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><ul><li><p>在指定时间间隔后，将内存中的数据快照写入硬盘，在恢复的时候，直接读取快照文件，进行数据的恢复。</p></li><li><p>默认情况下，redis将数据库快照保证在名字为 dump.rdb 的二进制文件中。文件名可以在配置文件中进行自定义。</p></li></ul><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>在进行rdb的时候，redis主线程是不会做io操作的，主线程会 fork 一个子线程来完成该操作：</p><ol><li>Redis 调用 fork 。 同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中</li><li>当子进程完成对新 RDB 文件写入时， Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件</li></ol><p>这种工作方式使得Redis 可以从写时复制（copy-on-write） 机制中获益（因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求）</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ol><li>save 的规则满足的情况下， 会自动触发 rdb原则</li><li>执行 flushall 命令也会触发我们的 rdb 原则</li><li>退出 redis 也会自动产生 rdb 文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 save 命令， 会立刻对当前内存中的数据进行持久化， 但是会阻塞， 也就是不接受其他操作了</p><blockquote><p>由于 save 命令是同步命令， 会占用 Redis 的主进程。 若Redis 数据非常多时， save 命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><p>flushall 命令也会触发持久化</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件：</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在 “N 秒内数据集至少有 M 个改动” 这一条件满足时， 会自动进行数据集保存操作。</p></blockquote><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 是异步进行， 进行持久化的时候， redis 还可以将继续响应客户端请求</p><p>bgsave 和 save 对比</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了</li><li>fork 进程的时候， 会占用一定的内存空间</li></ol><h2 id="二、持久化——-AOF"><a href="#二、持久化——-AOF" class="headerlink" title="二、持久化—— AOF"></a>二、持久化—— AOF</h2><p>Append Only File</p><p>将我们所有的命令都记录下来， history 恢复的时候就把这个文件全部再执行一遍</p><blockquote><p>以日志的形式来记录每个写操作，将redis执行的指令记录下来（读操作不记录），只需追加文件但不可以修改文件，redis 启动之初会读取改文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>快照功能（RDB) 并不是非常耐久：如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入，以及未保存到快照中的那些数据，从1.1版本开始，Redis增加了一种完全耐久的持久方式：AOF持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/1609059576333.png" alt="1609059576333"></p><blockquote><p> appendonly  yes 则表示启动AOF</p><p>appendfilename “appendonly.aof”  表示保存的文件名为 “appendonly.aof”</p><p>appendfsync  everysec  每秒同步一次</p></blockquote><p>appendonly 默认是no  不开启的，我们需要手动配置，然后重启redis，就可以生效</p><p>如果这个aof文件有错误，这时候 redis 是启动不起来的，我们需要修改这个aof文件</p><p>redis给我们提供了一个工具， redis-check-aof –fix</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>每一次修改都会同步，文件的完整性会更加的好</li><li>每秒同步一次，可能会丢失最后一秒的数据</li><li>从不同步，效率最高</li></ul><p>缺点</p><ul><li>相对于数据文件来说，aof远远大于rdb，修复速度比 rdb 慢！</li><li>aof 运行效率也比 rdb 慢，所以我们 redis 默认的配置就是 rdb 持久化</li></ul><p>RDB与AOF的选择</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><p>如何选择使用哪种持久化方式？</p><ul><li><p>一般来说，如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p></li><li><p>如果你非常关心你的数据，但仍然可以承受部分数据数分钟以内的丢失，那么你可以选择只使用RDB 持久化</p></li><li><p>有很多用户都只是用AOF持久化，但并不推荐这种持久化方式：因为定时生成的AOF快照非常便于数据备份，并且RDB恢复数据集的速度也要比 AOF 恢复的速度快</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>5中基本使用类型及使用场景</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis配置</title>
      <link href="2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/"/>
      <url>2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061040941.png" alt="1609061040941"></p><h2 id="其他配置文件设置"><a href="#其他配置文件设置" class="headerlink" title="其他配置文件设置"></a>其他配置文件设置</h2><blockquote><p>可以设置多个配置文件组合使用</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061174389.png" alt="1609061174389"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><blockquote><p>bind 127.0.0.1  # IP绑定</p><p>protected-mode yes    # 保护模式，默认开启</p><p>port 6379    # 端口号，默认6379</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061264732.png" alt="1609061264732"></p><h2 id="日志输出级别"><a href="#日志输出级别" class="headerlink" title="日志输出级别"></a>日志输出级别</h2><blockquote><p>loglevel notice    # 日志级别设置。（有debug,verbose,notice,waring四种级别）</p><p>logfile    “” # 日志文件名称</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061433425.png" alt="1609061433425"></p><h2 id="持久化（RDB，SNAPSHOTTING）"><a href="#持久化（RDB，SNAPSHOTTING）" class="headerlink" title="持久化（RDB，SNAPSHOTTING）"></a>持久化（RDB，SNAPSHOTTING）</h2><blockquote><ul><li>持久化规则，持久化文件 .rdb  .aof文件中</li></ul><p>save 900 1 # 如果900秒内， 至少1个key进行了修改，就进行持久化</p><p>save 300 10    # 300 秒内， 10个 key 进行了修改，则进行持久化</p><p>save 60 10000    # 60秒内， 10000个 key  进行了修改，则进行持久化</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061586443.png" alt="1609061586443"></p><blockquote><p> stop-writes-on-bgsave-error yes    # 持久化错误继续工作</p><p> rdbcompression yes    # 压缩 .rdb 文件</p><p>rdbchecksum yes    # 检验 rdb文件</p><p>dbfilename dump.rdb    # 保存文件名称为 dump.rdb</p><p>dir ./    # rdb 文件保存的目录</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061879993.png" alt="1609061879993"></p><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062044223.png" alt="1609062044223"></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062119419.png" alt="1609062119419"></p><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><blockquote><p>requirepass foobared # 密码设置</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062373660.png" alt="1609062373660"></p><h2 id="客户端连接设置"><a href="#客户端连接设置" class="headerlink" title="客户端连接设置"></a>客户端连接设置</h2><blockquote><p>maxclients 10000  最大客户端数量<br>maxmemory <bytes> 最大内存限制<br>maxmemory-policy noeviction </bytes></p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062480854.png" alt="1609062480854"></p><h2 id="过期策略配置"><a href="#过期策略配置" class="headerlink" title="过期策略配置"></a>过期策略配置</h2><blockquote><p>有八种过期策略配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 只对设置了过期时间的key进行lru</span><br><span class="line">volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line"># 删除lru算法的key</span><br><span class="line">allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># 只对设置了过期时间的key进行lfu</span><br><span class="line">volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="line"># 删除lfu算法的key</span><br><span class="line">allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># 随机删除即将过期key</span><br><span class="line">volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="line"># 随机删除</span><br><span class="line">allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># 删除即将过期的</span><br><span class="line">volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># 永不过期，返回错误</span><br><span class="line">noeviction -&gt; Don&#39;t evict anything, just return an error on write operations</span><br></pre></td></tr></table></figure><p>默认过期策略是：noeviction</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062738767.png" alt="1609062738767"></p><h2 id="持久化（AOF）"><a href="#持久化（AOF）" class="headerlink" title="持久化（AOF）"></a>持久化（AOF）</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;appendonly no# 默认不开启 AOF </span><br><span class="line">&gt;appendfilename &quot;appendonly.aof&quot;# 默认文件名</span><br><span class="line"></span><br><span class="line">&gt;appendfsync always# 每次修改进行同步</span><br><span class="line">&gt;appendfsync everysec# 每秒执行一次同步</span><br><span class="line">&gt;appendfsync no# 不进行同步， 由操作系统进行同步，速度最快</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062990992.png" alt="1609062990992"></p><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609063021674.png" alt="1609063021674"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

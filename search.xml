<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程--线程池</title>
      <link href="2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul><li>线程池提供了一种限制和管理资源</li><li>好处：<ul><li>降低资源消耗：线程的创建和销毁需要消耗资源</li><li>提高响应速度：当任务达到的时候，任务可以不用等待线程创建就能立即执行</li><li>提高线程的可管理性：线程是稀缺资源，不可以无限创建，需要统一分配和调度、监控</li></ul></li></ul><h1 id="Runable接口和Callable接口的区别"><a href="#Runable接口和Callable接口的区别" class="headerlink" title="Runable接口和Callable接口的区别"></a>Runable接口和Callable接口的区别</h1><ul><li>Runable 接口没有返回结果和抛出异常</li><li>Callable 接口偶返回结果和抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h1><h2 id="使用-Executors"><a href="#使用-Executors" class="headerlink" title="使用 Executors"></a>使用 Executors</h2><blockquote><p>// 允许创建线程的数量为 Integer.MAX_VALUE，可能会导致创建大量线程，从而导致 OOM</p><p>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</p><p>// 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM<br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</p><p>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</p><p>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</p></blockquote><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><ul><li>FixedThreadPool ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的数量始终不变。当有一个新的任务提交时，线程池中若有空闲的线程，则立即执行。若没有，则新的任务会暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>FixedThreadPool ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li><li>因为最大线程数固定，不会拒绝任务，在任务比较多的时候会导致 OOM</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610064973712.png" alt="1610064973712"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul><li>SingkeThreadExecutor：方法返回<strong>一个只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会碑额保存在一个队列中，等待线程空闲，按先入先出的顺序执行队列中的任务。</li><li>SingleThreadExecutor ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065305945.png" alt="1610065305945"></p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><ul><li>CachedThreadPool：<strong>可以根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可以复用的线程。若所有的线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<ul><li>CachedThreadPool 的 corePoolSize 被设置为空 (0) , maxinumPoolSize 被设置为 Integer.MAX_VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maxinunPool 中线程处理任务的速度时， CacheThreadPool 会不断创建新的线程，极端情况下，这样会导致耗尽 CPU 和 内存资源。</li><li>CacheThreadPool 允许创建的线程数量为 Integer.MAX_VALUE , 可能会创建大量线程，造成 OOM.</li></ul></li></ul><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><ul><li>ScheduledThreadPool：创建一个定长线程池，支持 定时及周期性任务执行</li><li>ScheduledThreadPoolExecutor ：使用的任务队列 DelayQueue 封装了一个 PriortyQueue 会对队列中的任务进行排序，执行所需时间段的放在前面先被执行 （ScheduleFuture 的 time 变量小的先执行），如果执行所需时间相同则先提交的任务将被先执行 （ScheduleFuture 的 squenceNumber 变量小的先执行）。</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065993004.png" alt="1610065993004"></p><h2 id="使用-ThreadPoolExecutor"><a href="#使用-ThreadPoolExecutor" class="headerlink" title="使用 ThreadPoolExecutor"></a>使用 ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>corePoolSize：核心线程数线程数定义了<strong>最小可以同时运行的线程数量</strong>。</p></li><li><p>maxinumPoolSize：当<strong>队列中存在的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</strong>。</p></li><li><p>workQueue：当<strong>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放在队列中</strong>。</p></li><li><p>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</p></li><li><p>unit：keepAliveTime 参数的时间单位。</p></li><li><p>threadFactory：executor 创建新线程的时候会用到</p></li><li><p>handler ：饱和策略，<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略</strong></p><ul><li>ThreadPoolExecutor.<strong>AbortPolicy</strong>：抛出  RejectedExecutionException 来拒绝新任务的处理。</li><li>ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>：调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行 (run) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务的提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.<strong>DiscardPolicy</strong>： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.<strong>DiscardOldestPolicy</strong>： 此策略将丢弃最早的未处理的任务请求。</li></ul></li></ul><h3 id="ThreadPoolExecutor中的execute方法和submit方法区别"><a href="#ThreadPoolExecutor中的execute方法和submit方法区别" class="headerlink" title="ThreadPoolExecutor中的execute方法和submit方法区别"></a>ThreadPoolExecutor中的execute方法和submit方法区别</h3><ul><li>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li><li>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值， get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h3 id="shutdown-和shutDownNow"><a href="#shutdown-和shutDownNow" class="headerlink" title="shutdown()和shutDownNow()"></a>shutdown()和shutDownNow()</h3><ul><li>shutdown()：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow()：关闭线程池，线程的状态变为 STOP。线程池会终止正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h3><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                MAX_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                KEEP_ALIVE_TIME,<span class="comment">//</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//  executor.execute(worker);</span></span><br><span class="line">            Future&lt;?&gt; result = executor.submit(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h1><p>需要根据实际业务场景来划分</p><ul><li>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存泄漏--ThreadLocal</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>内存泄漏是堆内存中不再使用的对象，但是垃圾收集器没有将它们删除的情况，因此它们将会被不必要的一直存在。这样会消耗内存资源，降低系统性能，最终可能导致OOM发生。</li></ul><h1 id="Java中内存泄漏的类型"><a href="#Java中内存泄漏的类型" class="headerlink" title="Java中内存泄漏的类型"></a>Java中内存泄漏的类型</h1><h2 id="static字段引起内存泄漏"><a href="#static字段引起内存泄漏" class="headerlink" title="static字段引起内存泄漏"></a>static字段引起内存泄漏</h2><ul><li>静态的资源一般与整个应用拥有相匹配的生命周期</li><li>尽量减少使用。</li></ul><h2 id="未关闭的资源导致内存泄漏"><a href="#未关闭的资源导致内存泄漏" class="headerlink" title="未关闭的资源导致内存泄漏"></a>未关闭的资源导致内存泄漏</h2><ul><li>创建连接或打开流时，JVM会为这些资源分配内存。如果连接没有关闭，会导致占有内存。</li><li>可以在finally块中或try-with-resources块中关闭</li></ul><h2 id="不正确的hashCode和equals"><a href="#不正确的hashCode和equals" class="headerlink" title="不正确的hashCode和equals"></a>不正确的hashCode和equals</h2><ul><li>重写不合理会导致内存泄漏</li><li>用最佳的方式重写hashCode和equals</li></ul><h2 id="引用了外部类的内部类"><a href="#引用了外部类的内部类" class="headerlink" title="引用了外部类的内部类"></a>引用了外部类的内部类</h2><ul><li>使用了一个非静态的内部类对象，这个时候内部类依赖于外部类对象。即使用完了内部类，这个对象也不会被收集</li><li>如果内部类不访问外部类的成员，可以转换为静态类</li></ul><h2 id="重写了finalize方法"><a href="#重写了finalize方法" class="headerlink" title="重写了finalize方法"></a>重写了finalize方法</h2><h2 id="ThreadLoacl造成内存泄漏"><a href="#ThreadLoacl造成内存泄漏" class="headerlink" title="ThreadLoacl造成内存泄漏"></a>ThreadLoacl造成内存泄漏</h2><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><ul><li>每个线程拥有自己本地专属的变量，可以用ThreadLoal类。</li><li>ThreadLoal类让每个线程绑定自己的值，存储线程私有数据。避免线程出现竞争。</li><li>ThreadLocal类是使用ThreadLoalMap类来实现定制化的HashMap的。调用ThreadLocal类的set或get方法，实际调用的是ThreadLocalMap类的get、set方法。</li><li>变量最终是存在ThreadLocalMap中。</li><li>ThreadLocalMap可以存以ThreadLocal为key，Object对象为value的值对。</li><li>ThreadLocalMap中的key是ThreadLocal的弱引用，而value是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。</li><li>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录<strong>。使用完 ThreadLocal方法后 最好手动调用remove()方法</strong></li></ul><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><blockquote><ul><li><p>每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行set方法中，是从当前线程的<code>threadLocals</code>变量获取。</p></li><li><p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p></li></ul></blockquote><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><blockquote><p>没有链表结构，那发生hash冲突了怎么办？</p><ol><li>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小<code>0x61c88647</code>。</li><li>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：<ol><li>如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； </li><li>不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value； </li><li>很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</li></ol></li><li>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</li><li>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--AQS</title>
      <link href="2020/12/31/java/juc/java-juc-AQS/"/>
      <url>2020/12/31/java/juc/java-juc-AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><ul><li>AQS 是一个用来构建锁和同步器的框架</li></ul><h1 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h1><ul><li><p>如果请求的资源空闲，当前请求资源的线程就可以获取资源，并且给资源加上锁。如果当前请求的资源被暂用，就需要一套阻塞和唤醒机制，AQS使用CLH队列实现，将目前获取不到资源的锁的现场，加入到队列中</p></li><li><p>CLH 队列</p><ul><li>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个节点 （Node） 来实现锁的分配。</li><li>虚拟的双向队列，并没有队列实例，仅存在节点间的指向关系。</li></ul></li><li><p>AQS 使用一个volatile int state 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。 AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p></li></ul><h1 id="AQS-资源共享方式"><a href="#AQS-资源共享方式" class="headerlink" title="AQS 资源共享方式"></a>AQS 资源共享方式</h1><ul><li> Exclusive (独占)：：只有一个线程能执行， 如 ReentantLock</li><li>Share（共享）：多个线程可同时执行， 如 Semaphore/CountDownLatch</li></ul><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>在 AQS 独占式资源共享方式中</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到先拿到锁。</li><li>非公平锁：当线程要获取锁时，无视队列的顺序直接去抢锁（CAS），谁先抢到就是谁的</li></ul><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><ul><li>以 ReentrantLock 为例， state 初始化为 0 ， 表示未锁定状态。 A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 share +1 。此后，其他现场再 tryAcquire() 时就会失败， 直到 A 线程 unlock() 到 state = 0 （即释放锁）为止， 其他线程才有机会获取该锁。当然，锁释放之前， A 线程自己是可以重复获取此锁的 （state 会累加），这就是可重入的概念。但是要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的</li></ul><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><ul><li>再以 CountDownLatch 为例，任务分配为 N 个线程去执行， state 也初始化为 N（注意 N 要与线程个数一致）。 该 N 个子线程是并行执行的， 每个子线程执行完后 countDown() 一次， state 会 CAS 减1。等到所有子线程都执行完后 （即 state =0）, 会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</li><li>（倒计时器）： CountDownLatch 是一个同步工具类， 用来协调多个线程之间同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，在开始执行。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><ul><li>Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源， Semaphore （信号量）可以指定多个线程同时访问某个资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> num = i;</span><br><span class="line">       cachedThreadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//请求获得许可，如果有可获得的许可则继续往下执行，许可数减1。否则进入阻塞状态</span></span><br><span class="line">                   semaphore.acquire();</span><br><span class="line">                   <span class="comment">//执行</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;Accessing: &quot;</span> + num);</span><br><span class="line">                   Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 模拟随机执行时长</span></span><br><span class="line">                   <span class="comment">//释放</span></span><br><span class="line">                   semaphore.release();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Release...&quot;</span> + num);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cachedThreadPool.shutdown();</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h1><ul><li>可以实现线程间的技术等待</li><li>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--JMM和volatile关键字</title>
      <link href="2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM和volatile关键字"><a href="#JMM和volatile关键字" class="headerlink" title="JMM和volatile关键字"></a>JMM和volatile关键字</h1><h1 id="JMM相关"><a href="#JMM相关" class="headerlink" title="JMM相关"></a>JMM相关</h1><h2 id="CPU缓存模型"><a href="#CPU缓存模型" class="headerlink" title="CPU缓存模型"></a>CPU缓存模型</h2><blockquote><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。<strong>于是就有了在CPU和主内存之间增加缓存的设计</strong>。最靠近CPU的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p><ul><li>CPU访问数据 -&gt; L1 L2 高速缓存 -&gt; 一致性协议 -&gt; 内存</li></ul></blockquote><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609942893338.png" alt="1609942893338"></p><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><ul><li><p>JMM描述的是变量存储到内存和从内存中读取变量的细节。</p></li><li><p>Java中实例变量和类变量都是存在于主内存，是线程共享的。</p><blockquote><ul><li>每个线程都有一个自己的工作内存，它从主内存读取数据到工作内存中进行使用。这样就可能造成了一个线程在主内存中修改了一个变量的值，而另一个线程还在使用之前拷贝的值，就造成了数据的不一致型。</li><li>解决：把变量声明为volatile，指示这个变量是不稳定的，没用使用的时候需要从主内存中读取。</li></ul></blockquote></li></ul><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609943944217.png" alt="1609943944217"></p><blockquote><ul><li>主内存 所有线程共享的内存区域 线程内存 线程自己私有的内存区域 主内存和线程内存通过save和load操作进行交互 所有提到的内存区域并不是真实存在的，而是虚拟存在的，就和虚拟机的运行时数据区一样。</li></ul></blockquote><h2 id="JMM-的八种内存交互操作"><a href="#JMM-的八种内存交互操作" class="headerlink" title="JMM 的八种内存交互操作"></a>JMM 的八种内存交互操作</h2><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609946346742.png" alt="1609946346742"></p><ol><li>lock(锁定)：作用于<strong>主内存</strong>中的变量，一个变量在同一时间只能被一个线程锁定，即把变量标识为线程<strong>独占</strong>状态。</li><li>read(读取)：作用于<strong>主内存</strong>变量，表示把一个变量值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。</li><li>load(载入)：作用于线程的<strong>工作内存</strong>的变量，表示把 read 操作从主内存中读取的变量值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</li><li>use(使用)：作用于线程的<strong>工作内存</strong>中的变量，表示把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</li><li>assign(赋值)：作用于线程的<strong>工作内存</strong>的变量，表示把执行引擎返回的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</li><li>store(存储)：作用于线程的<strong>工作内存</strong>中的变量，把工作内存中的一个变量的值传递给主内存，以便下一步的 write 操作使用。</li><li>write(写入)：作用于<strong>主内存</strong>的变量，表示把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，表示把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ol><p>JMM 还规定了以上八种操作需按照如下规则进行：</p><ul><li>不允许read 和 load、store 和 write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许线程将没有 assign 的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施 use 和 store 操作之前，必须经过 load 和 assign 操作。</li><li>一个变量同一时间只能有一个线程对其进行 lock 操作。但 lock 操作可以被同一条线程重复执行多次，多次 lock 之后，必须执行相同次数 unlock 才可以解锁。</li><li>如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。</li><li>如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="JMM-三大特征"><a href="#JMM-三大特征" class="headerlink" title="JMM 三大特征"></a>JMM 三大特征</h2><blockquote><p>JMM 三大特征分别是：原子性，可见性，有序性。整个 JMM 实际上也是围绕着这三个特征建立起来的，并且也是 Java 并发编程的基础。</p></blockquote><p><strong>原子性</strong>：原子性是指一个操作是不可分割、不可中断的，要么全部执行成功要么全部执行失败。</p><ul><li>synchronized 修饰的代码块之间的操作都是原子性的，<strong>volatile不保证原子性</strong></li></ul><p><strong>可见性</strong>：可见性是指所有线程都能看到共享内存的最新状态。即当一个线程修改了一个共享变量的值时，其他线程能够立即看到该变量的最新值。</p><ul><li>volatile 关键字之外，final 和 synchronized 也能实现可见性。</li></ul><p><strong>有序性</strong>：有序性是指程序执行的顺序按照代码的先后顺序执行。</p><ul><li><p>可以通过 volatile 和 synchronized 关键字来保证多线程之间操作的有序性。</p><ul><li><p>volatile 关键字是通过在主存中加入内存屏障来达到禁止指令重排序，来保证有序性。</p></li><li><p>synchronized 关键字原理是，一个变量在同一时刻只能被一个线程 lock，并且必须 unlock 后，其他线程才可以重新 lock，使得被 synchronized 修饰的代码块在多线程之间是串行执行的。</p></li></ul></li></ul><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li>volatitle可以保证变量的可见性。</li></ul><h2 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h2><ul><li>volatile写是在前⾯和后⾯分别插⼊<strong>内存屏障</strong>，⽽volatile读操作是在后⾯插⼊两个内存屏障。</li></ul><h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><blockquote><p>compare-and-swap–比较并替换</p></blockquote><ul><li>CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：如果当前值等于预期值，则将内存修改为新值，否则不做任何操作。</li><li>Java中Unsafe类</li><li>每次在执行CAS操作时，线程会根据valueOffset去内存中获取当前值去跟expect的值做对比如果一致则修改并返回true，如果不一致说明有别的线程也在修改此对象的值，则返回false</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><ul><li>一个线程对变量进行了修改，然后又修改会原来的值，对于其他线程来说好像没有变化。</li><li>解决ABA最简单的方案就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号</li></ul><h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><ul><li>volatile是线程同步的轻量级实现，只能修饰变量；而synchronized可以修饰方法及代码块</li><li>volatile关键字能够保证数据的可见性，不能保证数据的原子性；synchronized两者都可以保证</li><li>volatile解决的是多个线程访问变量的可见性；synchronized解决的是多线程之间访问资源的同步性</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--synchronized</title>
      <link href="2020/12/31/java/juc/java-juc-synchronized/"/>
      <url>2020/12/31/java/juc/java-juc-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>synchronized 是为了解决多线程同步访问资源的问题。 synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li><li>Java多线程依赖于操作系统原生线程，所以挂起或者唤醒一个线程，需要操作系统帮忙完成。而操作系统需要从用户状态切换成内核状态，时间相对较长，时间成本高。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>修改实例方法：作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</p><blockquote><p>多个线程操作同一个实例的加锁方法时，线程安全</p></blockquote></li><li><p>修饰静态方法：作用于当前类对象(Class对象，每个类都有一个Class对象)，进入同步代码前要获得当前类对象（Class对象）的锁。</p><blockquote><p>多个线程操作同一个Class的多个实例时，线程安全。（如果是非静态方法加的synchronized那么则是不安全的，因为不是同一把锁）</p></blockquote></li><li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><blockquote><ul><li><p>synchronized(this){}，当前实例对象锁</p></li><li><p>synchronized(ObjA.class){}，class对象锁</p></li></ul></blockquote></li></ul><blockquote><ul><li>在 java 中，每一个对象有且仅有一个同步锁。这也意味着：同步锁是依赖于对象存在的。</li><li>当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。（例如：synchronized(ObjA) 就获取了 “ObjA这个对象” 的同步锁）</li><li>不同线程对同步锁的访问是互斥的。（也就是说：某个时间点，对象的同步锁只能被一个线程获取到，通过同步锁，能实现多线程间 “对象/方法” 的互斥访问）</li></ul></blockquote><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头</strong>（Header），<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong></p><ul><li>普通对象的对象头包含两个部分：<strong>Mark Word</strong> 和 <strong>Class Metadata Address</strong> （类型指针）</li><li>如果是数组的对象头还额外包括 <strong>Array length</strong> 数组长度部分</li></ul><h3 id="Mark-word："><a href="#Mark-word：" class="headerlink" title="Mark word："></a>Mark word：</h3><ul><li>用于存储对象自身的运行时数据，如 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li></ul><h3 id="Class-Metadata-Address：类型指针"><a href="#Class-Metadata-Address：类型指针" class="headerlink" title="Class Metadata Address：类型指针"></a>Class Metadata Address：类型指针</h3><ul><li>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪一个类的实例</li></ul><h3 id="Array-length：数组长度"><a href="#Array-length：数组长度" class="headerlink" title="Array length：数组长度"></a>Array length：数组长度</h3><ul><li>如果对象是数组类型。则虚拟机用3个 Word （字宽）存储对象头，如果对象是非数组类型，则用 2 字节宽存储对象头。在 32 位虚拟机中，一字节宽等于 4 字节，及 32bit。</li></ul><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象hashCode或锁信息等运行时数据。</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><h4 id="Mark-Word详解"><a href="#Mark-Word详解" class="headerlink" title="Mark Word详解"></a>Mark Word详解</h4><p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><blockquote><p>例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，MarkWord的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，</p><p>在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p></blockquote><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609892506114.png" alt="1609892506114"></p><h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><ul><li><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做<strong>内部锁</strong>或者<strong>Monitor锁</strong>。</p></li><li><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系又存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header       = <span class="literal">NULL</span>;</span><br><span class="line">   _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">   _waiters      = <span class="number">0</span>,</span><br><span class="line">   _recursions   = <span class="number">0</span>;</span><br><span class="line">   _object       = <span class="literal">NULL</span>;</span><br><span class="line">   _owner        = <span class="literal">NULL</span>;</span><br><span class="line">   _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">   _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">   _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">   _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609893330560.png" alt="1609893330560"></p><h2 id="synchronized-关键字底层原理是JVM层面的"><a href="#synchronized-关键字底层原理是JVM层面的" class="headerlink" title="synchronized 关键字底层原理是JVM层面的**"></a>synchronized 关键字底层原理是JVM层面的**</h2><h3 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h3><ol><li>synchronized 同步语句块的实现使用的是 <strong>monitorenter</strong> 和 <strong>monitoreexit</strong> 指令， 其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置</li><li>当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor 对象的特有权。<strong>当计数器为 0 则可以成功获取monitor</strong>，获取后将锁计数器设为 1 就是 加1 （<strong>重入时计数器的值也会加 1</strong>）， 。相对应的在执行 monitorexit 指令后， 所得计数器就会 -1，当锁计数器变为0，标明锁被释放。</li><li>如果获取对象的锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li><li>（monitor 对象存在于每个 java 对象的对象头中 ，synchronized 锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因）</li></ol><h3 id="synchronized-修饰方法的情况"><a href="#synchronized-修饰方法的情况" class="headerlink" title="synchronized 修饰方法的情况"></a>synchronized 修饰方法的情况</h3><ol><li><p>JVM 通过 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p></li><li><p>用的是一个隐式的 monitorenter 和 monitorexit 指令。</p><blockquote><ol><li>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。</li><li>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</li><li>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词），然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</li><li>在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</li></ol></blockquote></li></ol><h2 id="synchronized-锁优化的过程（锁升级）"><a href="#synchronized-锁优化的过程（锁升级）" class="headerlink" title="synchronized 锁优化的过程（锁升级）"></a>synchronized 锁优化的过程（锁升级）</h2><ul><li>锁的状态有：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，随着锁竞争的激烈而逐渐升级。锁只可以升级不可以降级，这种策略是为了提高获取锁和释放锁的效率。</li></ul><blockquote><p>Synchronized的实现依赖于与某个对象向关联的monitor（监视器）实现，而monitor是基于底层操作系统的Mutex Lock实现的，而基于Mutex Lock实现的同步必须经历从用户态到核心态的转换，这个开销特别大，成本非常高。所以频繁的通过Synchronized实现同步会严重影响到程序效率，而这种依赖于Mutex Lock实现的锁机制也被称为“重量级锁”，为了减少重量级锁带来的性能开销，JDK对Synchronized进行了种种优化。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>单个线程重复访问资源的时候没有必要向操作系统重新申请轻量级锁。</li></ul><h4 id="获取锁："><a href="#获取锁：" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><h4 id="释放锁："><a href="#释放锁：" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><p><strong>偏向锁的释放采用了一种只有竞争才会释放锁的机制</strong>，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><blockquote><p>在有锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里?</p><p>下面先看偏向锁的情况，偏向锁时，mark word中记录了线程id，没有足够的额外空间存储hashcode，所以，答案是：</p><ol><li>当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；</li><li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li><li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。</li></ol><p>因为mark word里没地方同时放bias信息和identity hash code。 HotSpot VM是假定“实际上只有很少对象会计算identity hash code”来做优化的；换句话说如果实际上有很多对象都计算了identity hash code的话，HotSpot VM会被迫使用比较不优化的模式。</p></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>多个线程重复访问资源的时候，可以使用指针竞争的方式来获取轻量级锁</li></ul><h4 id="获取锁：-1"><a href="#获取锁：-1" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><h4 id="释放锁：-1"><a href="#释放锁：-1" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><pre><code>&gt; 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</code></pre><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p><blockquote><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p></blockquote><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><ul><li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li>如果没有在第一时间获取到轻量级锁，可能需要等一会儿就可以获取锁。这时使用 CAS 的操作不断自旋该线程。默认限定 10 次，没有获取锁，就用传统方式挂起线程。</li><li>在自旋的基础上， Java1.6 引入了适应性自旋锁。它的等待时间不是固定的，而是由前一次操作的时间以及锁拥有的状态来决定。</li></ul><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><ul><li><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p></li><li><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法。</li></ul><h3 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h3><ul><li>偏向锁：通常只有一个线程访问临界区</li><li>轻量级锁：可以有多个线程交替进入临界区，竞争不激烈的时候，稍微自旋就能获得锁</li><li>重量级锁：线程间出现激烈的竞争就需要重量级锁，未获得锁的线程就会进入阻塞队列，需要操作系统介入。</li></ul><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的开销，和执行非同步方法比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td><td>追求响应时间。同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>锁竞争不适用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="锁的膨胀流程图解"><a href="#锁的膨胀流程图解" class="headerlink" title="锁的膨胀流程图解"></a>锁的膨胀流程图解</h3><p><img src="/2020/12/31/java/juc/java-juc-synchronized/165adaeab7580a64.png" alt="165adaeab7580a64"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--基本概念</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程：程序的一次执行过程，程序的运行就是一个进程从创建、运行到消亡的过程。进程是计算机运行的基本单位，进程之间是相互独立的。</li><li>线程：线程是 CPU 执行的基本单位，一个进程可以分为多个线程，多个线程对进程的资源使用存在竞争关系。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>创建：线程 new 之后进入创建状态，调用 start() 方法进入就绪状态。</li><li>就绪：线程就绪状态需要等待 CPU 调用执行</li><li>运行：线程获取了 CPU 时间，进入运行中状态</li><li>等待：wait、join、LockSupport.park 进入等待状态，需要其他线程通知才能进入运行状态 （notify、notifyAll、LockSupport.unPark）</li><li>超时等待：在等待的基础上加了一个超时时间，超时时间到了就自动进入运行状态（sleep，wait（long），LockSupport.pariUntil，LockSupport.parkNanos）</li><li>阻塞：线程调用同步方法或者代码块，未获得锁时，进入阻塞状态</li><li>终止：线程执行完 run 方法后进入终止状态</li></ul><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li>并行：多个处理器上，执行多个任务</li><li>并发：单个处理器上，多个任务交替执行。线程通过轮询获取 CPU 的执行时间。</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>多个线程同时被阻塞，他们中的一个或者多个都在等待某个资源被释放。由于无限期的阻塞，线程无法正常终止。</li></ul><h2 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件"></a>线程死锁的四个必要条件</h2><ul><li>互斥条件：某一个资源某一时刻只能有一个线程使用</li><li>请求和保持条件：一个线程在请求其他资源的时候，对其中持有的资源不释放</li><li>不可剥夺条件：线程已获得的资源在未使用的情况下不能被其他线程强行剥夺，只能由该线程使用完毕后自己释放</li><li>循环等待条件：多个线程形成的一种首位相接的等待资源的关系。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul><li><p>破坏线程死锁产生的四个条件之一</p><blockquote><ul><li>破坏互斥条件：这个条件我们没法破坏，因为我们用锁本来就是想让他们互斥（临界资源需要互斥访问）</li><li>破坏请求和保持条件：一次性申请所有的资源。</li><li>破坏不可剥夺条件：占用部分资源的现场进一步申请其他资源时，如果申请不到，可以主动释放他自己占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。</li></ul></blockquote></li></ul><h2 id="sleep和yeild方法"><a href="#sleep和yeild方法" class="headerlink" title="sleep和yeild方法"></a>sleep和yeild方法</h2><ul><li>sleep方法在超时等待一定时间后会自动唤醒，进入就绪状态；yield方法是当前线程进入就绪状态线程调</li><li>sleep方法后，无论其他线程的优先级都有机会运行；执行yield方法，只会给相同优先级或更高优先级的方法的线程运行的机会</li><li>sleep方法会抛出InterruptedException异常，而yield方法没有任何异常声明</li><li>循环中调用yield方法，yield死循环：线程yield之后有获得了cpu，导致其他线程无法获取资源</li></ul><h2 id="调用start方法，为什么不直接调用run方法"><a href="#调用start方法，为什么不直接调用run方法" class="headerlink" title="调用start方法，为什么不直接调用run方法"></a>调用start方法，为什么不直接调用run方法</h2><ul><li>调用 start 方法方可启动线程并使线程进入就绪状态，</li><li>而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li></ul><h2 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h2><ul><li>继承Thread类</li><li>实现Runable接口，实现run方法</li><li>实现Callable接口，实现call方法</li><li>使用线程池</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC参数和调优</title>
      <link href="2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/"/>
      <url>2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="GC参数和调优"><a href="#GC参数和调优" class="headerlink" title="GC参数和调优"></a>GC参数和调优</h2><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(HotSpot)的垃圾回收器</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾的回收作用范围"><a href="#jvm垃圾的回收作用范围" class="headerlink" title="jvm垃圾的回收作用范围"></a>jvm垃圾的回收作用范围</h1><p>下面描述的收集器是基于 JDK1.7 Update 14 之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图：如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/1610272098369.png" alt="1610272098369"></p><h1 id="jvm的7种垃圾回收器"><a href="#jvm的7种垃圾回收器" class="headerlink" title="jvm的7种垃圾回收器"></a>jvm的7种垃圾回收器</h1><h2 id="1-Serial收集器-单线程"><a href="#1-Serial收集器-单线程" class="headerlink" title="1.Serial收集器(单线程)"></a>1.Serial收集器(单线程)</h2><p>Serial收集器时最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。<br>Serial收集器依然是虚拟机运行在Cleent模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="2-ParNew收集器（Serial-多线程）"><a href="#2-ParNew收集器（Serial-多线程）" class="headerlink" title="2.ParNew收集器（Serial+多线程）"></a>2.ParNew收集器（Serial+多线程）</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The Worl、对象可分配规则、回收策略等都与Serial收集器完全一样。<br>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是除了Serial收集器之外，目前只有arNew它能与CMS收集器配合工作。</p><h2 id="3-Parallel-Scavenge-并行回收-收集器"><a href="#3-Parallel-Scavenge-并行回收-收集器" class="headerlink" title="3.Parallel Scavenge(并行回收)收集器"></a>3.Parallel Scavenge(并行回收)收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br>停顿时间越短就越适合需要与用户交互的程序良好的响应速度能提升用户体验，二高吞吐量则可用高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算二不需要太多的交互的任务。</p><p>Parallel Scavenga收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePPolicy/这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor去的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGvPauseMillis参数或者SGCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是paralel Scavenge收集器与ParNew收集器的一个重要区别</p><h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记清除算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p><p>如果在 Server 模式下，主要两大用途：</p><ol><li>在 JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器使用</li><li>作为 CMS 收集器的后备预案，在并行收集发生 Concurrent Mode Failure 时使用</li></ol><h2 id="5-Paralled-Old收集器"><a href="#5-Paralled-Old收集器" class="headerlink" title="5.Paralled Old收集器"></a>5.Paralled Old收集器</h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-清理”算法。这个收集器在 1.6 中才开始提供。</p><h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h2><p>CMS（ Concurrent Mark Sweep ） 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务器的相应速度，希望系统停顿时间最短，已给用户带来较好的体验。 CMS 收集器就非常符合这类应用需求</p><p>CMS 收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更加复杂一些，整个过程为4个步骤:</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要 “Stop the World”。</p><p>CMS 收集器的主要优点：并发收集，低停顿。</p><p>CMS 三个明显的缺点：</p><ol><li>CMS 收集器对 CPU 资源非常敏感。 CPU 个数少于4个时， CMS 对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的 CMS 收集器变种。所做的事情和单 CPU 年代 PC 机操作系统使用抢占式来模拟多线程任务机制的思想。</li><li>CMS 收集器无法处理浮动垃圾，可能出现“ Concurrent Mode Failure ”失败而导致另一次 Full Gc 的产生。在 JDK1.5 的默认设置下， CMS 收集器当老年代使用了 68% 的空间后就会被激活， 这是一个偏保守的设置， 如果在应用中老年代增长不是太快，可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK1.6 中， CMS 收集器的启动阈值已经提升到 92%。</li><li> CMS 是基于“标记-清除”算法实现的收集器，手机结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前发出 Full Gc。为了解决这个问题， CMS 收集器提供一个 -XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片整合并清理过程， 内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间变长了。虚拟机设计者还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction ，这个参数是用于设置执行多次不压缩 Full GC后，跟着来一次带压缩的FullGC（默认值为0，标识每次进入 FullGC时都进行碎片整理）</li></ol><h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h2><p>G1收集器的优势：</p><ol><li>并行与并发</li><li>分代收集</li><li>空间整理（标记整理算法，复制算法）</li><li>可预测的停顿（G1处追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M毫秒的时间片段内，消耗在垃圾收集器上的时间不超过 N 毫秒，这几乎已经实现 Java（ RTSJ ）的垃圾收集器的特征）</li></ol><p>使用 G1 收集器时， Java 堆的内存布局是整个规划为多个大小相等的独立区域（ Region ），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一小部分 Region 的集合。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个 Java 堆中进行全区域的垃圾收集。 G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值最大的 Region （这也就是 Garbage-First 名称的由来）。这种使用 Region 划分的内存空间以及优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽量可能高的效率。</p><p>G1 内存“化整为零”的思路</p><p>在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会遗漏。</p><p>如果不计算维护 Remembered Set 的操作， G1 收集器的运作大致可分为以下步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾分代收集</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾分代收集"><a href="#垃圾分代收集" class="headerlink" title="垃圾分代收集"></a>垃圾分代收集</h1><ul><li><p>Full GC ： 针对的是整个堆。包括：新生代、老年代、永久代。</p></li><li><p>针对HotSpot VM 的实现，他里面的GC其实准确分类只有两大类：</p><ul><li><p>部分收集器（Partial GC）：</p><ul><li>新生代收集器（Minor GC/ Yong GC）：只对新生代进行垃圾收集</li><li>老年代收集器（Major GC/Old GC）：只对老年代进行垃圾收集。</li><li>混合收集器（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区。</p></li></ul></li></ul><h1 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h1><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/1610272750274.png" alt="1610272750274"></p><h1 id="对象默认存活年龄"><a href="#对象默认存活年龄" class="headerlink" title="对象默认存活年龄"></a>对象默认存活年龄</h1><ul><li>晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6，The default value is 15 for the parallel(throughput) collector</li></ul><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><ul><li><p>对象优先在eden区分配</p></li><li><p>大对象直接进入老年代</p><ul><li>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。为了避免为大对象分配内存空间时由于分配担保机制带来的复制而降低效率</li></ul></li><li><p>长期存活的对象将进入老年代</p><ul><li>-XX:MaxTenuringThreshold</li></ul></li><li><p>动态对象年龄判定</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li>该算法分为 “标记” 和 “清除” 阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：<ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul></li></ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>为了解决效率问题，“复制” 收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</li></ul><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><ul><li>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li><li>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类和常量池引</title>
      <link href="2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h1><ul><li>字面量会到 java 堆中的常量池去找</li><li>new 的方式会在堆中创建</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/1610271202594.png" alt="1610271202594"></p><h1 id="String常量池的实现方式"><a href="#String常量池的实现方式" class="headerlink" title="String常量池的实现方式"></a>String常量池的实现方式</h1><ul><li>字面量：双引号括起来的</li><li>String.intern()：他的作用是：如果运行时常量池中已经包含一个等于此 Spring 对象内容的字符串，则返回常量池中该字符串的引用</li></ul><h1 id="String-s1-new-String-“abc”-；这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-；这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”)；这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”)；这句话创建了几个字符串对象？</h1><ul><li>将创建 1 或 2 个字符串，如果常量池中已存在字符串常量 “abc”，则只会在堆空间创建一个字符串常量 “abc” 。如果池中没有字符串常量 “abc” ，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共两个字符串对象。</li></ul><h1 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h1><ul><li><p>Java 基本类型的包装类的大部分都实现了常量池技术</p><ul><li> Byte、Short、Integer、Long：四种包装类默认创建了数字 [-128,127] 的相应类型的缓存数据</li><li>Character：创建了数值在[0,127]范围的缓存数据</li><li>Boolean；直接返回 True 或 False。</li></ul><blockquote><ul><li><p>如果超出对应范围仍然会去创建新的对象。</p></li><li><p>为啥把缓存设置为[-128,127]区间？ (参见issue、461)性能和资源之间的权衡。</p></li></ul></blockquote></li><li><p>算术运算符或比较运算符，对包装类型会有一个拆箱操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ul><li>加载</li><li>连接<ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/1610292210392.png" alt="1610292210392"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过类的全限定名，找到 Class 文件，将 Class 文件中的静态存储结构转换成方法区运行时数据结构，在内存中生活才能一个代表该类的 Class 对象，作为方法区这些数据的入口</li><li>数组类型不通过类加载器创建，由 JVM 直接创建</li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证字节码文件的安全性和完整性：包括：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>为类的静态变量分配内存和设置初始化值</li><li>实例变量会在对象实例化时随着对象一块分配在Java堆中。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code> 方法的过程。</li><li>类初始化的情况<ul><li>new、设置或获取类的静态资源</li><li>反射调用</li><li>子类初始化，先初始化父类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制</li><li>Java8中，接口定义了默认方法时，接口实现类发生了初始化，先初始化接口</li></ul></li></ul><h1 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h1><ul><li>卸载类是该类的Class对象被GC</li><li>满足的条件<ul><li>该类的所有实例对象都已被GC，堆中不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC：自定义加载器加载的类是可以被卸载掉的</li></ul></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader：<ul><li>BootstrapClassLoader( 启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</li><li>ExtensionClassLoader (扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</li><li>AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有jar包和类。</li></ul></li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><ul><li><strong>每一个类都有一个对应它的类加载器</strong> 。类加载的时候，会先判断这个类有没有被加载过。已经加载过的类直接返回，否则尝试加载。</li><li>加载的时候，会先委派该父类加载器的 loadClass 处理，因此所有请求都会到达顶层启动类加载器。当父类加载器无法处理时，才由自己来处理。</li><li>父类加载器为 null 时，由启动类加载器来处理。</li></ul><h2 id="双亲委派的好处"><a href="#双亲委派的好处" class="headerlink" title="双亲委派的好处"></a>双亲委派的好处</h2><ul><li>保证了 Java 程序的稳定运行，可以避免类的重复加载，也<strong>保证了 Java 的核心 API 不被篡改</strong>。</li><li>假设每个类加载器加载自己的话，就会出现我自定义一个 java.lang.Object 类的话，运行程序的时候，就有多个 Object 类了。</li></ul><h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><p>自定义加载器的话，需要继承 ClassLoader 。</p><ul><li>如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</li><li>如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的访问定位</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>java 程序通过栈上的 reference 数据来操作堆上的具体对象</p><p>对象的访问方式2种：<strong>使用句柄，直接指针</strong></p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><ul><li>如果使用句柄的话，那么java 堆中将会划分出一块内存来作为句柄池， reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据 与 类型数据各自的具体地址信息；</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270729163.png" alt="1610270729163"></p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><ul><li>如果使用直接指针访问，那么 java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 refrence 中存储的直接就是对象的地址</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270744133.png" alt="1610270744133"></p><blockquote><ul><li><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，他节约了一次指针定位的时间开销。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的内存布局</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><blockquote><p>对象的内存布局分为3块区域：<strong>对象头、实例数据</strong>和<strong>对齐填充</strong></p></blockquote><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><ul><li>包含两部分信息：第一部分专用于存储对象自身的运行时数据（hash码、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><ul><li>实例数据部分是对象真正存储的有效信息，也就是程序中定义的各种类型的字段内容。</li></ul><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><ul><li>不是必然存在，仅仅起占位作用。</li><li>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整倍数，换句话说就是对象的大小必须是8字节的整倍数。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的过程</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><ul><li>虚拟机遇到new指令时，首先去检查常量池中有没有这个类的符号应用，并且检查这个符号引用代表的类是否已被<strong>加载、验证、准备、解析、初始化</strong>过。如果没有，那么必须先执行相应的类的加载过程。</li></ul><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><ul><li>为新生对象分配内存，在类加载完成后就可以确定对象所需内存大小，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配的方式有”指针碰撞”和”空闲列表”，选择哪种方式由java堆是否规整决定，而java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定</li></ul><h3 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ul><li>适用于内存规整（没有内存碎片）</li><li>原理：用过的内存全部整理到一边，没有用过的内存放到另外一边，只要从没有用过的内存方向移动指定对象内存大小的位置即可。</li><li>GC收集器： Serial ， ParNew</li></ul><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ul><li>适用于堆内存不规整的情况下</li><li>原理：虚拟机会维护一个列表，该列表中记录哪些内存是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录</li><li>GC 收集器：CMS</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h3><ul><li>CAS + 失败重试：CAS 是一种乐观锁的实现方式。所谓乐观锁就是：每次不加锁而是假设没有冲突去完成某项操作，因为如果冲突失败就重试，直到成功为止。虚拟机采用CAS失败重试的方式保证更新操作的原子性</li><li>TLAB（Thread Local Allocation Buffer）：为每一个线程先在伊甸区分配一块内存，JVM 在给线程中对象分配内存时，首先在 TLAB 分配，当对象大于TLAB分配中的剩余内存或TLAB的内存用尽时，在采用CAS进行内存分配。</li></ul><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><ul><li>内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化零值</strong>（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段数据类型所对应的零值。</li></ul><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><ul><li>初始化零值完成之后，虚拟机需要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到<strong>类的元数据</strong>信息、对象的<strong>哈希码</strong>、对象的 <strong>GC</strong> 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如<strong>是否启用偏向锁</strong>等，对象头会有不同的设置方式。</li></ul><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><ul><li>从虚拟机的视角来看，一个新的对象已经产生了，但从java程序的视角来看，对象创建才刚开始，<code>&lt;init&gt; </code> 方法还没有执行，所有字段都还为零。所以一般来说，执行完 new 指令后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm体系结构</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​        JVM 是可运行 Java 代码的假想计算，包括<strong>一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域</strong>。 JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>完整内存模型图见：<a href="https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764">https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764</a></p><p><img src="/2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1610267566650.png" alt="1610267566650"></p><ul><li>JVM 内存区域主要分为：线程私有区域【<strong>程序计数器、虚拟机栈、本地方法区</strong>】、线程共享区域【 <strong>JAVA 堆、方法区</strong>】、直接内存。</li></ul><ul><li>线程私有区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)。</li></ul><ul><li>线程区域随虚拟机的启动/关闭而创建/销毁。</li></ul><ul><li>直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用：在 JDK1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。</li></ul><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><ul><li>字节码解释器从程序计数器中取出指令，实现对流程的控制</li></ul><ul><li><p><strong>在线程切换的过程中，保存当前线程的执行位置，以便在线程恢复执行的时候找到正确的执行位置</strong></p></li><li><p>唯一一个不会发生 OutOfMemoryError 的区域。</p></li></ul><h3 id="Java虚拟机栈（线程私有）"><a href="#Java虚拟机栈（线程私有）" class="headerlink" title="Java虚拟机栈（线程私有）"></a>Java虚拟机栈（线程私有）</h3><ul><li>由一组栈帧组成，栈帧用来保存<strong>局部变量、操作数栈、动态链接、方法出口</strong>等信息，栈帧随着方法调用而创建，随着方法结束而销毁—-无论方法是正常完成还是异常完成（抛出了在方法内未捕获的异常）都算方法结束。</li><li>局部变量表主要存放了编译期可知的各种<strong>数据类型</strong>（boolean,byte,char,short,int,float,long,double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的应用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li><li>StackOverFlowError：若 java 虚拟机的内存大小不动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li>OutOfMemory：若 java 虚拟机堆中没有空闲内存，并且垃圾收集器也无法提供更多的内存。就会抛出 OutOfMemoryError 错误。</li><li>每一次函数的调用就是对应栈帧的一次入栈到出栈的过程。</li></ul><h3 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h3><ul><li>使用到的是本地方法服务。</li><li>HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>线程私有区域，他的生命周期随着线程的创建而开始，随着线程的消亡而结束。</li></ul><h3 id="堆（-Heap-线程共享-）-运行时数据区"><a href="#堆（-Heap-线程共享-）-运行时数据区" class="headerlink" title="堆（ Heap-线程共享 ）-运行时数据区"></a>堆（ Heap-线程共享 ）-运行时数据区</h3><ul><li><p>目的是存放对象实例，几乎所有的对象实例和数组都在这里分配内存</p></li><li><p>随着JTI编译器的发展和逃逸分析技术的成熟，栈上分配、变量替换优化技术，使得所有对象在堆上的分配变得不那么绝对。<strong>如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存</strong>。</p></li><li><p>堆是垃圾收集器管理的主要区域，因此才被称为GC堆，现在垃圾收集器都是采用<strong>分代收集算法</strong>。Java堆细分：新生代和老年代，在细致一点的话就是：伊甸区，from区，to区。划分的目的是更好的回收内存，或者更快的分配内存。</p></li></ul><h3 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h3><ul><li>用于存放已被虚拟机加载的类信息，常量，静态变量，即时编译器后的代码数据。</li><li>java虚拟机规范把方法区描述为堆的一个逻辑部分，Non-Heap（非堆）</li><li>永久代就是HotsSpot虚拟机堆虚拟机规范方法区中的一种实现方式。也就是说，永久代是HotSpot的概念，方法区是java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。</li><li>-XX:PermSize=N  //方法区（永久代）初始大小</li><li>-XX:MaxPermSizze=N  //方法区（永久代）最大大小，超过这个值就会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError:PermGen</li></ul><h2 id="为什么元区间取代了永久代"><a href="#为什么元区间取代了永久代" class="headerlink" title="为什么元区间取代了永久代"></a>为什么元区间取代了永久代</h2><ul><li>永久代在 JVM 中受到 JVM 本身固定大小的限制，无法进行调整。</li><li>元空间使用的是直接内存，受本机可用内存的限制</li><li>元空间内存溢出：java.lang.OutOfMemoryError:MetaSpace</li><li>-XX:MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited ,这意味着他只受系统内存的限制</li><li>元空间里面存在的是元数据，这样加载多个类的元数据就不由 MaxPermSize 控制，而是由系统的实际可用空间来控制，这样能加载更多的类</li><li>在 JDK8 中，合并 HotSpot 和 Jrockit 的代码时，Jrockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了</li></ul><h2 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h2><ul><li>java7之前，运行时常量池包含字符串常量池。</li><li>java7，运行时常量池在永久代，字符串常量池在堆中。</li><li>java8，运行时常量池在元空间，字符串常量池在堆中。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul><li>本机的内存</li><li>JDK1.4 之后的 NIO ，引入了一种基于通道与缓存区的 I/O 方式，可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的应用操作，这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象死亡判断</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="对象死亡判断"><a href="#对象死亡判断" class="headerlink" title="对象死亡判断"></a>对象死亡判断</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的</p><blockquote><p>​    难以解决对象间的循环引用。除了对象 objA和objB相互引用这对方外，这两个对象之间再无任何引用。但是他们因为相互引用对方，导致他们的应用计数器都不为0，于是引用计数算法无法通知GC回收器回收他们。</p></blockquote></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始想下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li></ul><h4 id="可作为-GC-Roots-的对包括下面几种："><a href="#可作为-GC-Roots-的对包括下面几种：" class="headerlink" title="可作为 GC Roots 的对包括下面几种："></a>可作为 GC Roots 的对包括下面几种：</h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方发展（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>判定对象的存活与 “引用” 有关。</li><li>强引用（StrongReference）<ul><li>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。必不可少，垃圾收集器绝对不会回收他。当空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，是程序异常终止</li></ul></li><li>软引用<ul><li>如果一个对象具有软引用，可有可无，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</li></ul></li><li>弱引用<ul><li>可有可无，只具有弱引用的对象拥有更短暂的生命周期。在垃圾收集器线程扫描他所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></li><li>虚引用<ul><li>形同虚设。如果一个对象仅持有引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li></ul></li></ul><h2 id="不可达的对象并非-“不死不可”"><a href="#不可达的对象并非-“不死不可”" class="headerlink" title="不可达的对象并非 “不死不可”"></a>不可达的对象并非 “不死不可”</h2><ul><li>即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑阶段”，要真正宣告一个对象死亡，至少需要经历<strong>两次标记</strong>过程；可达性分析算法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法， 或 finalize 方法已经被虚拟机调用过时， 虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行二次标记，除非这个对象与应用链上的任何一个对象关联，否则真的会被回收。</li></ul><h2 id="如何判断一个常量是废弃的常量？"><a href="#如何判断一个常量是废弃的常量？" class="headerlink" title="如何判断一个常量是废弃的常量？"></a>如何判断一个常量是废弃的常量？</h2><ul><li>运行时常量池</li><li>加入在常量池中存在字符串 “abc” ， 如果当前没有任何 String 对象引用该字符串的话， 就说明常量 “abc” 就是废弃常量，如果这是发生内存回收的话而且有必要的话， “abc” 就会被系统清理出常量池。</li></ul><h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><ul><li>方法区主要回收的是无用的类</li><li>可以被回收<ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透与雪崩</title>
      <link href="2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/"/>
      <url>2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存穿透与雪崩"><a href="#缓存穿透与雪崩" class="headerlink" title="缓存穿透与雪崩"></a>缓存穿透与雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>在默认情况下，用户请求数据时，会先在缓存（Redis）中查找，若没找到即缓存为命中，再在数据库中查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景），缓存没有命中的话，就会将请求全部转移到数据库上，造成数据库的压力剧增，就有可能导致数据库的崩溃。</p><p>网络安全中的也有人恶意使用这种手段进行攻击称为洪水攻击</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="布隆过滤器："><a href="#布隆过滤器：" class="headerlink" title="布隆过滤器："></a>布隆过滤器：</h4><p>对所有可能查询的参数以hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截，检验不通过则直接打回，减轻了存储系统的压力</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072357498.png" alt="1609072357498"></p><h4 id="缓存空对象（查询不到）"><a href="#缓存空对象（查询不到）" class="headerlink" title="缓存空对象（查询不到）"></a>缓存空对象（查询不到）</h4><p>一次查询若在缓存与数据库中都没有查询到，就在缓存中放一个空对象用于处理后续这个请求</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072445647.png" alt="1609072445647"></p><p>这样做有一个缺陷：储存空对象也需要空间，大量空对象会消耗一定的空间，储存效率并不高。解决这个缺陷的方式就是 <strong>设置较短的过期时间</strong>。即使对空置设置了过期时间，还是会存在缓存层和储存层的数据会有一段时间的不一致，这对于需要保持一致性的业务会有影响。</p><h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时的 DB 请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个 key 的缓存不可用而导致的击穿，但是其他的 key 仍然可以使用缓存响应。</p></blockquote><p>比如热搜排行榜，一个热点新闻同时被大量访问就可能导致缓存击穿。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候，也会清理部分书，而且此种方案会暂占用空间，一旦热点数据多了起来，久会占用大量空间</p><h4 id="加互斥锁（分布式锁）"><a href="#加互斥锁（分布式锁）" class="headerlink" title="加互斥锁（分布式锁）"></a>加互斥锁（分布式锁）</h4><p>在访问 key 之前，采用 setnx （set  if  not exists）来设置另一个短期 key 来锁住当前 key 的访问，访问结束再删除改短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>大量的 key 设置了相同的过期时间，导致在缓存在同一时刻的 key 全部消失，造成瞬时 DB 请求量大、压力骤增、引起雪崩。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><p>这个思想的含义是：既然redis有可能挂掉，那就多增加几台 redis , 这样一台挂掉之后其他还可以继续工作，其实就是<strong>搭建集群</strong></p><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><p>在缓存失效后，通过加锁或者队列来控制读数据库写幻想村的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>数据预热的含义就是在正式部署之前，我先把可能的 数据先预先访问一遍，这样部门可能大量访问的数据久会加载到内存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台redis服务的数据，复制到其他的 redis 服务器。前者称为主节点（Master/Leader），后者称为从节点（Slave/Follower），数据的复制是单向的，只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台 Redis 服务器都是主节点，一个主节点可以有 0 个或者多个从节点，但是每个从节点只能有一个主节点。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式。</li><li>负载均衡：在主从复制的基础上，配合读写分离，有主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的情境下，通过多个从节点分担负载，提供并发量。</li><li>高可用基石：主从复制还是哨兵和集群能都实施的基础。</li></ol><h2 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h2><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限</li></ol><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我们在讲解配置文件的时候，注意到有一个 replication 模块（间 redis.conf 中第8条）</p><p>查看当前库的信息： info replication</p><p>// TODO</p><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改一下信息：</p><ul><li>端口号</li><li>pid 文件名</li><li>日志文件名 </li><li>rdb 文件名</li></ul><p>启动单机多服务集群：</p><p>// TODO</p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p><strong>默认情况下，每台 Redis 服务器都是主节点； 我们一般情况下只用配置从机就好了！</strong></p><p>使用 SALVEOF host port 就可以为从机配置主机了。</p><p>// TODO</p><p>然后主机上也能看到从机的状态</p><p>// TODO</p><p>我们这里使用命令搭建，是暂时的，真实开发中应该在从机配置文件中进行过配置，这样的话就是永久的。</p><p>// TODO</p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li>从机只读，不能写，主机可读可写但是多用于写。// TODO</li><li>当主机断点宕机后，默认情况下从机的角色不会发生变化，集群中只是丢失了写操作，当主机恢复以后，又会连上从机恢复原状。</li><li>当从机宕机后，若不是使用配置的配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若次吃重新配置称为从机，又可以获取到主机的所有数据。这里就是提到一个同步原理。</li><li>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：<ul><li>​    从机手动执行命令 slaveof  no  one，这样执行以后从机独立出来称为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动？</p></blockquote><p>如果主机断开了连接，我们可以使用 slaveof no one 让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大恢复了，那么就重新连接！</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>主从切换技术的方法是：<strong>当主机宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用</strong>。这不是一种推荐的方式，更多的时候，我们优先考虑哨兵模式。</p><h3 id="单机单个哨兵"><a href="#单机单个哨兵" class="headerlink" title="单机单个哨兵"></a>单机单个哨兵</h3><ul><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵检测到 master 宕机，会自动将 slave 切换成 master ， 然后通过 <strong>发布订阅模式</strong> 通知其他从服务器，修改配置文件，让它们切换成主机。</li></ul><h3 id="多哨兵模式"><a href="#多哨兵模式" class="headerlink" title="多哨兵模式"></a>多哨兵模式</h3><p>哨兵的核心配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>数字1表示：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p>// TOOD</p><p>此时哨兵模式监视着我们的主机6379，当我们断开主机后：</p><p>// TOOD</p><h3 id="哨兵的优缺点"><a href="#哨兵的优缺点" class="headerlink" title="哨兵的优缺点"></a>哨兵的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>哨兵集群，基于主从复制模式，所有的主从复制的有点，他都有</li><li>主从可以切换，故障可以转移，系统的可用性好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Redis 不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><h3 id="完整的哨兵模式配置文件-sentinel-conf"><a href="#完整的哨兵模式配置文件-sentinel-conf" class="headerlink" title="完整的哨兵模式配置文件 sentinel.conf"></a>完整的哨兵模式配置文件 sentinel.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h2 id="redis-红锁（redlock）"><a href="#redis-红锁（redlock）" class="headerlink" title="redis 红锁（redlock）"></a>redis 红锁（redlock）</h2><p>关于分布式锁，一般有三种选择，</p><ol><li><p>redis </p></li><li><p>zk</p></li><li><p>DB锁（悲观锁、乐观锁）</p><p>其中用的最多的应该是redis。</p></li></ol><p>redis常用的方式有单节点、主从模式、哨兵模式、集群模式。</p><p>单节点在生产环境基本上不会使用，因为不能达到高可用，且连RDB或AOF备份都只能放在master上，所以基本上不会使用。</p><p>另外几种模式都无法避免两个问题：</p><ol><li>异步数据丢失。</li><li>脑裂问题。</li></ol><p>所以redis官方针对这种情况提出了红锁（<strong>Redlock</strong>）的概念。</p><p>假设有5个redis节点，这些节点之间既没有主从，也没有集群关系。客户端用相同的key和随机值在5个节点上请求锁，请求锁的超时时间应小于锁自动释放时间。当在3个（超过半数）redis上请求到锁的时候，才算是真正获取到了锁。如果没有获取到锁，则把部分已锁的redis释放掉。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis发布订阅模式</title>
      <link href="2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis发布订阅模式"><a href="#Redis发布订阅模式" class="headerlink" title="Redis发布订阅模式"></a>Redis发布订阅模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Redis发布订阅（pub/sub）是一种消息通信模式：发布者（pub）,发送消息，订阅者（sub）接收消息。</p><ul><li>下图展示了频道 channel1，以及订阅这个频道的三个客户端–client1、client2和client3之间的关系：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287271460.png" alt="1609287271460"></p><ul><li>当有新的消息通过PUBLISH命令发送给频道 channel1 时，这个消息就会被发送给订阅他的三个客户端：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287501584.png" alt="1609287501584"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>// TODO</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个 redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer结构，结构的 pubsub_channels 属性是一个字典，这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287992211.png" alt="1609287992211"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度确不够快的话，那么不断积压消息会使 redis 输出缓冲区的体积变得越来越大，这可能使得 redis 本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短期时间发布者发布的消息。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>消息订阅：公众号订阅，微博关注等等（其实更多的是消息队列来进行实现）</li><li>多人在线聊天室</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ来处理。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事务</title>
      <link href="2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis 事务本质：一组命令的集合。</p><p>事务中每条命令都会被序列化，执行过程中按照顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>循序性</li><li>排他性</li></ul><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性</li></ol></blockquote><p>Redis 事务操作过程</p><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ul><p>所有事务中的命令在加入时没有被执行，直到提交时才会开始执行（Exec）一次性完成</p><p>取消事务(discurd)</p><p>事务错误</p><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><blockquote><p>代码逻辑国务（运行时异常） <strong>其他命令能正常执行，所以不保证事务的原子性</strong></p></blockquote><p>监控</p><p>悲观锁：</p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p>乐观锁：</p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用 watch key 监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于 getversion）</p></blockquote><p>我们启动另外一个客户端模拟插入线程。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="一、持久化——-RDB"><a href="#一、持久化——-RDB" class="headerlink" title="一、持久化—— RDB"></a>一、持久化—— RDB</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><ul><li><p>在指定时间间隔后，将内存中的数据快照写入硬盘，在恢复的时候，直接读取快照文件，进行数据的恢复。</p></li><li><p>默认情况下，redis将数据库快照保证在名字为 dump.rdb 的二进制文件中。文件名可以在配置文件中进行自定义。</p></li></ul><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>在进行rdb的时候，redis主线程是不会做io操作的，主线程会 fork 一个子线程来完成该操作：</p><ol><li>Redis 调用 fork 。 同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中</li><li>当子进程完成对新 RDB 文件写入时， Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件</li></ol><p>这种工作方式使得Redis 可以从写时复制（copy-on-write） 机制中获益（因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求）</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ol><li>save 的规则满足的情况下， 会自动触发 rdb原则</li><li>执行 flushall 命令也会触发我们的 rdb 原则</li><li>退出 redis 也会自动产生 rdb 文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 save 命令， 会立刻对当前内存中的数据进行持久化， 但是会阻塞， 也就是不接受其他操作了</p><blockquote><p>由于 save 命令是同步命令， 会占用 Redis 的主进程。 若Redis 数据非常多时， save 命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><h4 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h4><p>flushall 命令也会触发持久化</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件：</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在 “N 秒内数据集至少有 M 个改动” 这一条件满足时， 会自动进行数据集保存操作。</p></blockquote><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 是异步进行， 进行持久化的时候， redis 还可以将继续响应客户端请求</p><p>bgsave 和 save 对比</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了</li><li>fork 进程的时候， 会占用一定的内存空间</li></ol><h2 id="二、持久化——-AOF"><a href="#二、持久化——-AOF" class="headerlink" title="二、持久化—— AOF"></a>二、持久化—— AOF</h2><p>Append Only File</p><p>将我们所有的命令都记录下来， history 恢复的时候就把这个文件全部再执行一遍</p><blockquote><p>以日志的形式来记录每个写操作，将redis执行的指令记录下来（读操作不记录），只需追加文件但不可以修改文件，redis 启动之初会读取改文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>快照功能（RDB) 并不是非常耐久：如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入，以及未保存到快照中的那些数据，从1.1版本开始，Redis增加了一种完全耐久的持久方式：AOF持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/1609059576333.png" alt="1609059576333"></p><blockquote><p> appendonly  yes 则表示启动AOF</p><p>appendfilename “appendonly.aof”  表示保存的文件名为 “appendonly.aof”</p><p>appendfsync  everysec  每秒同步一次</p></blockquote><p>appendonly 默认是no  不开启的，我们需要手动配置，然后重启redis，就可以生效</p><p>如果这个aof文件有错误，这时候 redis 是启动不起来的，我们需要修改这个aof文件</p><p>redis给我们提供了一个工具， redis-check-aof –fix</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>每一次修改都会同步，文件的完整性会更加的好</li><li>每秒同步一次，可能会丢失最后一秒的数据</li><li>从不同步，效率最高</li></ul><p>缺点</p><ul><li>相对于数据文件来说，aof远远大于rdb，修复速度比 rdb 慢！</li><li>aof 运行效率也比 rdb 慢，所以我们 redis 默认的配置就是 rdb 持久化</li></ul><p>RDB与AOF的选择</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><p>如何选择使用哪种持久化方式？</p><ul><li><p>一般来说，如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p></li><li><p>如果你非常关心你的数据，但仍然可以承受部分数据数分钟以内的丢失，那么你可以选择只使用RDB 持久化</p></li><li><p>有很多用户都只是用AOF持久化，但并不推荐这种持久化方式：因为定时生成的AOF快照非常便于数据备份，并且RDB恢复数据集的速度也要比 AOF 恢复的速度快</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>5中基本使用类型及使用场景</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis配置</title>
      <link href="2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/"/>
      <url>2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><blockquote><p>容量单位不区分大小写，G和GB有区别</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061040941.png" alt="1609061040941"></p><h2 id="其他配置文件设置"><a href="#其他配置文件设置" class="headerlink" title="其他配置文件设置"></a>其他配置文件设置</h2><blockquote><p>可以设置多个配置文件组合使用</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061174389.png" alt="1609061174389"></p><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><blockquote><p>bind 127.0.0.1  # IP绑定</p><p>protected-mode yes    # 保护模式，默认开启</p><p>port 6379    # 端口号，默认6379</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061264732.png" alt="1609061264732"></p><h2 id="日志输出级别"><a href="#日志输出级别" class="headerlink" title="日志输出级别"></a>日志输出级别</h2><blockquote><p>loglevel notice    # 日志级别设置。（有debug,verbose,notice,waring四种级别）</p><p>logfile    “” # 日志文件名称</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061433425.png" alt="1609061433425"></p><h2 id="持久化（RDB，SNAPSHOTTING）"><a href="#持久化（RDB，SNAPSHOTTING）" class="headerlink" title="持久化（RDB，SNAPSHOTTING）"></a>持久化（RDB，SNAPSHOTTING）</h2><blockquote><ul><li>持久化规则，持久化文件 .rdb  .aof文件中</li></ul><p>save 900 1 # 如果900秒内， 至少1个key进行了修改，就进行持久化</p><p>save 300 10    # 300 秒内， 10个 key 进行了修改，则进行持久化</p><p>save 60 10000    # 60秒内， 10000个 key  进行了修改，则进行持久化</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061586443.png" alt="1609061586443"></p><blockquote><p> stop-writes-on-bgsave-error yes    # 持久化错误继续工作</p><p> rdbcompression yes    # 压缩 .rdb 文件</p><p>rdbchecksum yes    # 检验 rdb文件</p><p>dbfilename dump.rdb    # 保存文件名称为 dump.rdb</p><p>dir ./    # rdb 文件保存的目录</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609061879993.png" alt="1609061879993"></p><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062044223.png" alt="1609062044223"></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062119419.png" alt="1609062119419"></p><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><blockquote><p>requirepass foobared # 密码设置</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062373660.png" alt="1609062373660"></p><h2 id="客户端连接设置"><a href="#客户端连接设置" class="headerlink" title="客户端连接设置"></a>客户端连接设置</h2><blockquote><p>maxclients 10000  最大客户端数量<br>maxmemory <bytes> 最大内存限制<br>maxmemory-policy noeviction </bytes></p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062480854.png" alt="1609062480854"></p><h2 id="过期策略配置"><a href="#过期策略配置" class="headerlink" title="过期策略配置"></a>过期策略配置</h2><blockquote><p>有八种过期策略配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 只对设置了过期时间的key进行lru</span><br><span class="line">volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line"># 删除lru算法的key</span><br><span class="line">allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># 只对设置了过期时间的key进行lfu</span><br><span class="line">volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="line"># 删除lfu算法的key</span><br><span class="line">allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># 随机删除即将过期key</span><br><span class="line">volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="line"># 随机删除</span><br><span class="line">allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># 删除即将过期的</span><br><span class="line">volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># 永不过期，返回错误</span><br><span class="line">noeviction -&gt; Don&#39;t evict anything, just return an error on write operations</span><br></pre></td></tr></table></figure><p>默认过期策略是：noeviction</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062738767.png" alt="1609062738767"></p><h2 id="持久化（AOF）"><a href="#持久化（AOF）" class="headerlink" title="持久化（AOF）"></a>持久化（AOF）</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;appendonly no# 默认不开启 AOF </span><br><span class="line">&gt;appendfilename &quot;appendonly.aof&quot;# 默认文件名</span><br><span class="line"></span><br><span class="line">&gt;appendfsync always# 每次修改进行同步</span><br><span class="line">&gt;appendfsync everysec# 每秒执行一次同步</span><br><span class="line">&gt;appendfsync no# 不进行同步， 由操作系统进行同步，速度最快</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609062990992.png" alt="1609062990992"></p><p><img src="/2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/1609063021674.png" alt="1609063021674"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中concorrentHashMap源码解析</title>
      <link href="2020/01/04/java/map/java-map-jdk8-concorrentHashMap/"/>
      <url>2020/01/04/java/map/java-map-jdk8-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中concorrentHashMap源码解析"><a href="#JDK8中concorrentHashMap源码解析" class="headerlink" title="JDK8中concorrentHashMap源码解析"></a>JDK8中concorrentHashMap源码解析</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中concorrentHashMap源码解析</title>
      <link href="2020/01/04/java/map/java-map-jdk7-concorrentHashMap/"/>
      <url>2020/01/04/java/map/java-map-jdk7-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中concorrentHashMap源码解析"><a href="#JDK7中concorrentHashMap源码解析" class="headerlink" title="JDK7中concorrentHashMap源码解析"></a>JDK7中concorrentHashMap源码解析</h1><h1 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h1><p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h1 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h1><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default initial capacity for this table,</span></span><br><span class="line"><span class="comment">    * used when not otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认的数组大小16(HashMap里的那个数组)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default load factor for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 扩容因子0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default concurrency level for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认并发标准16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The minimum capacity for per-segment tables.  Must be a power</span></span><br><span class="line"><span class="comment">    * of two, at least two to avoid immediate resizing on next use</span></span><br><span class="line"><span class="comment">    * after lazy construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 每段表的最小容量。必须为2的幂，至少为2的幂，以免在延迟构造后立即调整下次使用时的大小。*/</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// ConcurrentHashMap中的数组</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">    * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">    * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 段是哈希表的专用版本。该子类是ReentrantLock的机会子类，只是为了简化一些锁定并避免单独构造。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">        * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/* 每个细分表。元素通过提供可变语义的entryAtsetEntryAt访问。 */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment">        * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The total number of mutative operations in this segment.</span></span><br><span class="line"><span class="comment">        * Even though this may overflows 32 bits, it provides</span></span><br><span class="line"><span class="comment">        * sufficient accuracy for stability checks in CHM isEmpty()</span></span><br><span class="line"><span class="comment">        * and size() methods.  Accessed only either within locks or</span></span><br><span class="line"><span class="comment">        * among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table is rehashed when its size exceeds this threshold.</span></span><br><span class="line"><span class="comment">        * (The value of this field is always &lt;tt&gt;(int)(capacity *</span></span><br><span class="line"><span class="comment">        * loadFactor)&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The load factor for the hash table.  Even though this value</span></span><br><span class="line"><span class="comment">        * is same for all segments, it is replicated to avoid needing</span></span><br><span class="line"><span class="comment">        * links to outer object.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">       Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">           <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">           <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">           <span class="keyword">this</span>.table = tab;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">    * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* ConcurrentHashMap列表条目。请注意，它永远不会作为用户可见的Map.Entry导出。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;</span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造**默认值是 16。</li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>。</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15。</li><li><strong>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 20.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap()"></a>ConcurrentHashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">    * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用默认的初始容量（16），</span></span><br><span class="line"><span class="comment">   * 负载因子（0.75）和concurrencyLevel（16）创建一个新的空映射。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity"><a href="#ConcurrentHashMap-int-initialCapacity" class="headerlink" title="ConcurrentHashMap(int initialCapacity)"></a>ConcurrentHashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity,</span></span><br><span class="line"><span class="comment">    * and with default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 创建一个具有指定初始容量，默认负载因子（0.75）和concurrencyLevel（16）的新的空映射。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果元素的初始容量为负，则IllegalArgumentException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity</span></span><br><span class="line"><span class="comment">    * and load factor and with the default concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量和负载因子以及默认的concurrencyLevel（16）创建一个新的空映射。 @param initialCapacity该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @throws IllegalArgumentException如果元素的初始容量为负或负载系数为非正值（从1.6开始）*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">    * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">    * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">    * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">    * nonpositive.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量，负载因子和并发级别创建一个新的空映射。 @param initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @param concurrencyLevelLevel并发更新线程的估计数量。该实现执行内部大小调整以尝试容纳这么多线程。如果初始容量为负，或者负载系数或concurrencyLevel为非正值，则@throws IllegalArgumentException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 参数检验</span></span><br><span class="line">       <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂次方数（例如 concurrencyLevel=16，sshift 则为 4 ）</span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂数（例如 concurrencyLevel=16，ssize 则为 16）</span></span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">           ++sshift;</span><br><span class="line">           <span class="comment">// ssize 右移两位 即 ssize = ssize * 2</span></span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 32 - 4 = 28 (段位移)</span></span><br><span class="line">       <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">       <span class="comment">// 16 - 1 = 15 （段 mask）</span></span><br><span class="line">       <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 计算 segment 段内最小的数组长度，2的幂次方倍</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">       <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">           ++c;</span><br><span class="line">       <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">       <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create segments and segments[0]</span></span><br><span class="line">       <span class="comment">// 创建 segments=Segment[ssize] 数组并初始化 segments[0]</span></span><br><span class="line">       Segment&lt;K,V&gt; s0 =</span><br><span class="line">           <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                            (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">       Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">       UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">       <span class="keyword">this</span>.segments = ss;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li><p>根据 initialCapacity, loadFactor, concurrencyLevel 创建 Segment 数组并初始化 Segment[0]</p></li><li><p>计算出段位移：this.segmentShift = 32 - sshift;</p></li><li><p>计算出段Mask :  this.segmentMask = ssize - 1;</p></li></ul></blockquote><h2 id="ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment">    * The map is created with a capacity of 1.5 times the number</span></span><br><span class="line"><span class="comment">    * of mappings in the given map or 16 (whichever is greater),</span></span><br><span class="line"><span class="comment">    * and a default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用与给定map相同的map创建一个新map。创建的映射的容量是给定映射中映射数量的1.5倍或16（最大），默认加载因子（0.75）和concurrencyLevel（16）。map中的@param m */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">            DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">       putAll(m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、put方法"><a href="#3、put方法" class="headerlink" title="3、put方法"></a>3、put方法</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment">    * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment">    * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** 将指定的键映射到此表中的指定值。键或值都不能为null。 &lt;p&gt;可以通过使用等于原始键的键调用&lt;tt&gt; get &lt;tt&gt;方法来检索该值。 <span class="doctag">@param</span>与指定值关联的键key @ param与指定键关联的值@返回与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值如果指定的键或值为null，则&lt;tt&gt; key &lt;tt&gt;没有映射<span class="doctag">@throws</span> NullPointerException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// value 值为空，直接抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 经过一系列的计算得出 key 的 hash 值 (为了更好的均匀散列表的下标)</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Segment[] 数组中下标所在的位置</span></span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="comment">// 如果 Segment[] 数组为空则创建一个 Segment&lt;&gt; 元素，若不为空则直接 put</span></span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ensureSegment-int-k"><a href="#ensureSegment-int-k" class="headerlink" title="ensureSegment(int k)"></a>ensureSegment(int k)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">    * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 返回给定索引的段，创建它并记录在段表中（通过CAS）（如果尚不存在）。 @param k索引 @返回 段 */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">       <span class="comment">// raw offset 原始偏移</span></span><br><span class="line">       <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">       Segment&lt;K,V&gt; seg;</span><br><span class="line">       <span class="comment">// 根据原始偏移获取指定段的值，如果为空</span></span><br><span class="line">       <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 复制一份和segment 0一样的segment （使用 segment0 作为原型）</span></span><br><span class="line">           Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">           <span class="keyword">int</span> cap = proto.table.length;<span class="comment">// 段数组大小</span></span><br><span class="line">           <span class="keyword">float</span> lf = proto.loadFactor;<span class="comment">// 加载因子</span></span><br><span class="line">           <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);<span class="comment">// 阈值</span></span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">           <span class="comment">// 再次根据原始偏移量获取指定段的值，如果为空</span></span><br><span class="line">           <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">               == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">               <span class="comment">// 根据已有属性创建段 Segment s</span></span><br><span class="line">               Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">               <span class="comment">// 再次根据原始偏移量获取指定段的值，为空则循环</span></span><br><span class="line">               <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                      == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 利用 cas 进行赋值</span></span><br><span class="line">                   <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> seg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li><p>如果指定段 segments[j] 为空，则复制 segments[0] 到指定段 segments[j]</p></li><li><p>UNSAFE.compareAndSwapObject 原子性操作保证线程安全 （利用了CAS）</p></li></ul></blockquote><h3 id="Segment-put"><a href="#Segment-put" class="headerlink" title="Segment.put()"></a>Segment.put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中hashMap源码解析</title>
      <link href="2020/01/04/java/map/java-map-jdk8-hashmap/"/>
      <url>2020/01/04/java/map/java-map-jdk8-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中hashMap源码解析"><a href="#JDK8中hashMap源码解析" class="headerlink" title="JDK8中hashMap源码解析"></a>JDK8中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>因为主要说的是1.8版本中的实现。而1.8中HashMap是数组+链表+红黑树实现的，大概如下图所示。后面还是主要介绍Hash Map中主要的一些成员以及方法原理。</p><p>那么上述图示中的结点Node具体类型是什么，源码如下。Node是HashMap的内部类，实现了Map.Entery接口，主要就是存放我们put方法所添加的元素。其中的next就表示这可以构成一个单向链表，这主要是通过链地址法解决发生hash冲突问题。而当桶中的元素个数超过阈值的时候就换转为红黑树。</p><h2 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">    * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基本哈希箱节点，用于大多数条目。 （请参阅下面的</span></span><br><span class="line"><span class="comment">    * TreeNode子类，以及LinkedHashMap中的Entry子类。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// hash桶中的结点Node,实现了Map.Entry</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;<span class="comment">// 链表的next指针</span></span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重写Object的hashCode</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// equals方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeNode-lt-k-v-gt"><a href="#TreeNode-lt-k-v-gt" class="headerlink" title="TreeNode&lt;**k**,**v**&gt;"></a><strong>TreeNode</strong>&lt;**k**,**v**&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;<span class="comment">//左子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;<span class="comment">//右子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;<span class="comment">// 颜色属性</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 返回当前节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2、HashMap中的成员变量以及含义"><a href="#2、HashMap中的成员变量以及含义" class="headerlink" title="2、HashMap中的成员变量以及含义"></a>2、HashMap中的成员变量以及含义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量初始化=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量 = 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认加载因子.一般HashMap的扩容的临界点是当前HashMap的大小 &gt; DEFAULT_LOAD_FACTOR * </span></span><br><span class="line"><span class="comment">//DEFAULT_INITIAL_CAPACITY = 0.75F * 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数大于该值的时候，会由链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数小于该值的时候，红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash算法,计算传入的key的hash值，下面会有例子说明这个计算的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。下面会有例子说明</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash桶</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存的entrySet</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶的实际元素个数 != table.length</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容或者更改了map的计数器。含义：表示这个HashMap结构被修改的次数，结构修改是那些改变HashMap中的映射数量或者</span></span><br><span class="line"><span class="comment">//修改其内部结构（例如，重新散列rehash）的修改。 该字段用于在HashMap失败快速（fast-fail）的Collection-views</span></span><br><span class="line"><span class="comment">//上创建迭代器。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临界值，当实际大小（cap*loadFactor）大于该值的时候，会进行扩充</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="3、HashMap构造方法"><a href="#3、HashMap构造方法" class="headerlink" title="3、HashMap构造方法"></a>3、HashMap构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量</span></span><br><span class="line"><span class="comment">    *（16）和默认的加载因子（0.75）构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;，它具有指定的初始*容量和默认负载因子（0.75）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。 </span></span><br><span class="line"><span class="comment"> * @如果初始容量为负，则抛出IllegalArgumentException。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用指定的初始*容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor负载系数</span></span><br><span class="line"><span class="comment">    * @如果初始容量为负*或负载系数为非正数，则抛出IllegalArgumentException </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的&lt;tt&gt; HashMap &lt;/ tt&gt;。 &lt;tt&gt; HashMap &lt;/ tt&gt;是使用默认负载因子（0.75）和足以将*映射保存在指定的&lt;tt&gt; Map &lt;/ tt&gt;中的初始容量创建的。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>要在其地图中放置其映射的地图*如果指定的地图为null，则抛出NullPointerException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">    * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.putAll和Map构造函数。映射时的</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>最初构造此映射时，返回<span class="doctag">@false</span>，否则为true（中继到afterNodeInsertion方法）。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//该函数将传递的map集合中的所有元素加入本map实例中</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果本map实例的table为null，没有初始化，那么需要初始化</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">               <span class="comment">// 实际大小：ft = m.size() / 0.75 + 1;</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">// 判断刚刚计算的大小是否小于最大值1&lt;&lt;&lt;30</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//计算的实际大小ft大于当前的阈值threshhold，那么将threshhold重新计算，tableSizeFor传递的</span></span><br><span class="line">           <span class="comment">//参数是计算的大小，即重新计算大于ft的最小二次幂</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果table!=null，并且m.size() &gt; threshhold，直接进行扩容处理</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">// 将map中的所有元素加入本map实例中</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、put-方法"><a href="#4、put-方法" class="headerlink" title="4、put 方法"></a>4、put 方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定值与该映射中的指定键相关联。</span></span><br><span class="line"><span class="comment">    * 如果该映射先前包含键的映射，则将替换旧</span></span><br><span class="line"><span class="comment">    * 值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>键与指定值关联的键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>值与指定键关联的值</span></span><br><span class="line"><span class="comment">    * @返回与&lt;tt&gt; key &lt;/ tt&gt;关联的先前值，或者</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt; null &lt;/ tt&gt;（如果没有&lt;tt&gt; key &lt;/ tt&gt;的映射）。</span></span><br><span class="line"><span class="comment">    * （返回&lt;tt&gt; null &lt;/ tt&gt;还可以表明该地图</span></span><br><span class="line"><span class="comment">    * 先前将&lt;tt&gt; null &lt;/ tt&gt;与&lt;tt&gt; key &lt;/ tt&gt;关联。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现Map.put和相关方法。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 哈希键的哈希值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 键的键</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 值的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> only如果为true，则不更改现有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 退出，如果为false，则表处于创建模式。 </span></span><br><span class="line"><span class="comment">   * @返回上一个值；如果没有，则返回null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//table == null 或者table的长度为0，调用resize方法进行扩容</span></span><br><span class="line"><span class="comment">//这里也说明：table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里就是调用了Hash算法的地方，具体的计算可参考后面写到的例子</span></span><br><span class="line"> <span class="comment">// 这里定位坐标的做法在上面也已经说到过</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 如果计算得到的桶下标值中的Node为null，就新建一个Node加入该位置(这个新的结点是在</span></span><br><span class="line">     <span class="comment">// table数组中)。而该位置的hash值就是调用hash()方法计算得到的key的hash值</span></span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//这里表示put的元素用自己key的hash值计算得到的下表和桶中的第一个位置元素产生了冲突，具体就是</span></span><br><span class="line"> <span class="comment">//(1)key相同，value不同</span></span><br><span class="line"> <span class="comment">//(2)只是通过hash值计算得到的下标相同，但是key和value都不同。这里处理的方法就是链表和红黑树</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//上面已经计算得到了该hash对应的下标i，这里p=tab[i]。这里比较的有：</span></span><br><span class="line">     <span class="comment">//(1)tab[i].hash是否等于传入的hash。这里的tab[i]就是桶中的第一个元素</span></span><br><span class="line">     <span class="comment">//(2)比较传入的key和该位置的key是否相同</span></span><br><span class="line">     <span class="comment">//(3)如果都相同，说明是同一个key，那么直接替换对应的value值(在后面会进行替换)</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">// 将桶中的第一个元素赋给e，用来记录第一个位置的值</span></span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             <span class="comment">// 这里判断为红黑树。hash值不相等，key不相等；为红黑树结点</span></span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//判断为链表结点</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//如果达到链表的尾部</span></span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 在尾部插入新的结点</span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 前面的binCount是记录链表长度的，如果该值大于8，就会转变为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//如果在遍历链表的时候，判断得出要插入的结点的key和链表中间的某个结点的key相</span></span><br><span class="line">             <span class="comment">//同，就跳出循环,后面也会更新旧的value值</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">//e = p.next。遍历链表所用</span></span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断插入的是否存在HashMap中，上面e被赋值，不为空，则说明存在，更新旧的键值对</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value; <span class="comment">// 用传入的参数value更新旧的value值</span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;<span class="comment">// 返回旧的value值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// modCount修改</span></span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 容量超出就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>​    可以看到主要逻辑在put方法中调用了putVal方法，传递的参数是调用了hash()方法计算key的hash值，主要逻辑在putVal中。可以结合注释熟悉这个方法的执行，我在这里大概总结一下这个方法的执行：</p><ol><li><p>首先 <strong>(tab = table) == null || (n = tab.length) == 0</strong>这一块判断hash桶是否为null，如果为null那么会调用resize方法扩容。后面我们会说到这个方法</p></li><li><p>定位元素在桶中的位置，具体就是通过<strong>key的hash值和hash桶的长度</strong>计算得到下标i，如果计算到的位置处没有元素(null)，那么就新建结点然后添加到该位置。</p></li><li><p>如果table[i]处不为null，已经有元素了，那么就表明产生hash冲突,这里可能是三种情况</p><p>①判断key是不是一样，如果key一样，那么就将新的值替换旧的值；</p><p>②如果不是因为key一样，那么需要判断当前该桶是不是已经转为了红黑树，是的话就构造一个TreeNode结点插入红黑树；</p><p>③不是红黑树，就使用链地址法处理冲突问题。这里主要就是遍历链表，如果在遍历过程中也找到了key一样的元素，那么久还是使用新值替换旧值。否则会遍历到链表结尾处，到这里就直接新添加一个Node结点插入链表，插入之后还需要判断是不是已将超过了转换为红黑树的阈值8，如果超过就会转为红黑树。</p></li><li><p>最后需要修改modCount的值。</p></li><li><p>判断插入后的size大小是不是超过了threshhold，如果超过需要进行扩容。</p></li></ol></blockquote><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化或加倍表大小。如果为null，则根据字段阈值中保持的初始容量目标分配。 </span></span><br><span class="line"><span class="comment">    * 否则，因为我们使用的是2的幂，所以每个bin中的</span></span><br><span class="line"><span class="comment">    * 元素必须保持相同的索引，或者在新表中以2的偏移量移动。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @返回 table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// oldTab 指向旧的 table 数组</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// oldTab 不为 null 的话，oldCap 为原 table 的长度，oldTab为null的话，oldCap为0</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">// 阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果数组的长度在扩容后小于最大容量 并且oldCap大于默认值16(这里的newCap也是在原来的</span></span><br><span class="line">       <span class="comment">// 长度上扩展两倍)</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           <span class="comment">// 这里的oldThr=tabSizeFor(initialCapacity),从上面的构造方法看出，如果不是调用的</span></span><br><span class="line">       <span class="comment">// 无参构造，那么threshhold肯定都会是经过tabSizeFor运算得到的2的整数次幂的,所以可以将</span></span><br><span class="line">       <span class="comment">// 其作为Node数组的长度(个人理解)</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="comment">// 这里说的是我们调用无参构造函数的时候(table == null,threshhold = 0)，新的容量等于默</span></span><br><span class="line">       <span class="comment">// 认的容量，并且threshhold也等于默认加载因子*默认初始化容量</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 计算新的resize上限</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//容量 * 加载因子</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       <span class="comment">//以新的容量作为长度，创建一个新的Node数组存放结点元素</span></span><br><span class="line">   <span class="comment">//当然，桶数组的初始化也是在这里完成的</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//原来的table不为null</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// 原table中下标j位置不为null</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//将原来的table[j]赋为null</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果该位置没有链表，即只有数组中的那个元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">// 通过新的容量计算在新的table数组中的下标：(n-1)&amp;hash</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">// 如果是红黑树结点，重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">//遍历链表，进行重新映射</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 原位置</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// loTail处为null，那么直接加到该位置</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// loTail为链表尾结点，添加到尾部</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 原位置+旧容量</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// hiTail处为null，就直接点添加到该位置</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// hiTail为链表尾结点，尾插法添加</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                   <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 旧链表迁移新链表,链表元素相对位置没有变化; </span></span><br><span class="line">                       <span class="comment">// 实际是对对象的内存地址进行操作 </span></span><br><span class="line">                           loTail.next = <span class="keyword">null</span>; <span class="comment">// 链表尾元素设置为null</span></span><br><span class="line">                           newTab[j] = loHead; <span class="comment">// 数组中位置为j的地方存放链表的head结点</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断当前oldTab长度是否为空，如果为空，则进行初始化桶数组，也就回答了<strong>无参构造函数初始化为什么没有对容量和阈值进行赋值</strong>，如果不为空，则进行位运算，左移一位，2倍运算扩容。</p><p>扩容，创建一个新容量的数组，遍历旧的数组： </p><ul><li>如果节点为空，直接赋值插入</li><li>如果节点为红黑树，则需要进行进行拆分操作（个人对红黑树还没有理解，所以先不说明）</li><li>如果为链表，根据hash算法进行重新计算下标，将链表进行拆分分组（相信看到这里基本上也知道链表拆分的大致过程了）</li></ul></blockquote><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode(int hash, Object key)"></a><strong>getNode</strong>(<strong>int</strong> hash, Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.get和相关方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">    * @返回节点，如果没有则返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">//计算存放在数组table中的位置.具体计算方法上面也已经介绍了</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//先查找是不是就是数组中的元素</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//该位置为红黑树根节点或者链表头结点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="comment">//如果first为红黑树结点，就在红黑树中遍历查找</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="comment">//不是树结点，就在链表中遍历查找</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中hashMap源码解析</title>
      <link href="2020/01/04/java/map/java-map-jdk7-hashmap/"/>
      <url>2020/01/04/java/map/java-map-jdk7-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中hashMap源码解析"><a href="#JDK7中hashMap源码解析" class="headerlink" title="JDK7中hashMap源码解析"></a>JDK7中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>hashMap底层数据结构是数组 + 单链表，对 key 计算 hashCode 散列到数组中， 相同的 hashCode 的 key 添加到同一个链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash标中的结点Node,实现了Map.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Entry构造器，需要key的hash，key，value和next指向的结点</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object的hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、HashMap-对象的属性"><a href="#2、HashMap-对象的属性" class="headerlink" title="2、HashMap 对象的属性"></a>2、HashMap 对象的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 默认初始容量-必须为2的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 最大容量，如果两个构造函数都使用参数隐式指定了更高的值，则使用该容量。必须是两个&lt;= 1 &lt;&lt; 30的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在构造函数中未指定时使用的负载系数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当表未膨胀时要共享的空表实例。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 该表，根据需要调整大小。长度必须始终为2的幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 此映射中包含的键-值映射数。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 下一个要调整大小的大小值（容量负载因子）。</span></span><br><span class="line"><span class="comment">// If table == EMPTY_TABLE then this is the initial capacity at which the</span></span><br><span class="line"><span class="comment">// table will be created when inflated.</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 哈希表的负载因子。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 对该HashMap进行结构修改的次数结构修改是指更改HashMap中的映射次数或以其他方式修改其内部结构（例如重新哈希）的修改。此字段用于使HashMap的Collection-view上的迭代器快速失败。 （请参见ConcurrentModificationException）。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default threshold of map capacity above which alternative hashing is</span></span><br><span class="line"><span class="comment"> * used for String keys. Alternative hashing reduces the incidence of</span></span><br><span class="line"><span class="comment"> * collisions due to weak hash code calculation for String keys.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * This value may be overridden by defining the system property</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> jdk.map.althashing.threshold&#125;. A property value of &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment"> * forces alternative hashing to be used at all times whereas</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> -1&#125; value ensures that alternative hashing is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 映射容量的默认阈值，高于该阈值时，字符串键将使用替代哈希。备用哈希可减少由于字符串键的哈希码计算能力较弱而导致的冲突发生率。 &lt;p&gt;可以通过定义系统属性&#123;@code jdk.map.althashing.threshold&#125;来覆盖此值。属性值&#123;@code 1&#125;强制始终使用替代哈希，而&#123;@code -1&#125;值确保从不使用替代哈希。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure><h1 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;，它具有默认的初始容量（16）和默认的负载系数（0.75）。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//使用指定的初始容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;。 @param initialCapacity初始容量@param loadFactor负载系数@throws IllegalArgumentException如果初始容量为负或负载系数为非正</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">       inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">       putAllForCreate(m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="4、put方法"><a href="#4、put方法" class="headerlink" title="4、put方法"></a>4、put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 将指定值与该映射中的指定键相关联。如果该映射先前包含该键的映射，则将替换旧值。 </span></span><br><span class="line"><span class="comment">// @param 与指定值关联的键key </span></span><br><span class="line"><span class="comment">// @param 与指定键关联的值</span></span><br><span class="line"><span class="comment">// @return 与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值&lt;tt&gt; key &lt;tt&gt;没有映射。 （返回&lt;tt&gt; null &lt;tt&gt;也可以表明该映射先前将&lt;tt&gt; null &lt;tt&gt;与&lt;tt&gt; key &lt;tt&gt;关联。）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次调用时，table是空的，进行初始化</span></span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 如果 key 值为空，则调用 putForNullKey 的方法</span></span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 计算 hash 值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Entry 数组数组中的位置，相当于对该数组取余。</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 遍历该位置上的链表</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 如果存在相同的 key 值， 则直接覆盖并返回旧值</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 没有找到，则添加该 entity</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="inflateTable-threshold"><a href="#inflateTable-threshold" class="headerlink" title="inflateTable(threshold)"></a>inflateTable(threshold)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inflates the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 填充表</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次初始化时调用</span></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="comment">// 找到 &gt;= 2 size的2的幂方数（ 例如：15 则是 16 , 17 则是 32）</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 计算阈值，16 * 0.75 = 12 （&gt;=size的2的幂方数 * 加载因子）</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putForNullKey-V-value"><a href="#putForNullKey-V-value" class="headerlink" title="putForNullKey(V value)"></a>putForNullKey(V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 空键的put方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 遍历下标是 0 的数组</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           <span class="comment">// 如果存在键值为 null ， 则覆盖原有的值，并且返回原始值 </span></span><br><span class="line">           <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 如果不存在，则添加元素节点</span></span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hash-Object-k"><a href="#hash-Object-k" class="headerlink" title="hash(Object k)"></a>hash(Object k)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">    * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">    * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">    * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">    * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检索对象哈希码，并将补充哈希函数应用于</span></span><br><span class="line"><span class="comment">    * 结果哈希，以防止质量差的哈希函数。 </span></span><br><span class="line"><span class="comment">    * 这很关键，因为HashMap使用2的幂的哈希表，否则</span></span><br><span class="line"><span class="comment">    * 哈希码的冲突在低位没有区别。注意：空键始终映射到哈希0，因此索引为0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       <span class="comment">// 此函数可确保在每个位位置仅相差</span></span><br><span class="line">       <span class="comment">// 恒定倍数的hashCode具有有限的冲突次数（默认负载因子为约8）。</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="indexFor-int-h-int-length"><a href="#indexFor-int-h-int-length" class="headerlink" title="indexFor(int h, int length)"></a>indexFor(int h, int length)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回哈希码h的索引。</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// hashCode 逻辑与(length-1)   所以要长度必须为2的非零幂</span></span><br><span class="line">       <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="addEntry(int hash, K key, V value, int bucketIndex)"></a>addEntry(int hash, K key, V value, int bucketIndex)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment">    * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment">    * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     将具有指定键，值和哈希码的新条目添加到指定存储桶。如果有必要，此方法负责调整表的大小。 </span></span><br><span class="line"><span class="comment">  子类重写此方法以更改put方法的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 添加元素， bucketIndex 表示数组下标</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 元素个数大于阈值，并且数组元素不为空</span></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           <span class="comment">// 2倍扩容</span></span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 扩容后重新计算数组的下标值</span></span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建元素节点</span></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="resize-int-newCapacity"><a href="#resize-int-newCapacity" class="headerlink" title="resize(int newCapacity)"></a>resize(int newCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">    * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">    * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">    * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">    * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">    *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">    *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">    *        is irrelevant).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">/ ** </span><br><span class="line">* 将此映射的内容重新映射为</span><br><span class="line">* 具有更大容量的新数组。当此映射中的</span><br><span class="line">* 键数达到其阈值时，将自动调用此方法。 </span><br><span class="line">* </span><br><span class="line">   * 如果当前容量为MAXIMUM_CAPACITY，则此方法不会</span><br><span class="line">* 调整地图大小，而是将阈值设置为Integer.MAX_VALUE。 </span><br><span class="line">* 这样可以防止将来的通话。 </span><br><span class="line">* </span><br><span class="line">   * <span class="meta">@param</span> newCapacity新容量，必须是<span class="number">2</span>的幂； </span><br><span class="line">   * 必须大于当前容量，除非当前</span><br><span class="line">   * 容量为MAXIMUM_CAPACITY（在这种情况下，无关紧要）。</span><br><span class="line">   * /</span><br><span class="line">   <span class="comment">// 扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="comment">// 数组最大扩容到2的30次方</span></span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       <span class="comment">// 把旧数组的所有元素拷贝到新数组里</span></span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       <span class="comment">// 扩容后，重新计算阈值</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="transfer-Entry-newTable-boolean-rehash"><a href="#transfer-Entry-newTable-boolean-rehash" class="headerlink" title="transfer(Entry[] newTable, boolean rehash)"></a>transfer(Entry[] newTable, boolean rehash)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有条目从当前表传输到newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 重新计算新数组的下标位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">// 头插法</span></span><br><span class="line">               e.next = newTable[i];</span><br><span class="line">               newTable[i] = e;</span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="createEntry(int hash, K key, V value, int bucketIndex)"></a>createEntry(int hash, K key, V value, int bucketIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment">    * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment">    * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment">    * clone, and readObject.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 与addEntry相似，只是在创建条目时将使用此版本</span></span><br><span class="line"><span class="comment">* 作为Map构造或“伪构造”（克隆，</span></span><br><span class="line"><span class="comment">* 反序列化）的一部分。此版本无需担心调整表的大小。 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">   * 子类重写此方法，以更改HashMap（Map），</span></span><br><span class="line"><span class="comment">   * clone和readObject的行为。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 创建元素，放在头节点</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">       table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="getForNullKey"><a href="#getForNullKey" class="headerlink" title="getForNullKey()"></a>getForNullKey()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Offloaded version of get() to look up null keys.  Null keys map</span></span><br><span class="line"><span class="comment"> * to index 0.  This null case is split out into separate methods</span></span><br><span class="line"><span class="comment"> * for the sake of performance in the two most commonly used</span></span><br><span class="line"><span class="comment"> * operations (get and put), but incorporated with conditionals in</span></span><br><span class="line"><span class="comment"> * others.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Entry-lt-K-V-gt-getEntry-Object-key"><a href="#Entry-lt-K-V-gt-getEntry-Object-key" class="headerlink" title="Entry&lt;K,V&gt; getEntry(Object key)"></a>Entry&lt;K,V&gt; getEntry(Object key)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the entry associated with the specified key in the</span></span><br><span class="line"><span class="comment">  * HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment">  * for the key.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">             ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="6-常见面试题"><a href="#6-常见面试题" class="headerlink" title="6. 常见面试题"></a>6. 常见面试题</h1><h2 id="6-1-HashMap的put方法逻辑"><a href="#6-1-HashMap的put方法逻辑" class="headerlink" title="6.1 HashMap的put方法逻辑"></a>6.1 HashMap的put方法逻辑</h2><ol><li>判断entry是否是空数组，如果是初始化一个长度是16，阈值是12的数组</li><li>判断key是否等于null，如果是null，就放在下标是0的数组位置上，并插入头结点</li><li>对key的hashCode二次hash，并对(length-1)逻辑与，算出数组下标位置</li><li>遍历该下标位置上的链表，如果找到该key，就覆盖旧值并返回</li><li>判断当前元素个数是否大于阈值，如果大于就执行2倍扩容，把原数组的元素重新hash到新数组中</li><li>用当前key创建一个节点，插到下标数组链表的头结点</li></ol><h2 id="6-2-为什么HashMap的容量必须是2的倍数"><a href="#6-2-为什么HashMap的容量必须是2的倍数" class="headerlink" title="6.2 为什么HashMap的容量必须是2的倍数"></a>6.2 为什么HashMap的容量必须是2的倍数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算机中，与运算比求余运算更快，采用了 hashCode &amp; (length-1)。</strong> </p><blockquote><p> 假如length是16，(length-1)的二进制就是 1111，比15小的数逻辑与之后就是自身，比15大的数，只有低4位的数才能运算出值。是为了更方便与运算。</p></blockquote><h2 id="6-3-HashMap线程不安全体现在哪些方面？"><a href="#6-3-HashMap线程不安全体现在哪些方面？" class="headerlink" title="6.3 HashMap线程不安全体现在哪些方面？"></a>6.3 HashMap线程不安全体现在哪些方面？</h2><p>由于hash冲突的时候插入链表，采用的是头插法，导致扩容后链表的顺序和原来顺序相反，多个线程同时扩容会出现环形链表，get的时候陷入死循环。</p><h1 id="7-HashMap还有哪些缺点"><a href="#7-HashMap还有哪些缺点" class="headerlink" title="7. HashMap还有哪些缺点"></a>7. HashMap还有哪些缺点</h1><ol><li>使用单链表解决hash冲突，导致最坏的情况get的效率降至O(N)</li><li>链表采用头插法，导致多线程扩容出现环形链表</li><li>扩容需要把每个元素重新hash放到新数组里，性能太差</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

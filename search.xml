<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="2021/02/02/algorithm/sort/algorithm-sort/"/>
      <url>2021/02/02/algorithm/sort/algorithm-sort/</url>
      
        <content type="html"><![CDATA[<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h4><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20190306165258970-1789860540.png" alt="img"></p><h4 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20180402133438219-1946132192.png" alt="img"></p><p><strong>0.3 相关概念</strong></p><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机</li></ul><p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015223238449-2146169197.gif" alt="img"></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015224719590-1433219824.gif" alt="img">　　</p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015225645277-1151100000.gif" alt="img"></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20180331170017421-364506073.gif" alt="img"></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015230557043-37375010.gif" alt="img"></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015230936371-1413523412.gif" alt="img"></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015231308699-356134237.gif" alt="img"></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015231740840-6968181.gif" alt="img"></p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015232107090-1920702011.png" alt="img"></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="/2021/02/02/algorithm/sort/algorithm-sort/849589-20171015232453668-1397662527.gif" alt="img"> </p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><p>参考：</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列--消息堆积处理方案</title>
      <link href="2021/01/18/mq/mq-mq-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>2021/01/18/mq/mq-mq-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列–消息堆积处理方案"><a href="#消息队列–消息堆积处理方案" class="headerlink" title="消息队列–消息堆积处理方案"></a>消息队列–消息堆积处理方案</h1><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ </p><ul><li>关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在mq里积压，现在事故了，慌了</li></ul><h2 id="（1）大量消息在mq里积压了几个小时了还没解决"><a href="#（1）大量消息在mq里积压了几个小时了还没解决" class="headerlink" title="（1）大量消息在mq里积压了几个小时了还没解决"></a>（1）大量消息在mq里积压了几个小时了还没解决</h2><blockquote><p>几千万条数据在MQ里积压了七八个小时，从下午4点多，积压到了晚上很晚，10点多，11点多</p><p>这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复consumer的问题，让他恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p><p>一个消费者一秒是1000条，一秒3个消费者是3000条，一分钟是18万条，1000多万条</p><p>所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概1小时的时间才能恢复过来</p></blockquote><p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：</p><ol><li>先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</li><li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</li><li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li></ol><h2 id="（2）这里我们假设再来第二个坑"><a href="#（2）这里我们假设再来第二个坑" class="headerlink" title="（2）这里我们假设再来第二个坑"></a>（2）这里我们假设再来第二个坑</h2><blockquote><p>假设你用的是rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在mq里，而是大量的数据会直接搞丢。</p></blockquote><ul><li>这个情况下，就不是说要增加consumer消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。</li><li>这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。</li><li>假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次</li></ul><h2 id="（3）然后我们再来假设第三个坑"><a href="#（3）然后我们再来假设第三个坑" class="headerlink" title="（3）然后我们再来假设第三个坑"></a>（3）然后我们再来假设第三个坑</h2><p> 如果走的方式是消息积压在mq里，那么如果你很长时间都没处理掉，此时导致mq都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>]]></content>
      
      
      <categories>
          
          <category> mq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="2021/01/18/mq/mq-mq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/"/>
      <url>2021/01/18/mq/mq-mq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h1><ul><li>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用</li><li>队列是一种先进先出的数据结构</li></ul><h1 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h1><h2 id="1、解耦"><a href="#1、解耦" class="headerlink" title="1、解耦"></a>1、解耦</h2><h2 id="2、异步"><a href="#2、异步" class="headerlink" title="2、异步"></a>2、异步</h2><h2 id="3、削峰"><a href="#3、削峰" class="headerlink" title="3、削峰"></a>3、削峰</h2><h1 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h1><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h1 id="JMS-与-AMQP"><a href="#JMS-与-AMQP" class="headerlink" title="JMS 与 AMQP"></a>JMS 与 AMQP</h1><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h3 id="JMS-简介"><a href="#JMS-简介" class="headerlink" title="JMS 简介"></a><strong>JMS 简介</strong></h3><ul><li>JMS （ JAVA Message Service , java 消息服务）是 java 的消息服务， JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。</li><li>JMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</li><li>ActiveMQ 就是基于 JMS 规范实现的。</li></ul><h3 id="JMS-两种消息模型"><a href="#JMS-两种消息模型" class="headerlink" title="JMS 两种消息模型"></a>JMS 两种消息模型</h3><h4 id="点到点（-P2P-）模型"><a href="#点到点（-P2P-）模型" class="headerlink" title="点到点（ P2P ）模型"></a>点到点（ P2P ）模型</h4><ul><li>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</li></ul><h4 id="发布-订阅（-Pub-Sub-）模型"><a href="#发布-订阅（-Pub-Sub-）模型" class="headerlink" title="发布/订阅（ Pub/Sub ）模型"></a>发布/订阅（ Pub/Sub ）模型</h4><ul><li>发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</li></ul><h4 id="JMS-五种不同的消息正文格式"><a href="#JMS-五种不同的消息正文格式" class="headerlink" title="JMS 五种不同的消息正文格式"></a>JMS 五种不同的消息正文格式</h4><ul><li>StreamMessage – Java原始值的数据流</li><li>MapMessage – 一套名称-值对</li><li>TextMessage – 一个字符串对象</li><li>ObjectMessage – 一个序列化的 Java对象</li><li>BytesMessage – 一个字节的数据流</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><h3 id="AMQP简介"><a href="#AMQP简介" class="headerlink" title="AMQP简介"></a>AMQP简介</h3><ul><li>  AMQP ，即 Advanced Message Queuing Protocol , 一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS 。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</li><li>  在 AMQP 中，消息路由（ messagerouting ）和 JMS 存在一些差别，在 AMQP 中增加了 Exchange 和 binding 的角色。 producer 将消息发送给 Exchange ， binding 决定 Exchange 的消息应该发送到那个 queue ，而 consumer 直接从 queue 中消费消息。 queue 和 exchange 的 bind 由 consumer 来决定。</li><li>RabbitMQ 就是基于 AMQP 协议实现的。</li></ul><h2 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h2><table><thead><tr><th></th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java api</td><td>Wire-protocol</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>Model</td><td>提供两种消息模型：<br>（1）、<strong>Peer-2-Peer</strong><br>（2）、<strong>Pub/sub</strong></td><td>提供了五种消息模型：<br>（1）、<strong>direct exchange</strong><br>（2）、<strong>fanout exchange</strong><br>（3）、<strong>topic change</strong><br>（4）、<strong>headers exchange</strong><br>（5）、<strong>system exchange</strong><br>本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td>支持消息类型</td><td>多种消息类型：<br><strong>TextMessage</strong><br><strong>MapMessage</strong><br><strong>BytesMessage</strong><br><strong>StreamMessage</strong><br><strong>ObjectMessage</strong><br>Message （只有消息头和属性）</td><td>byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。</td></tr></tbody></table><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li><li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li><li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li></ul><h1 id="五、-常见的消息队列对比"><a href="#五、-常见的消息队列对比" class="headerlink" title="五、 常见的消息队列对比"></a>五、 常见的消息队列对比</h1><p><img src="/2021/01/18/mq/mq-mq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/v2-7e22e0cb2047c64ccdd95d90cdff9d2f_r.jpg" alt="preview"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li><li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p>参照：</p><p><a href="https://zhuanlan.zhihu.com/p/52773169">https://zhuanlan.zhihu.com/p/52773169</a></p>]]></content>
      
      
      <categories>
          
          <category> mq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ夺命连环11问</title>
      <link href="2021/01/18/mq/mq-mq-MQ%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF11%E9%97%AE/"/>
      <url>2021/01/18/mq/mq-mq-MQ%E5%A4%BA%E5%91%BD%E8%BF%9E%E7%8E%AF11%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1、你们为什么使用mq？具体的使用场景是什么？"><a href="#1、你们为什么使用mq？具体的使用场景是什么？" class="headerlink" title="1、你们为什么使用mq？具体的使用场景是什么？"></a>1、你们为什么使用mq？具体的使用场景是什么？</h1><p>mq的作用很简单，削峰填谷。以电商交易下单的场景来说，正向交易的过程可能涉及到创建订单、扣减库存、扣减活动预算、扣减积分等等。每个接口的耗时如果是100ms，那么理论上整个下单的链路就需要耗费400ms，这个时间显然是太长了。</p><p><img src="https://pic1.zhimg.com/80/v2-9be1ef7a125254dcc46926a474a593b0_720w.jpg" alt="img"></p><p>如果这些操作全部同步处理的话，首先调用链路太长影响接口性能，其次分布式事务的问题很难处理，这时候像扣减预算和积分这种对实时一致性要求没有那么高的请求，完全就可以通过mq异步的方式去处理了。同时，考虑到异步带来的不一致的问题，我们可以通过job去重试保证接口调用成功，而且一般公司都会有核对的平台，比如下单成功但是未扣减积分的这种问题可以通过核对作为兜底的处理方案。</p><p><img src="https://pic2.zhimg.com/80/v2-f9080423841112d15a584666c205f231_720w.jpg" alt="img"></p><p>使用mq之后我们的链路变简单了，同时异步发送消息我们的整个系统的抗压能力也上升了。</p><h1 id="2、那你们使用什么mq？基于什么做的选型？"><a href="#2、那你们使用什么mq？基于什么做的选型？" class="headerlink" title="2、那你们使用什么mq？基于什么做的选型？"></a>2、那你们使用什么mq？基于什么做的选型？</h1><p>我们主要调研了几个主流的mq，kafka、rabbitmq、rocketmq、activemq，选型我们主要基于以下几个点去考虑：</p><ol><li>由于我们系统的qps压力比较大，所以性能是首要考虑的要素。</li><li>开发语言，由于我们的开发语言是java，主要是为了方便二次开发。</li><li>对于高并发的业务场景是必须的，所以需要支持分布式架构的设计。</li><li>功能全面，由于不同的业务场景，可能会用到顺序消息、事务消息等。</li></ol><p>基于以上几个考虑，我们最终选择了RocketMQ。</p><table><thead><tr><th></th><th>Kafka</th><th>RocketMQ</th><th>RabbitMQ</th><th>ActiveMQ</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>10万级</td><td>10万级</td><td>万级</td><td>万级</td></tr><tr><td>开发语言</td><td>Scala</td><td>Java</td><td>Erlang</td><td>Java</td></tr><tr><td>高可用</td><td>分布式架构</td><td>分布式架构</td><td>主从架构</td><td>主从架构</td></tr><tr><td>性能</td><td>ms级</td><td>ms级</td><td>us级</td><td>ms级</td></tr><tr><td>功能</td><td>只支持主要的MQ功能</td><td>顺序消息、事务消息等功能完善</td><td>并发强、性能好、延时低</td><td>成熟的社区产品、文档丰富</td></tr></tbody></table><h1 id="3、你上面提到异步发送，那消息可靠性怎么保证？"><a href="#3、你上面提到异步发送，那消息可靠性怎么保证？" class="headerlink" title="3、你上面提到异步发送，那消息可靠性怎么保证？"></a>3、你上面提到异步发送，那消息可靠性怎么保证？</h1><p>消息丢失可能发生在生产者发送消息、MQ本身丢失消息、消费者丢失消息3个方面。</p><h2 id="生产者丢失"><a href="#生产者丢失" class="headerlink" title="生产者丢失"></a>生产者丢失</h2><p>生产者丢失消息的可能点在于程序发送失败抛异常了没有重试处理，或者发送的过程成功但是过程中网络闪断MQ没收到，消息就丢失了。</p><p>由于同步发送的一般不会出现这样使用方式，所以我们就不考虑同步发送的问题，我们基于异步发送的场景来说。</p><p>异步发送分为两个方式：<strong>异步有回调和异步无回调</strong>，无回调的方式，生产者发送完后不管结果可能就会造成消息丢失，而通过异步发送+回调通知+本地消息表的形式我们就可以做出一个解决方案。以下单的场景举例。</p><ol><li>下单后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么下单失败，事务回滚。</li><li>下单成功，直接返回客户端成功，异步发送MQ消息</li><li>MQ回调通知消息发送结果，对应更新数据库MQ发送状态</li><li>JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试</li><li>在监控平台配置或者JOB程序处理超过一定次数一直发送不成功的消息，告警，人工介入。</li></ol><p>![img](mq-mq-MQ夺命连环11问/640 [2])</p><p>一般而言，对于大部分场景来说异步回调的形式就可以了，只有那种需要完全保证不能丢失消息的场景我们做一套完整的解决方案。</p><h2 id="MQ丢失"><a href="#MQ丢失" class="headerlink" title="MQ丢失"></a>MQ丢失</h2><p>如果生产者保证消息发送到MQ，而MQ收到消息后还在内存中，这时候宕机了又没来得及同步给从节点，就有可能导致消息丢失。</p><p>比如RocketMQ：</p><p>RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。</p><p>比如Kafka也可以通过配置做到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acks=all 只有参与复制的所有节点全部收到消息，才返回生产者成功。这样的话除非所有的节点都挂了，消息才会丢失。</span><br><span class="line">replication.factor=N,设置大于1的数，这会要求每个partion至少有2个副本</span><br><span class="line">min.insync.replicas=N，设置大于1的数，这会要求leader至少感知到一个follower还保持着连接</span><br><span class="line">retries=N，设置一个非常大的值，让生产者发送失败一直重试</span><br></pre></td></tr></table></figure><p>虽然我们可以通过配置的方式来达到MQ本身高可用的目的，但是都对性能有损耗，怎样配置需要根据业务做出权衡。</p><h2 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a><strong>消费者丢失</strong></h2><p>消费者丢失消息的场景：消费者刚收到消息，此时服务器宕机，MQ认为消费者已经消费，不会重复发送消息，消息丢失。</p><p>RocketMQ默认是需要消费者回复ack确认，而kafka需要手动开启配置关闭自动offset。</p><p>消费方不返回ack确认，重发的机制根据MQ类型的不同发送时间间隔、次数都不尽相同，如果重试超过次数之后会进入死信队列，需要手工来处理了。（Kafka没有这些）</p><p>![img](mq-mq-MQ夺命连环11问/640 [3])</p><h1 id="4、你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？"><a href="#4、你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？" class="headerlink" title="4、你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？"></a>4、你说到消费者消费失败的问题，那么如果一直消费失败导致消息积压怎么处理？</h1><p>因为考虑到时消费者消费一直出错的问题，那么我们可以从以下几个角度来考虑：</p><ol><li>消费者出错，肯定是程序或者其他问题导致的，如果容易修复，先把问题修复，让consumer恢复正常消费</li><li>如果时间来不及处理很麻烦，做转发处理，写一个临时的consumer消费方案，先把消息消费，然后再转发到一个新的topic和MQ资源，这个新的topic的机器资源单独申请，要能承载住当前积压的消息</li><li>处理完积压数据后，修复consumer，去消费新的MQ和现有的MQ数据，新MQ消费完成后恢复原状</li></ol><p>![img](mq-mq-MQ夺命连环11问/640 [4])</p><h1 id="5、那如果消息积压达到磁盘上限，消息被删除了怎么办？"><a href="#5、那如果消息积压达到磁盘上限，消息被删除了怎么办？" class="headerlink" title="5、那如果消息积压达到磁盘上限，消息被删除了怎么办？"></a>5、那如果消息积压达到磁盘上限，消息被删除了怎么办？</h1><p>这。。。他妈都删除了我有啥办法啊。。。冷静，再想想。。有了。</p><p>最初，我们发送的消息记录是落库保存了的，而转发发送的数据也保存了，那么我们就可以通过这部分数据来找到丢失的那部分数据，再单独跑个脚本重发就可以了。如果转发的程序没有落库，那就和消费方的记录去做对比，只是过程会更艰难一点。</p><h1 id="6、说了这么多，那你说说RocketMQ实现原理吧？"><a href="#6、说了这么多，那你说说RocketMQ实现原理吧？" class="headerlink" title="6、说了这么多，那你说说RocketMQ实现原理吧？"></a>6、说了这么多，那你说说RocketMQ实现原理吧？</h1><p>RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成，它的架构原理是这样的：</p><ol><li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li><li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li><li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li></ol><p>![img](mq-mq-MQ夺命连环11问/640 [5])</p><h1 id="7、为什么RocketMQ不使用Zookeeper作为注册中心呢？"><a href="#7、为什么RocketMQ不使用Zookeeper作为注册中心呢？" class="headerlink" title="7、为什么RocketMQ不使用Zookeeper作为注册中心呢？"></a>7、为什么RocketMQ不使用Zookeeper作为注册中心呢？</h1><p>我认为有以下几个点是不使用zookeeper的原因：</p><ol><li>根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li><li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而zookeeper的写是不可扩展的，而zookeeper要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li><li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li><li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li></ol><h1 id="8、那Broker是怎么保存数据的呢？"><a href="#8、那Broker是怎么保存数据的呢？" class="headerlink" title="8、那Broker是怎么保存数据的呢？"></a>8、那Broker是怎么保存数据的呢？</h1><p>RocketMQ主要的存储文件包括commitlog文件、consumequeue文件、indexfile文件。</p><p>Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。</p><p>![img](mq-mq-MQ夺命连环11问/640 [6])</p><p>CommitLog文件保存于${Rocket_Home}/store/commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p><p><img src="https://pic1.zhimg.com/80/v2-6a9a48925df77d9d0e13af0bf09a7f04_720w.jpg" alt="img"></p><p>由于同一个topic的消息并不是连续的存储在commitlog中，消费者如果直接从commitlog获取消息效率非常低，所以通过consumequeue保存commitlog中消息的偏移量的物理地址，这样消费者在消费的时候先从consumequeue中根据偏移量定位到具体的commitlog物理文件，然后根据一定的规则（offset和文件大小取模）在commitlog中快速定位。</p><p>![img](mq-mq-MQ夺命连环11问/640 [8])</p><h1 id="9、Master和Slave之间是怎么同步数据的呢？"><a href="#9、Master和Slave之间是怎么同步数据的呢？" class="headerlink" title="9、Master和Slave之间是怎么同步数据的呢？"></a>9、Master和Slave之间是怎么同步数据的呢？</h1><p>而消息在master和slave之间的同步是根据raft协议来进行的：</p><ol><li>在broker收到消息后，会被标记为uncommitted状态</li><li>然后会把消息发送给所有的slave</li><li>slave在收到消息之后返回ack响应给master</li><li>master在收到超过半数的ack之后，把消息标记为committed</li><li>发送committed消息给所有slave，slave也修改状态为committed</li></ol><h1 id="10、你知道RocketMQ为什么速度快吗？"><a href="#10、你知道RocketMQ为什么速度快吗？" class="headerlink" title="10、你知道RocketMQ为什么速度快吗？"></a>10、你知道RocketMQ为什么速度快吗？</h1><p>是因为使用了顺序存储、Page Cache和异步刷盘。</p><ol><li>我们在写入commitlog的时候是顺序写入的，这样比随机写入的性能就会提高很多</li><li>写入commitlog的时候并不是直接写入磁盘，而是先写入操作系统的PageCache</li><li>最后由操作系统异步将缓存中的数据刷到磁盘</li></ol><h1 id="11、什么是事务、半事务消息？怎么实现的？"><a href="#11、什么是事务、半事务消息？怎么实现的？" class="headerlink" title="11、什么是事务、半事务消息？怎么实现的？"></a>11、什么是事务、半事务消息？怎么实现的？</h1><p>事务消息就是MQ提供的类似XA的分布式事务能力，通过事务消息可以达到分布式事务的最终一致性。</p><p>半事务消息就是MQ收到了生产者的消息，但是没有收到二次确认，不能投递的消息。</p><p>实现原理如下：</p><ol><li>生产者先发送一条半事务消息到MQ</li><li>MQ收到消息后返回ack确认</li><li>生产者开始执行本地事务</li><li>如果事务执行成功发送commit到MQ，失败发送rollback</li><li>如果MQ长时间未收到生产者的二次确认commit或者rollback，MQ对生产者发起消息回查</li><li>生产者查询事务执行最终状态</li><li>根据查询事务状态再次提交二次确认</li></ol><p>最终，如果MQ收到二次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在3天后被删除。</p><p>![img](mq-mq-MQ夺命连环11问/640 [9]-1611835066832)</p><p>参照：</p><p><a href="https://zhuanlan.zhihu.com/p/347131921">https://zhuanlan.zhihu.com/p/347131921</a></p>]]></content>
      
      
      <categories>
          
          <category> mq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 分库分表</title>
      <link href="2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Sharding"><a href="#1-Sharding" class="headerlink" title="1 Sharding"></a>1 Sharding</h1><p>把数据库横向扩展到多个物理节点的一种有效方式，主要是为了突破数据库单机服务器的 I/O 瓶颈，解决数据库扩展问题。</p><p>Sharding可简单定义为将大数据库分布到多个物理节点上的一个分区方案。每一个分区包含数据库的某一部分，称为一个shard，分区方式可以是任意的，并不局限于传统的水平分区和垂直分区。 一个shard可以包含多个表的内容甚至可以包含多个数据库实例中的内容。每个shard被放置在一个数据库服务器上。一个数据库服务器可以处理一个或多个shard的数据。系统中需要有服务器进行查询路由转发，负责将查询转发到包含该查询所访问数据的shard或shards节点上去执行。</p><h1 id="2-垂直切分-水平切分"><a href="#2-垂直切分-水平切分" class="headerlink" title="2 垂直切分/水平切分"></a>2 垂直切分/水平切分</h1><h2 id="2-1-MySQL的扩展方案"><a href="#2-1-MySQL的扩展方案" class="headerlink" title="2.1 MySQL的扩展方案"></a>2.1 MySQL的扩展方案</h2><ul><li>Scale Out 水平扩展</li></ul><p>一般对数据中心应用，添加更多机器时，应用仍可很好利用这些资源提升自己的效率从而达到很好的扩展性</p><ul><li>Scale Up 垂直扩展</li></ul><p>一般对单台机器，Scale Up指当某个计算节点添加更多的CPU Cores，存储设备，使用更大的内存时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性</p><h2 id="2-2-MySQL的Sharding策略"><a href="#2-2-MySQL的Sharding策略" class="headerlink" title="2.2 MySQL的Sharding策略"></a>2.2 MySQL的Sharding策略</h2><ol><li>垂直切分：按功能模块拆分，以解决<code>表与表之间</code>的I/O竞争</li></ol><p>e.g. 将原来的老订单库，切分为基础订单库和订单流程库。数据库之间的<code>表结构不同</code> <img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829110221177.png" alt="img"></p><ol><li>水平切分：将<code>同个表</code>的数据分块，保存至不同的数据库</li></ol><p>以解决单表中数据量增长压力。这些数据库中的<code>表结构完全相同</code></p><h2 id="2-3-表结构设计案例"><a href="#2-3-表结构设计案例" class="headerlink" title="2.3 表结构设计案例"></a>2.3 表结构设计案例</h2><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><ol><li>大字段</li></ol><p>单独将大字段建在另外的表中，提高基础表的访问性能，原则上在性能关键的应用中应当避免数据库的大字段 2. 按用途 例如企业物料属性，可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直切分 3. 按访问频率 例如电子商务、Web 2.0系统中，如果用户属性设置非常多，可以将基本、使用频繁的属性和不常用的属性垂直切分开</p><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><ol><li>比如在线电子商务网站，订单表数据量过大，按照年度、月度水平切分</li><li>网站注册用户、在线活跃用户过多，按照用户ID范围等方式，将相关用户以及该用户紧密关联的表做水平切分</li><li>论坛的置顶帖，因为涉及到分页问题，每页都需显示置顶贴，这种情况可以把置顶贴水平切分开来，避免取置顶帖子时从所有帖子的表中读取</li></ol><h1 id="3-分表和分区"><a href="#3-分表和分区" class="headerlink" title="3 分表和分区"></a>3 分表和分区</h1><p>分表：把一张表分成多个小表； 分区：把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。</p><h2 id="3-1-分表和分区的区别"><a href="#3-1-分表和分区的区别" class="headerlink" title="3.1 分表和分区的区别"></a>3.1 分表和分区的区别</h2><ul><li>实现方式</li></ul><p>MySQL的一张表分成多表后，每个小表都是完整的一张表，都对应三个文件（MyISAM引擎：.MYD数据文件，.MYI索引文件，.frm表结构文件）</p><ul><li>数据处理 <ul><li>分表后数据都存放在分表里，总表只是个外壳，存取数据发生在一个个的分表里</li><li>分区则不存在分表的概念，分区只不过把存放数据的文件分成许多小块，分区后的表还是一张表，数据处理还是自己完成。</li></ul></li><li>性能 <ul><li>分表后，单表的并发能力提高了，磁盘I/O性能也提高了。分表的关键是存取数据时，如何提高 MySQL并发能力</li><li>分区突破了磁盘I/O瓶颈，想提高磁盘的读写能力，来增加MySQL性能</li></ul></li><li>实现成本 <ul><li>分表的方法有很多，用merge来分表，是最简单的一种。这种方式和分区难易度差不多，并且对程序代码透明，如果用其他分表方式就比分区麻烦</li><li>分区实现比较简单，建立分区表，跟建平常的表没区别，并且对代码端透明</li></ul></li></ul><h2 id="3-2-分区适用场景"><a href="#3-2-分区适用场景" class="headerlink" title="3.2 分区适用场景"></a>3.2 分区适用场景</h2><ol><li>一张表的查询速度慢到影响使用</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ol><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829015141290.png" alt="img"></p><h2 id="3-3-分表适用场景"><a href="#3-3-分表适用场景" class="headerlink" title="3.3 分表适用场景"></a>3.3 分表适用场景</h2><ol><li>一张表的查询速度慢到影响使用</li><li>频繁插入或连接查询时，速度变慢</li><li>分表的实现需要业务结合实现和迁移，较为复杂</li></ol><h1 id="4-分库"><a href="#4-分库" class="headerlink" title="4 分库"></a>4 分库</h1><p>分表能解决<code>单表数据量过大带来的查询效率下降</code>问题，但无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库主服务器无法承载写压力，不管如何扩展从服务器，都没有意义了。 换个思路，对数据库进行拆分，<code>提高数据库写性能</code>，即分库。</p><h2 id="4-1-分库的解决方案"><a href="#4-1-分库的解决方案" class="headerlink" title="4.1 分库的解决方案"></a>4.1 分库的解决方案</h2><p>一个MySQL实例中的多个数据库拆到不同MySQL实例中： <img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80Njg1OTY4LTFhNzBiNTMzNDY1MDU3NTQucG5n.png" alt="img"></p><ul><li>缺陷</li></ul><p>有的节点还是无法承受写压力。</p><h3 id="4-1-1-查询切分"><a href="#4-1-1-查询切分" class="headerlink" title="4.1.1 查询切分"></a>4.1.1 查询切分</h3><ul><li>将key和库的映射关系单独记录在一个数据库。</li></ul><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829114917514.png" alt="img"></p><ul><li>优点</li></ul><p>key和库的映射算法可以随便自定义</p><ul><li>缺点</li></ul><p>引入了额外的单点</p><h3 id="4-1-2-范围切分"><a href="#4-1-2-范围切分" class="headerlink" title="4.1.2 范围切分"></a>4.1.2 范围切分</h3><ul><li>按照时间区间或ID区间切分。</li></ul><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829115657202.png" alt="img"></p><ul><li>优点</li></ul><p>单表容量可控，水平扩展很方便。</p><ul><li>缺点</li></ul><p>无法解决集中写入的瓶颈问题。</p><h3 id="4-1-3-Hash切分（重点）"><a href="#4-1-3-Hash切分（重点）" class="headerlink" title="4.1.3 Hash切分（重点）"></a>4.1.3 Hash切分（重点）</h3><ul><li>一般都是采用hash切分。</li></ul><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829112801122.png" alt="img"></p><p>数据水平切分后我们希望是一劳永逸或者是易于水平扩展的，所以推荐采用mod 2^n这种一致性Hash。</p><p>比如一个订单库，分库分表方案是32*32，即通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024张表。</p><blockquote><p>线上部署情况为8个集群(主从)，每个集群4个库。</p></blockquote><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829112716345.png" alt="img"></p><p>为什么说这易于水平扩展？分析如下场景：</p><h4 id="数据库性能达到瓶颈"><a href="#数据库性能达到瓶颈" class="headerlink" title="数据库性能达到瓶颈"></a>数据库性能达到瓶颈</h4><ol><li>现有规则不变，可直接扩展到32个数据库集群。</li></ol><p><img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829120226464.png" alt="img"> 2. 如果32个集群也无法满足需求，那么将分库分表规则调整为(32<em>2^n)</em>(32⁄2^n)，可以达到最多1024个集群。 <img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829120300693.png" alt="img"></p><h4 id="单表容量达到瓶颈"><a href="#单表容量达到瓶颈" class="headerlink" title="单表容量达到瓶颈"></a>单表容量达到瓶颈</h4><p>或1024都无法满足。 <img src="/2021/01/17/database/mysql/mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/20200829120344287.png" alt="img"> 假如单表都突破200G，200*1024=200T 没关系，32 * (32 * 2^n)，这时分库规则不变，单库里的表再裂变，当然，在目前订单这种规则下（用userId后四位 mod）还是有极限的，因为只有四位，所以最多拆8192个表。</p><h2 id="选择分片键"><a href="#选择分片键" class="headerlink" title="选择分片键"></a>选择分片键</h2><ul><li>尽量避免跨分区查询的发生(无法完全避免)</li><li>尽量使各个分片中的数据平均</li></ul><h2 id="如何存储无需分片的表"><a href="#如何存储无需分片的表" class="headerlink" title="如何存储无需分片的表"></a>如何存储无需分片的表</h2><ul><li>每个分片中存储一份相同的数据</li></ul><p>对于数据量不大且并不经常被更新的字典类表，经常需要和分区表一起关联查询，每个分片中存储一份冗余的数据可以更好提高查询效率，维护其一致性就很重要了。</p><ul><li>使用额外的节点统一存储</li></ul><p>没有冗余问题,但是查询效率较差,需要汇总</p><h2 id="在节点上部署分片"><a href="#在节点上部署分片" class="headerlink" title="在节点上部署分片"></a>在节点上部署分片</h2><ul><li>每个分片使用单一数据库,并且数据库名也相同</li></ul><p>结构也保持相同,和单一节点时的一致</p><ul><li>将多个分片表存储在一个数据库中,并在表名上加入分片号后缀</li><li>在一个节点中部署多个数据库,每个数据库包含一个切片</li></ul><h1 id="5-分库分表后的难题"><a href="#5-分库分表后的难题" class="headerlink" title="5 分库分表后的难题"></a>5 分库分表后的难题</h1><h2 id="全局唯一ID生成方案"><a href="#全局唯一ID生成方案" class="headerlink" title="全局唯一ID生成方案"></a>全局唯一ID生成方案</h2><p>方案很多，主流的如下：</p><h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>使用</p><ul><li><code>auto_increment_increment </code></li><li><code>auto_increment_offset</code></li></ul><p>系统变量让MySQL以期望的值和偏移量来增加<code>auto_increment</code>列的值。</p><ul><li>优点</li></ul><p>最简单，不依赖于某节点，较普遍采用但需要非常仔细的配置服务器哦！</p><ul><li>缺点</li></ul><p>单点风险、单机性能瓶颈。不适用于一个节点包含多个分区表的场景。</p><h3 id="数据库集群并设置相应步长（Flickr方案）"><a href="#数据库集群并设置相应步长（Flickr方案）" class="headerlink" title="数据库集群并设置相应步长（Flickr方案）"></a>数据库集群并设置相应步长（Flickr方案）</h3><p>在一个全局数据库节点中创建一个包含<code>auto_increment</code>列的表，应用通过该表生成唯一数字。</p><ul><li>优点</li></ul><p>高可用、ID较简洁。</p><ul><li>缺点</li></ul><p>需要单独的数据库集群。</p><h3 id="Redis等缓存NoSQL服务"><a href="#Redis等缓存NoSQL服务" class="headerlink" title="Redis等缓存NoSQL服务"></a>Redis等缓存NoSQL服务</h3><p>避免了MySQL性能低的问题。</p><h3 id="Snowflake（雪花算法）"><a href="#Snowflake（雪花算法）" class="headerlink" title="Snowflake（雪花算法）"></a>Snowflake（雪花算法）</h3><ul><li>优点</li></ul><p>高性能高可用、易拓展。</p><ul><li>缺点</li></ul><p>需要独立的集群以及ZK。</p><h3 id="各种GUID、Random算法"><a href="#各种GUID、Random算法" class="headerlink" title="各种GUID、Random算法"></a>各种GUID、Random算法</h3><ul><li>优点</li></ul><p>简单。</p><ul><li>缺点</li></ul><p>生成ID较长，且有重复几率。</p><h3 id="业务字段（美团的实践方案）"><a href="#业务字段（美团的实践方案）" class="headerlink" title="业务字段（美团的实践方案）"></a>业务字段（美团的实践方案）</h3><p>为减少运营成本并减少额外风险，美团排除了所有需要独立集群的方案，采用了带有业务属性的方案： <code>时间戳+用户标识码+随机数</code></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>方便、成本低</li><li>基本无重复的可能</li><li>自带分库规则，这里的用户标识码即为<code>userID的后四位</code>，在查询场景，只需订单号即可匹配到相应库表而无需用户ID，只取四位是希望订单号尽可能短，评估后四位已足。</li><li>可排序，因为时间戳在最前</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>长度稍长，性能要比int/bigint的稍差。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>分库分表后，由于数据存到了不同库，数据库事务管理出现困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><ul><li>解决方案</li></ul><p>比如美团，是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p><h2 id="跨库跨表的join问题"><a href="#跨库跨表的join问题" class="headerlink" title="跨库跨表的join问题"></a>跨库跨表的join问题</h2><p>分库分表之后，难免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次询能够完成的业务，可能需要多次查询才能完成。</p><ul><li>解决方案</li></ul><p>垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内。 比如查询具体某个用户下的订单等； 禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p><h2 id="额外的数据管理和运算压力"><a href="#额外的数据管理和运算压力" class="headerlink" title="额外的数据管理和运算压力"></a>额外的数据管理和运算压力</h2><p>额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算。 例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表前，只需一个order by即可。但分表后，将需要n个order by语句，分别查出每一个分表前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。 拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。</p><p>参考：</p><p><a href="https://juejin.cn/post/6866295501763903502">https://juejin.cn/post/6866295501763903502</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL InnoDB-锁</title>
      <link href="2021/01/17/database/mysql/mysql-%E9%94%81/"/>
      <url>2021/01/17/database/mysql/mysql-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h1><h1 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h1><ul><li>基于锁的属性分类：共享锁、排他锁。</li><li>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁。</li><li>基于锁的状态分类：意向共享锁、意向排它锁。</li></ul><h2 id="属性锁"><a href="#属性锁" class="headerlink" title="属性锁"></a>属性锁</h2><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><ul><li>共享锁又称读锁，简称 S 锁：当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。</li><li>共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</li></ul><h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><ul><li>排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。</li><li>排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。</li></ul><h2 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a>粒度锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；</li><li>特点： 粒度大，加锁简单，容易冲突；</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；</li><li>特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；</li></ul><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><ul><li>记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</li></ul><blockquote><p><strong>触发条件：</strong>精准条件命中，并且命中的条件字段是唯一索引；</p><p><strong>例如：</strong>update user_info set name=’张三’ where id=1 ,这里的id是唯一索引。</p><p><strong>记录锁的作用：</strong>加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</p></blockquote><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><ul><li>间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</li></ul><blockquote><p>比如下面的表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/v2-691b5b3936ddd2bae289cac6356b4d97_720w.png" alt="img"></p><p><strong>触发条件：</strong>范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</p><p><strong>例如</strong>：对应上图的表执行select * from user_info where id&gt;1 and id&lt;4(这里的id是唯一索引) ，这个SQL查询不到对应的记录，那么此时会使用间隙锁。</p><p><strong>间隙锁作用</strong>：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/v2-c02d6502983df69147e5f3d4c039cda0_720w.png" alt="img"></p></blockquote><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><ul><li>临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</li></ul><blockquote><p><strong>例如：</strong>下面表的数据执行 select * from user_info where id&gt;1 and id&lt;=13 for update ;</p><p>会锁住ID为 1,5,10的记录；同时会锁住，1至5,5至10,10至15的区间。</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/v2-8c9555f753fbab98c71760ddba9e5068_720w.png" alt="img"></p><p><strong>触发条件：</strong>范围查询并命中，查询命中了索引。</p><p><strong>临键锁的作用：</strong>结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</p></blockquote><h2 id="状态锁"><a href="#状态锁" class="headerlink" title="状态锁"></a>状态锁</h2><p>状态锁包括意向共享锁和意向排它锁，把他们区分为状态锁的一个核心逻辑，是因为这两个锁都是描述是否可以对某一个表进行加表锁的状态。</p><p><strong>意向锁的解释</strong>：当一个事务试图对<strong>整个表</strong>进行加锁（共享锁或排它锁）之前，首先需要获得对应类型的意向锁（意向共享锁或意向共享锁）</p><h3 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a><strong>意向共享锁</strong></h3><ul><li>当一个事务试图对<strong>整个表</strong>进行加共享锁之前，首先需要获得这个表的意向共享锁。</li></ul><h3 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a><strong>意向排他锁</strong></h3><ul><li>当一个事务试图对<strong>整个表</strong>进行加排它锁之前，首先需要获得这个表的意向排它锁。</li></ul><h3 id="为什么我们需要意向锁？"><a href="#为什么我们需要意向锁？" class="headerlink" title="为什么我们需要意向锁？"></a><strong>为什么我们需要意向锁？</strong></h3><p>意向锁光从概念上可能有点难理解，所以我们有必要从一个案例来分析其作用，这里首先我们先要有一个概念那就是 innodb 加锁的方式是基于索引，并且加锁粒度是行锁，然后我们来看下面的案例。</p><p><strong>第一步：</strong></p><p>事务 A 对 user_info 表执行一个 SQL ： <code>update user_info set name =”张三” where id=6</code>  加锁情况如下图;</p><p><img src="/2021/01/17/database/mysql/mysql-%E9%94%81/v2-17fb981d24d52d615b382b79a7694378_720w.png" alt="img"></p><p><strong>第二步：</strong></p><p>与此同时数据库又接收到事务B修改数据的请求： SQL ：  <code>update user_info set name =”李四”；</code></p><p>1、因为事务 B 是对整个表进行修改操作，那么此 SQL 是需要对整个表进行加排它锁的（ update 加锁类型为排他锁）；</p><p>2、我们首先做的第一件事是先检查这个表有没有被别的事务锁住，只要有事务对表里的任何一行数据加了共享锁或排他锁我们就无法对整个表加锁（<strong>排他锁不能与任何属性的锁兼容</strong>）<strong>。</strong></p><p>3、因为 InnoDB 锁的机制是基于行锁，那么这个时候我们会对整个索引每个节点一个个检查，我们需要检查每个节点是否被别的事务加了共享锁或排它锁。</p><p>4、最后检查到索引 ID 为 6 的节点被事务 A 锁住了，最后导致事务 B 只能等待事务 A 锁的释放才能进行加锁操作。</p><p><strong>思考：</strong></p><p>在A事务的操作过程中，后面的每个需要对user_info加持表锁的事务都需要遍历整个索引树才能知道自己是否能够进行加锁，这种方式是不是太浪费时间和损耗数据库性能了？</p><p><strong>所以就有了意向锁的概念：</strong>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是我们的意向锁。</p><h1 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h1><ul><li>Record Lock：单个记录上的锁</li><li>Gap Lock： 间隙锁，锁定一个范围，但不包括记录本上</li><li>Next-Key Lock： Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li></ul><h2 id="行锁（Record-Locks）"><a href="#行锁（Record-Locks）" class="headerlink" title="行锁（Record Locks）"></a>行锁（Record Locks）</h2><ul><li>行锁是作用在索引记录上的。例如， SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;会防止其他事物对于t.c1=10的增、删、改。</li><li>行锁总是锁索引记录的，尽管没有创建索引，对于没有创建索引的情况，InnoDB创建一个隐藏的聚簇索引并用该索引来实现行锁。</li></ul><h2 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h2><ul><li>间隙锁是作用于索引记录之间或第一条索引记录之前或最后一条索引记录之后的锁。</li><li>间隙锁不会作用于使用唯一索引去检索唯一行记录的情况。</li><li>间隙锁能防止幻读。（当前读）</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>两个或以上事务在执行过程中，因争夺资源造成的相互等待现象</p><p>解决办法：</p><ul><li>超时回滚</li><li>wait-for graph，死锁检测<ul><li>维护所得信息链表，事务等待链表，若存在回路则有死锁</li><li>通常采用深度优先算法实现</li></ul></li></ul><p>参考：</p><p><a href="https://juejin.cn/post/6844903744417562638">https://juejin.cn/post/6844903744417562638</a></p><p><a href="https://zhuanlan.zhihu.com/p/213814000">https://zhuanlan.zhihu.com/p/213814000</a></p><p><a href="https://zhuanlan.zhihu.com/p/66676020">https://zhuanlan.zhihu.com/p/66676020</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 日志</title>
      <link href="2021/01/17/database/mysql/mysql-%E6%97%A5%E5%BF%97/"/>
      <url>2021/01/17/database/mysql/mysql-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>日志是<code>mysql</code>数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志(<code>binlog</code>)和事务日志(包括<code>redo log</code>和<code>undo log</code>)，本文接下来会详细介绍这三种日志。</p><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>错误日志文件对MySQL的启动，运行，关闭过程进行了记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| Variable_name | Value               |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| log_error     | &#x2F;var&#x2F;log&#x2F;mysqld.log |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>可以看到错误日志的路径和文件名，默认情况下错误文件的文件名为服务器的主机名，即：<code>hostname.err</code>。只不过我这里设置的是<code>/var/log/mysqld.log</code>,修改错误日志地址可以在<code>/etc/my.cnf</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Recommended in standard MySQL setup</span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</span><br></pre></td></tr></table></figure><p>当出现MySQL数据库不能正常启动时，第一个必须查找的文件就是<strong>错误日志文件</strong>，该文件记录了出错信息，能够帮助我们找到问题。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录响应时间超过阈值的SQL语句，所以我们可以设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。该阈值可以通过参数  <code>long_query_time</code> 来设置，默认为10秒。</p><h2 id="启动慢查询日志"><a href="#启动慢查询日志" class="headerlink" title="启动慢查询日志"></a>启动慢查询日志</h2><p><strong>默认情况下，MySQL数据库并不启动慢查询日志，需要手动将这个参数设为ON，然后启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow%&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| log_slow_admin_statements | OFF                                             |</span><br><span class="line">| log_slow_slave_statements | OFF                                             |</span><br><span class="line">| slow_launch_time          | 2                                               |</span><br><span class="line">| slow_query_log            | OFF                                             |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;slow_query_log&quot;;</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name             | Value                                           |</span><br><span class="line">+---------------------------+-------------------------------------------------+                                        |</span><br><span class="line">| slow_query_log            | ON                                              |</span><br><span class="line">| slow_query_log_file       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">+---------------------------+-------------------------------------------------+</span><br><span class="line">2   rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>**但是使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果MySQL数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf (其他系统变量也是如此)**，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log&#x3D;1</span><br></pre></td></tr></table></figure><p>然后重启MySQL就可以让慢查询日志记录开启了,至于日志文件的路径就是上面<code>slow_query_log_file</code>对应的路径。</p><h2 id="设置阈值"><a href="#设置阈值" class="headerlink" title="设置阈值"></a>设置阈值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>阈值默认为10秒，我们可以修改阈值大小，比如(当然这还是对当前数据库有效)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global long_query_time&#x3D;0.05;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>设置<code>long_query_time</code>这个阈值之后，MySQL数据库会记录运行时间超过该值的所有SQL语句，但对于运行时间正好等于 <code>long_query_time</code> 的情况，并不会被记录下。而设置 <code>long_query_time</code>为0来捕获所有的查询</p><h2 id="参数log-queries-not-using-indexes"><a href="#参数log-queries-not-using-indexes" class="headerlink" title="参数log_queries_not_using_indexes"></a>参数log_queries_not_using_indexes</h2><p><strong>另一个和慢查询日志有关的参数是 log_queries_not_using_indexes</strong>, 如果运行的SQL语句没有使用索引，则MySQL数据库同样会将这条SQL语句记录到慢查询日志文件。首先确认打开了log_queries_not_using_indexes;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_queries_not_using_indexes&#39;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes | ON    |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">1 row in set (0.12 sec)</span><br></pre></td></tr></table></figure><p>例子，没有用到索引进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from vote_record_memory where vote_id &#x3D; 323;</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table              | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | vote_record_memory | ALL  | NULL          | NULL | NULL    | NULL | 149272 | Using where |</span><br><span class="line">+----+-------------+--------------------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">1 row in set (1.56 sec)</span><br></pre></td></tr></table></figure><p>可以看到是进行了全表扫描； 然后去log日志文件中查看这条SQL已经被标记为慢SQL，因为它没有使用索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Time: 180817 11:42:59</span><br><span class="line"># User@Host: root[root] @  [117.136.86.151]  Id:  2625</span><br><span class="line"># Query_time: 0.016542  Lock_time: 0.000112 Rows_sent: 142  Rows_examined: 149272</span><br><span class="line">SET timestamp&#x3D;1534477379;</span><br><span class="line">select * from vote_record_memory where vote_id &#x3D; 323;</span><br></pre></td></tr></table></figure><h2 id="将日志记录放入表中"><a href="#将日志记录放入表中" class="headerlink" title="将日志记录放入表中"></a>将日志记录放入表中</h2><p>MySQL5.1开始可以将慢查询的日志记录放入一张表中，在mysql数据库下，名为slow_log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">| slow_log | CREATE TABLE &#96;slow_log&#96; (</span><br><span class="line">  &#96;start_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  &#96;user_host&#96; mediumtext NOT NULL,</span><br><span class="line">  &#96;query_time&#96; time NOT NULL,</span><br><span class="line">  &#96;lock_time&#96; time NOT NULL,</span><br><span class="line">  &#96;rows_sent&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;rows_examined&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;db&#96; varchar(512) NOT NULL,</span><br><span class="line">  &#96;last_insert_id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;insert_id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;server_id&#96; int(10) unsigned NOT NULL,</span><br><span class="line">  &#96;sql_text&#96; mediumtext NOT NULL,</span><br><span class="line">  &#96;thread_id&#96; bigint(21) unsigned NOT NULL</span><br><span class="line">) ENGINE&#x3D;CSV DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;Slow log&#39; |</span><br></pre></td></tr></table></figure><p>参数<code>log_output</code>指定了慢查询输出的格式，默认为file,可以将它设置成table，将变成了上面的slow_log中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;log_output&quot;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_output    | FILE  |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.19 sec)</span><br></pre></td></tr></table></figure><p><strong>但是多数情况下这样做没什么必要，这不但对性能有较大影响，而且 MySQL 5.1 在将慢查询记录到文件中时已经支持微秒级别的信息，然而将慢查询记录到表中会导致时间粒度退化为只能到秒级，而秒级别的慢查询日志没有太大的意义</strong></p><h2 id="慢查询日志分析工具"><a href="#慢查询日志分析工具" class="headerlink" title="慢查询日志分析工具"></a>慢查询日志分析工具</h2><h3 id="mysqldumpslo3w命令"><a href="#mysqldumpslo3w命令" class="headerlink" title="mysqldumpslo3w命令"></a>mysqldumpslo3w命令</h3><p>当越来越多的SQL查询被记录到慢查询日志文件中，这时候直接看日志文件就不容易了，MySQL提供了<code>mysqldumpslow</code> 命令解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zeaf3cg1099kiidi06mz mysql]# mysqldumpslow iz2zeaf3cg1099kiidi06mz-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from iz2zeaf3cg1099kiidi06mz-slow.log</span><br><span class="line">Count: 1  Time&#x3D;60.02s (60s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;149272.0 (149272), root[root]@[117.136.86.151]</span><br><span class="line">  select * from vote_record_memory</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;14.85s (14s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;0.0 (0), root[root]@[117.136.86.151]</span><br><span class="line">  CALL add_vote_memory(N)</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;1.72s (1s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;0.0 (0), root[root]@[117.136.86.151]</span><br><span class="line">  INSERT into vote_record SELECT * from  vote_record_memory</span><br><span class="line"></span><br><span class="line">Count: 1  Time&#x3D;0.02s (0s)  Lock&#x3D;0.00s (0s)  Rows&#x3D;142.0 (142), root[root]@[117.136.86.151]</span><br><span class="line">  select * from vote_record_memory where vote_id &#x3D; N</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多关于 <code>mysqldumpslow</code> 命令的介绍，请参阅 ：<a href="https://github.com/luisedware/Archives/issues/7">mysqldumpslow 的参数讲解与基础使用</a></p><h3 id="pt-query-digest-工具"><a href="#pt-query-digest-工具" class="headerlink" title="pt-query-digest 工具"></a>pt-query-digest 工具</h3><p>pt-query-digest 是分析MySQL查询日志最有力的工具，该工具功能强大，它可以分析binlog，Generallog，slowlog，也可以通过<code>show processlist</code>或者通过 <code>tcpdump</code> 抓取的MySQL协议数据来进行分析，比 mysqldumpslow 更具体，更完善。以下是使用pt-query-digest的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接分析慢查询文件</span><br><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该工具可以将查询的剖析报告打印出来，可以分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间，次数，占比等，可以借助分析结果找出问题进行优化。更多关于pt-query-digest的安装与使用，请参阅 : <a href="http://www.ywnds.com/?p=8179">www.ywnds.com/?p=8179</a></p></blockquote><h1 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h1><p>查看日志记录了所有对 MySQL 数据库请求的信息，不论这些请求是否得到了正确的执行。默认为 <code>主机名.log</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;general_log%&quot;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | OFF                                        |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">2 rows in set (0.24 sec)   </span><br></pre></td></tr></table></figure><p>默认情况下不启动查询日志，必须要先开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global general_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &quot;general_log%&quot;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | ON                                         |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">2 rows in set (0.11 sec)</span><br></pre></td></tr></table></figure><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p><code>binlog</code>用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code>是<code>mysql</code>的逻辑日志，并且由<code>Server</code>层进行记录，使用任何存储引擎的<code>mysql</code>数据库都会记录<code>binlog</code>日志。</p><blockquote><p>逻辑日志：<strong>可以简单理解为记录的就是sql语句</strong>。</p></blockquote><blockquote><p>物理日志：<strong>因为mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更</strong>。</p></blockquote><p><code>binlog</code>是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code>参数设置每个<code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><h2 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a>binlog使用场景</h2><p>在实际应用中，<code>binlog</code>的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p><ol><li><strong>主从复制</strong>：在<code>Master</code>端开启<code>binlog</code>，然后将<code>binlog</code>发送到各个<code>Slave</code>端，<code>Slave</code>端重放<code>binlog</code>从而达到主从数据一致。</li><li><strong>数据恢复</strong>：通过使用<code>mysqlbinlog</code>工具来恢复数据。</li></ol><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><p>对于<code>InnoDB</code>存储引擎而言，只有在事务提交时才会记录<code>biglog</code>，此时记录还在内存中，那么<code>biglog</code>是什么时候刷到磁盘中的呢？<code>mysql</code>通过<code>sync_binlog</code>参数控制<code>biglog</code>的刷盘时机，取值范围是<code>0-N</code>：</p><ul><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：每次<code>commit</code>的时候都要将<code>binlog</code>写入磁盘；</li><li>N：每N个事务，才会将<code>binlog</code>写入磁盘。</li></ul><p>从上面可以看出，<code>sync_binlog</code>最安全的是设置是<code>1</code>，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p><h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p><code>binlog</code>日志有三种格式，分别为<code>STATMENT</code>、<code>ROW</code>和<code>MIXED</code>。</p><blockquote><p>在 <code>MySQL 5.7.7</code>之前，默认的格式是<code>STATEMENT</code>，<code>MySQL 5.7.7</code>之后，默认值是<code>ROW</code>。日志格式通过<code>binlog-format</code>指定。</p></blockquote><ul><li><code>STATMENT</code> <strong>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中</strong>。 优点：<strong>不需要记录每一行的变化，减少了binlog日志量，节约了IO, 从而提高了性能</strong>； 缺点：<strong>在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</strong>。</li><li><code>ROW</code> <strong>基于行的复制(row-based replication, RBR)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了</strong>。 优点：<strong>不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题</strong>； 缺点：<strong>会产生大量的日志，尤其是alter table的时候会让日志暴涨</strong></li><li><code>MIXED</code> <strong>基于STATMENT和ROW两种模式的混合复制(mixed-based replication, MBR)，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog</strong></li></ul><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h2><p>我们都知道，事务的四大特性里面有一个是<strong>持久性</strong>，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong>。那么<code>mysql</code>是如何保证持久性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p><ol><li>因为<code>Innodb</code>是以<code>页</code>为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li></ol><p>因此<code>mysql</code>设计了<code>redo log</code>，<strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p><h2 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a>redo log基本概念</h2><p><code>redo log</code>包括两部分：一个是内存中的日志缓冲(<code>redo log buffer</code>)，另一个是磁盘上的日志文件(<code>redo log file</code>)。<code>mysql</code>每执行一条<code>DML</code>语句，先将记录写入<code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到<code>redo log file</code>。这种<strong>先写日志，再写磁盘</strong>的技术就是<code>MySQL</code>里经常说到的<code>WAL(Write-Ahead Logging)</code> 技术。</p><p>在计算机操作系统中，用户空间(<code>user space</code>)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(<code>kernel space</code>)缓冲区(<code>OS Buffer</code>)。因此，<code>redo log buffer</code>写入<code>redo log file</code>实际上是先写入<code>OS Buffer</code>，然后再通过系统调用<code>fsync()</code>将其刷到<code>redo log file</code>中，过程如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc4395ebadf4dbd87e1c64a6bdb68e0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>mysql</code>支持三种将<code>redo log buffer</code>写入<code>redo log file</code>的时机，可以通过<code>innodb_flush_log_at_trx_commit</code>参数配置，各参数值含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>事务提交时不会将<code>redo log buffer</code>中日志写入到<code>os buffer</code>，而是每秒写入<code>os buffer</code>并调用<code>fsync()</code>写入到<code>redo log file</code>中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</td></tr><tr><td>1（实时写，实时刷）</td><td>事务每次提交都会将<code>redo log buffer</code>中的日志写入<code>os buffer</code>并调用<code>fsync()</code>刷到<code>redo log file</code>中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次提交都仅写入到<code>os buffer</code>，然后是每秒调用<code>fsync()</code>将<code>os buffer</code>中的日志写入到<code>redo log file</code>。</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfbc08983004721bfa445ea3cc9777d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a>redo log记录形式</h2><p>前面说过，<code>redo log</code>实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此<code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd580611e99442a8037c9b5f0b519bc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>同时我们很容易得知，<strong>在innodb中，既有redo log需要刷盘，还有数据页也需要刷盘，redo log存在的意义主要就是降低对数据页刷盘的要求</strong>。在上图中，<code>write pos</code>表示<code>redo log</code>当前记录的<code>LSN</code>(逻辑序列号)位置，<code>check point</code>表示<strong>数据页更改记录</strong>刷盘后对应<code>redo log</code>所处的<code>LSN</code>(逻辑序列号)位置。<code>write pos</code>到<code>check point</code>之间的部分是<code>redo log</code>空着的部分，用于记录新的记录；<code>check point</code>到<code>write pos</code>之间是<code>redo log</code>待落盘的数据页更改记录。当<code>write pos</code>追上<code>check point</code>时，会先推动<code>check point</code>向前移动，空出位置再记录新的日志。</p><p>启动<code>innodb</code>的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为<code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如<code>binlog</code>)要快很多。 重启<code>innodb</code>时，首先会检查磁盘中数据页的<code>LSN</code>，如果数据页的<code>LSN</code>小于日志中的<code>LSN</code>，则会从<code>checkpoint</code>开始恢复。 还有一种情况，在宕机前正处于<code>checkpoint</code>的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的<code>LSN</code>大于日志中的<code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p><h2 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h2><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>文件大小</td><td><code>redo log</code>的大小是固定的。</td><td><code>binlog</code>可通过配置参数<code>max_binlog_size</code>设置每个<code>binlog</code>文件的大小。</td></tr><tr><td>实现方式</td><td><code>redo log</code>是<code>InnoDB</code>引擎层实现的，并不是所有引擎都有。</td><td><code>binlog</code>是<code>Server</code>层实现的，所有引擎都可以使用 <code>binlog</code>日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>适用场景</td><td><code>redo log</code>适用于崩溃恢复(crash-safe)</td><td><code>binlog</code>适用于主从复制和数据恢复</td></tr></tbody></table><p>由<code>binlog</code>和<code>redo log</code>的区别可知：<code>binlog</code>日志只用于归档，只依靠<code>binlog</code>是没有<code>crash-safe</code>能力的。但只有<code>redo log</code>也不行，因为<code>redo log</code>是<code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要<code>binlog</code>和<code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>数据库事务四大特性中有一个是<strong>原子性</strong>，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。实际上，<strong>原子性</strong>底层就是通过<code>undo log</code>实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条<code>INSERT</code>语句，对应一条<code>DELETE</code>的<code>undo log</code>，对于每个<code>UPDATE</code>语句，对应一条相反的<code>UPDATE</code>的<code>undo log</code>，这样在发生错误时，就能回滚到事务之前的数据状态。同时，<code>undo log</code>也是<code>MVCC</code>(多版本并发控制)实现的关键，这部分内容在<a href="https://juejin.im/post/6855129007336521741">面试中的老大难-mysql事务和锁，一次性讲清楚！</a>中有介绍，不再赘述。</p><p>参考：</p><p><a href="https://juejin.cn/post/6844903662888697864">https://juejin.cn/post/6844903662888697864</a></p><p><a href="https://juejin.cn/post/6860252224930070536">https://juejin.cn/post/6860252224930070536</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL explain详解</title>
      <link href="2021/01/17/database/mysql/mysql-explain%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/01/17/database/mysql/mysql-explain%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="explain简单示例"><a href="#explain简单示例" class="headerlink" title="explain简单示例"></a>explain简单示例</h1><p>创建数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` ( </span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">    KEY `idx_name` (`NAME`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t_user_balance` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  uid <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  balance <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`),</span><br><span class="line">  KEY `idx_uid` (`uid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;yangl&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;zhangsan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;lisi&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;wangwu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user_balance <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user_balance <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user_balance <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_user_balance <span class="keyword">values</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure><p>查看 explain 结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT * FROM t_user AS tuser, t_user_balance AS usba WHERE 1 AND tuser.id = 1 AND tuser.id = usba.uid;</span></span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | tuser | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | usba  | ref   | idx_uid       | idx_uid | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">2 rows in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h1 id="explain结果列说明"><a href="#explain结果列说明" class="headerlink" title="explain结果列说明"></a>explain结果列说明</h1><h2 id="【id列-】"><a href="#【id列-】" class="headerlink" title="【id列 】"></a>【id列 】</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from ( select id from t_user) as tmp;</span></span><br><span class="line">+----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL          | NULL    | NULL    | NULL |    4 | NULL        |</span><br><span class="line">|  2 | DERIVED     | t_user     | index | NULL          | PRIMARY | 4       | NULL |    4 | Using index |</span><br><span class="line">+----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>id 列是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。</li><li>id 的顺序是按 select 出现的顺序增长的。</li><li>id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id列的值为NULL最后执行。</li></ul><h2 id="【select-type列-】"><a href="#【select-type列-】" class="headerlink" title="【select_type列 】"></a>【select_type列 】</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from ( select * from t_user) as tmp UNION select * from t_user;</span></span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">| id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |</span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | &lt;derived2&gt; | ALL  | NULL          | NULL | NULL    | NULL |    4 | NULL            |</span><br><span class="line">|    2 | DERIVED      | t_user     | ALL  | NULL          | NULL | NULL    | NULL |    4 | NULL            |</span><br><span class="line">|    3 | UNION        | t_user     | ALL  | NULL          | NULL | NULL    | NULL |    4 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,3&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |</span><br><span class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">4 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>select_type 列的值标明查询的类型：<ul><li><code>simple</code> ：简单select（不使用union或子查询）。</li><li><code>primary</code> ：最外面的select。</li><li><code>union</code> ：union中的第二个或后面的select语句。</li><li><code>dependent union</code> ：union中的第二个或后面的select语句，取决于外面的查询。</li><li><code>union result</code> ：union的结果。</li><li><code>subquery</code> ：子查询中的第一个select。</li><li><code>dependent subquery</code> ：子查询中的第一个select，取决于外面的查询。</li><li><code>derived</code> ：导出表的select（from子句的子查询）。</li></ul></li></ul><h2 id="【table列-】"><a href="#【table列-】" class="headerlink" title="【table列 】"></a>【table列 】</h2><p>table 列的结果表明当前行对应的 select 正在访问哪个表。</p><ul><li>当查询的子句中有子查询时， table 列是格式，表示当前的 select 依赖 id=N 结果行对应的查询，要先执行 id 序号 = N 的查询。</li><li>当存在 union 时，UNION RESULT 的 table 列的值为 &lt; unionN1 , N2 &gt; ， N1 和 N2 表示参与 union 的 select 行的 id 序号。</li></ul><h2 id="【type列-】"><a href="#【type列-】" class="headerlink" title="【type列 】"></a>【type列 】</h2><ul><li><p> type 列的结果表明当前行对应的 select 的关联类型或访问类型，也就是优化器决定怎么查找数据表中的行，以及查找数据行记录的大概范围。</p></li><li><p>该列的取值优化程度的优劣，从最优到最差依次为：null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。一般来说，要保证查询达到 range 级别，最好达到 ref 。</p><ul><li><p>null：不需要查表，直接通过索引就能查出结果</p></li><li><p>system：系统表，少量数据，往往不需要进行磁盘IO</p></li><li><p>const：常量连接</p></li><li><p>eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描</p></li><li><p>ref：非主键非唯一索引等值扫描</p></li><li><p>range：范围扫描</p></li><li><p>index：索引树扫描</p></li><li><p>ALL：全表扫描(full table scan)</p></li></ul></li></ul><h3 id="1、null"><a href="#1、null" class="headerlink" title="1、null"></a>1、null</h3><ul><li>MySQL 优化器在优化阶段分解查询语句，在优化过程中就已经可以得到结果，那么在执行阶段就不用再访问表或索引。</li><li>这时的函数 min ，在索引列 user_id 中选取最小值，可以直接查找索引来完成 ， 不需要执行时再访问数据表。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select min(id) from t_user;</span></span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                        |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Select tables optimized away |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、const-和-system"><a href="#2、const-和-system" class="headerlink" title="2、const 和 system"></a>2、const 和 system</h3><ul><li>const 出现在用 primary key （主键） 或 unique key （唯一键） 的所有列与常数比较时，优化器对查询进行优化并将其部分查询转化成一个常量。最多有一个匹配行，读取1次，速度非常快。</li><li>而system是const的特例，表中数据只有一条匹配时为system。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from ( select id from t_user <span class="built_in">where</span> id = 1) as tmp;</span></span><br><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 | NULL        |</span><br><span class="line">|  2 | DERIVED     | t_user     | const  | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |</span><br><span class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="3、eq-ref"><a href="#3、eq-ref" class="headerlink" title="3、eq_ref"></a>3、eq_ref</h3><ul><li>primary key（主键）或 unique key（唯一键） 索引的所有构成部分被join使用 ，只会返回一条符合条件的数据行。这是仅次于const的连接类型。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT * FROM t_user_balance AS usba LEFT JOIN t_user AS tuser on tuser.id = usba.uid;</span></span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                       | rows | Extra |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | usba  | ALL    | NULL          | NULL    | NULL    | NULL                      |    1 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | tuser | eq_ref | PRIMARY       | PRIMARY | 4       | test_transaction.usba.uid |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="4、ref"><a href="#4、ref" class="headerlink" title="4、ref"></a>4、ref</h3><ul><li> ref 与 eq_ref 相比， ref 类型不是使用 primary key （主键） 或 unique key （唯一键）等唯一索引，而是使用普通索引或者联合唯一性索引的部分前缀，索引和某个值相比较，可能会找到符合条件的多个数据行。</li></ul><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>如下示例，使用的 name 是普通索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user WHERE name = <span class="string">&#x27;yangl&#x27;</span>;</span></span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key      | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | t_user | ref  | idx_name      | idx_name | 153     | const |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h4 id="关联表查询"><a href="#关联表查询" class="headerlink" title="关联表查询"></a>关联表查询</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT * FROM t_user_balance AS usba LEFT JOIN t_user AS tuser on tuser.id = usba.uid;</span></span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">| id | select_type | table | type   | possible_keys | key     | key_len | ref                       | rows | Extra |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | usba  | ALL    | NULL          | NULL    | NULL    | NULL                      |    4 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | tuser | eq_ref | PRIMARY       | PRIMARY | 4       | test_transaction.usba.uid |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+</span><br><span class="line">2 rows in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="5、range"><a href="#5、range" class="headerlink" title="5、range"></a>5、range</h3><ul><li>出现在 in(),between ,&gt; ,&lt;, &gt;= 等操作符中。使用一个索引来查询给定范围的行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user <span class="built_in">where</span> id &gt; 3;</span></span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="6、index"><a href="#6、index" class="headerlink" title="6、index"></a>6、index</h3><ul><li>扫描全表索引（ index 是从索引中读取的，所有字段都有索引，而 all 是从硬盘中读取），比ALL要快。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user ;</span></span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user | index | NULL          | idx_name | 153     | NULL |    4 | Using index |</span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="7、all"><a href="#7、all" class="headerlink" title="7、all"></a>7、all</h3><p>即全表扫描，需要从头到尾去查找所需要的行。一般这种情况下这需要增加索引来进行查询优化了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user_balance;</span></span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | ALL  | NULL          | NULL | NULL    | NULL |    4 | NULL  |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h2 id="【possible-keys-列】"><a href="#【possible-keys-列】" class="headerlink" title="【possible_keys 列】"></a>【possible_keys 列】</h2><ul><li>这一列的结果表明查询可能使用到哪些索引。但有些时候也会出现出现 possible_keys 列有结果，而 后面的 key 列显示 null 的情况，这是因为此时表中数据不多，优化器认为查询索引对查询帮助不大，所以没有走索引查询而是进行了全表扫描。</li></ul><ul><li>如果 possible_keys 列的结果是 null ，则表明没有相关的索引。这时，<strong>可以通过优化 where 子句，增加恰当的索引来提升查询性能</strong>。</li></ul><h2 id="【key-列】"><a href="#【key-列】" class="headerlink" title="【key 列】"></a>【key 列】</h2><ul><li>这一列表明优化器实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 null。</li></ul><h2 id="【key-len-列】"><a href="#【key-len-列】" class="headerlink" title="【key_len 列】"></a>【key_len 列】</h2><ul><li><p>这一列表明了在索引里使用的字节数，通过这个值可以大致估算出具体使用了联合索引中的前几个列。</p></li><li><p>key_len计算规则这里不再赘述，不同的数据类型所占的字节数是不一致的。</p></li></ul><h2 id="【ref-列】"><a href="#【ref-列】" class="headerlink" title="【ref 列】"></a>【ref 列】</h2><ul><li>这一列表明了在 key 列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名，如user.user_id</li></ul><h2 id="【rows-列】"><a href="#【rows-列】" class="headerlink" title="【rows 列】"></a>【rows 列】</h2><ul><li>这一列表明优化器大概要读取并检测的行数。跟实际的数据行数大部分情况是不一致的。</li></ul><h2 id="【Extra-列】"><a href="#【Extra-列】" class="headerlink" title="【Extra 列】"></a>【Extra 列】</h2><blockquote><p> 顾名思义，这一列表明的是额外信息，<strong>这一列的取值对优化SQL非常有参考意义</strong>。常见的重要取值如下：</p></blockquote><h3 id="using-index"><a href="#using-index" class="headerlink" title="using index"></a>using index</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user ;</span></span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user | index | NULL          | idx_name | 153     | NULL |    4 | Using index |</span><br><span class="line">+----+-------------+--------+-------+---------------+----------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>所有被查询的字段都是索引列(称为覆盖索引),并且where条件是索引的前导列，出现这样的结果，是性能高的表现。</li></ul><h3 id="using-where"><a href="#using-where" class="headerlink" title="using where"></a>using where</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user_balance <span class="built_in">where</span> balance = 110;</span></span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | ALL  | NULL          | NULL | NULL    | NULL |    4 | Using where |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>被查询的列未被索引覆盖，where条件也并非索引的前导列，表示 MySQL 执行器从存储引擎接收到查询数据,再进行“后过滤”（Post-filter）。所谓“后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。</li></ul><h3 id="using-where-Using-index"><a href="#using-where-Using-index" class="headerlink" title="using where Using index"></a>using where Using index</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user WHERE name = <span class="string">&#x27;yangl&#x27;</span>;</span></span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key      | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | t_user | ref  | idx_name      | idx_name | 153     | const |    1 | Using where; Using index |</span><br><span class="line">+----+-------------+--------+------+---------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>被查询的列被索引覆盖，并且where条件是索引列之一但是不是索引的前导列，也就是没有办法直接通过索引来查询到符合条件的数据</li></ul><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select * from t_user_balance <span class="built_in">where</span> id = 1;</span></span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table          | type  | possible_keys | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>被查询的列没有被索引覆盖，但 where 条件是索引的前导列，此时用到了索引，但是部分列未被索引覆盖，必须通过“回表查询”来实现，不是纯粹地用到了索引，也不是完全没用到索引</li></ul><h3 id="using-index-condition"><a href="#using-index-condition" class="headerlink" title="using index condition"></a>using index condition</h3><p>与 using where 类似，查询的列不完全被索引覆盖，where 条件中是一个前导列的范围；这种情况未能通过示例显现，可能跟MySQL版本有关系。</p><h3 id="using-temporary"><a href="#using-temporary" class="headerlink" title="using temporary"></a>using temporary</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select distinct balance from t_user_balance;</span></span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows | Extra           |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | ALL  | NULL          | NULL | NULL    | NULL |    4 | Using temporary |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+-----------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><p>这表明需要通过创建临时表来处理查询。出现这种情况一般是要进行优化的，用索引来优化。创建临时表的情况：distinct，group by，orderby，子查询等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select distinct id from t_user_balance; -- id 是索引列</span></span><br><span class="line">+----+-------------+----------------+-------+-----------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table          | type  | possible_keys   | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+----------------+-------+-----------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | index | PRIMARY,idx_uid | idx_uid | 4       | NULL |    4 | Using index |</span><br><span class="line">+----+-------------+----------------+-------+-----------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><h3 id="usingfilesort"><a href="#usingfilesort" class="headerlink" title="usingfilesort"></a>usingfilesort</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select balance from t_user_balance  order by balance asc;</span></span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows | Extra          |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | ALL  | NULL          | NULL | NULL    | NULL |    4 | Using filesort |</span><br><span class="line">+----+-------------+----------------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>在使用 order by 的情况下出现，mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时 mysql 会根据连接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下要考虑使用索引来优化的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN select id from t_user_balance order by id asc; -- id 是索引列</span></span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table          | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t_user_balance | index | NULL          | PRIMARY | 4       | NULL |    4 | Using index |</span><br><span class="line">+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/yycc/p/7338894.html">https://www.cnblogs.com/yycc/p/7338894.html</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/"/>
      <url>2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p><strong>索引是存储引擎用于快速找到记录的一种数据结构</strong>。</p><blockquote><p>举例说明：如果查找一本书中的某个特定主题，一般会先看书的目录（类似索引），找到对应页面。在MySQL，存储引擎采用类似的方法使用索引，高效获取查找的数据。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="索引从实现上说"><a href="#索引从实现上说" class="headerlink" title="索引从实现上说"></a>索引从实现上说</h3><ul><li><p>聚集索引：找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。</p></li><li><p>非聚集索引（也叫二级索引或者辅助索引）：索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。</p></li></ul><h3 id="从功能上说"><a href="#从功能上说" class="headerlink" title="从功能上说"></a>从功能上说</h3><ul><li>普通索引：最基本的索引，没有任何约束。</li><li>唯一索引：与普通索引类似，但具有唯一性约束。</li><li>主键索引：特殊的唯一索引，不允许有空值。</li><li>复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</li><li>外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</li><li>全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。</li></ul><blockquote><p><strong>注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。</strong></p><p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。</p><p>简单点说：</p><p>1、设置主键时，会自动生成一个唯一索引，如果<strong>之前</strong>没有聚集索引，那么主键就是聚集索引。</p><p>2、没有设置主键时，会选择一个不为空的唯一索引作为聚集索引，如果还没有，那就生成一个隐式的 6 字节的索引。</p><p>MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似。</p></blockquote><h1 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h1><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><ul><li><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li><p>无法用于排序与分组；</p></li><li><p>只支持精确查找，无法用于部分查找和范围查找。</p></li></ul></li><li><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p></li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><ul><li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</li><li>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</li><li>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</li><li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li></ul><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><ul><li>是大多数 MySQL 存储引擎的默认索引类型。</li><li>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</li><li>除了用于查找，还可以用于排序和分组。</li><li>可以指定多个列作为索引列，多个索引列共同组成键。</li><li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li><li>InnoDB 的 B+Tree 索引分为主索引和辅助索引。<strong>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。</strong>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</li><li><strong>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</strong></li></ul><h3 id="b-tree数据结构"><a href="#b-tree数据结构" class="headerlink" title="b-tree数据结构"></a>b-tree数据结构</h3><blockquote><ul><li><strong>规则：</strong></li></ul><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的关键字数量大于等于 ceil(m/2 ) - 1 个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p></blockquote><p><img src="/2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/b-tree.jpg" alt="preview"></p><h3 id="b-tree数据结构-1"><a href="#b-tree数据结构-1" class="headerlink" title="b+-tree数据结构"></a>b+-tree数据结构</h3><blockquote><ul><li><strong>规则</strong></li></ul><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p><p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p></blockquote><p><img src="/2021/01/17/database/mysql/mysql-%E7%B4%A2%E5%BC%95/b+-tree.png" alt="img"></p><h1 id="MySQL是如何存储索引和数据的"><a href="#MySQL是如何存储索引和数据的" class="headerlink" title="MySQL是如何存储索引和数据的"></a>MySQL是如何存储索引和数据的</h1><p>Innodb 创建表后生成的文件有：</p><ul><li>frm：创建表的语句</li><li>idb：表里面的数据+索引文件</li></ul><p>Myisam 创建表后生成的文件有</p><ul><li>frm：创建表的语句</li><li>MYD：表里面的数据文件（myisam data）</li><li>MYI：表里面的索引文件（myisam index）</li></ul><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/142139541">https://zhuanlan.zhihu.com/p/142139541</a></p><p><a href="https://zhuanlan.zhihu.com/p/60492217">https://zhuanlan.zhihu.com/p/60492217</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务</title>
      <link href="2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/"/>
      <url>2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要事务"><a href="#为什么要事务" class="headerlink" title="为什么要事务"></a>为什么要事务</h1><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><ul><li><p>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库在异常状态下仍能保持一致性的方法。</p></li><li><p>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，保证彼此的操作互相干扰。</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>​        简单的说，事务就是一组原子性的 SQL 查询，这一组 SQL 要么全部执行成功，要么全部执行失败。</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><ul><li><p><strong>原子性</strong>：一个事务是不可分割的最小工作单元，整个事务要么全部成功，要么全部失败，不可能只执行中间的一部分操作。</p></li><li><p><strong>一致性</strong>：执行事务是使得数据库从一个一致性状态到另一个一致性状态，如果事务最终没有被提交，那么事务所做的修改也不会保存到数据库中。</p></li><li><p><strong>隔离性</strong>：通常来说，一个事务提交之前对其他事务是不可见的，但是这里所说的不可见需要考虑隔离级别，比如未提交读在提交前对于其他事务来说也是可见的，隔离级别，在下面会详细讲。</p></li><li><p><strong>持久性</strong>：事务一旦被提交，那么对数据库的修改会被永久的保存，即使数据库崩溃修改后的数据也不会丢失。</p></li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读 ( Read uncommited )</td><td>√</td><td>√</td><td>√</td></tr><tr><td>已提交读 ( Read commited )</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读 ( Repeatable read )</td><td>×</td><td>×</td><td>√</td></tr><tr><td>串行化 ( Serializable )</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li><p>多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。<strong>SQL 标准中定义了四种隔离级别</strong>，这里简单介绍一下这四种隔离级别。</p><ul><li><strong>未提交读</strong>：未提交读的意思是，事务中的修改，即使没有提交，对其他事务也都是可见的，但是这样会出现脏读，一般情况下，通常都不会使用未提交读。</li><li><strong>提交读</strong>：提交读的意思是，一个事务所做的修改在提交之前对其他事务都是不可见的，这个级别也叫做“不可重复读”，因为执行两次相同的操作，可能会得到不同的结果。</li><li><strong>可重复读</strong>：可重复读解决了脏读的问题，这个级别保证了同一个事务多次读取同样记录的结果是一致的，但是这个隔离级别无法解决幻读的问题，所谓幻读就是说，当某个事务读取范围数据时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围数据时，会产生幻行。InnoDB 存储引擎通过 MVCC 解决了幻读的问题，可重复读是 MySQL 默认的事务隔离级别。</li><li><strong>可串行化</strong>：是最高的隔离级别，避免了前面说到的幻读问题。可串行化会给读取的每一行都加锁，所以可能导致大量超时和锁争用的问题，实际中很少使用这个隔离级别。</li></ul></li><li><p>事务不考虑隔离性可能会引发的问题</p><ul><li><strong>脏读</strong>：指一个事务读取了另外一个事务未提交的数据</li><li><strong>不可重复读</strong>：指在一个事务内读取表中的某一行数据，多次读取结果不同。</li><li>**虚读(幻读)**：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</li></ul></li></ul><h2 id="MySQL-数据库中操作事务的命令"><a href="#MySQL-数据库中操作事务的命令" class="headerlink" title="MySQL 数据库中操作事务的命令"></a>MySQL 数据库中操作事务的命令</h2><ul><li>开启事务：start transaction</li><li>提交事务：commit </li><li>回滚事务：rollback </li></ul><blockquote><ul><li>默认情况下， MySQL 事务是自动提交（Autocommit）的，若果需要明确的 Commit 和 Rollback 来提交和回滚事务，那么就需要明确的事务控制命令来开始事务。</li><li>SET AUTOCOMMIT 可以修改当前连接的提交方式，如果设置了 set autocommi t= 0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。</li><li>如果只是对某些语句需要进行事务控制，则使用 start transaction 语句开始一个事务比较方便，这样事务结束之后可以自动回到自动提交的方式，如果希望所有的事务都不是自动提交的，那么通过修改 AUTOCOMMIT 来控制事务比较方便，这样不用在每个事务开始的时候再执行 start transaction。</li></ul></blockquote><h2 id="事务隔离级别验证"><a href="#事务隔离级别验证" class="headerlink" title="事务隔离级别验证"></a>事务隔离级别验证</h2><h3 id="准备表"><a href="#准备表" class="headerlink" title="准备表"></a>准备表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建账户表</span><br><span class="line">CREATE TABLE &#96;t_account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;money&#96; float DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>验证事务隔离级别可能需要用到的 sql 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-- 设置 RU（未提交读）</span><br><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">-- 设置 RC（已提交读）</span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line">-- 设置 RR（可重复读）</span><br><span class="line">set session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line">select @@session.tx_isolation;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">commit;</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">-- 查询与关闭事务自动提交</span><br><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line">set @@autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">select * from t_account;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;1&#39;, &#39;A&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;2&#39;, &#39;B&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (&#39;3&#39;, &#39;C&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br><span class="line">UPDATE t_account set money &#x3D; money - 100 where id &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="未提交读（RU）"><a href="#未提交读（RU）" class="headerlink" title="未提交读（RU）"></a>未提交读（RU）</h3><table><thead><tr><th align="left">会话1</th><th align="left">会话2</th></tr></thead><tbody><tr><td align="left">设置隔离级别</td><td align="left">设置隔离级别</td></tr><tr><td align="left">开启事务</td><td align="left">开启事务</td></tr><tr><td align="left"></td><td align="left">查询表数据（结果为空）</td></tr><tr><td align="left">插入数据</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">查询表数据（有 “会话1” 的插入结果）</td></tr><tr><td align="left">回滚事务</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">查询数据（结果为空）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611658431742.png" alt="1611658431742"></p><blockquote><p>小结：</p><p>​        在RU模式下，一个事务可以读取到另一个未提交事务的数据，导致了脏读。如果另一个事务回滚了，就会造成数据的不一致性。RU是事务隔离级别中最低的。</p></blockquote><h3 id="读提交（RC）"><a href="#读提交（RC）" class="headerlink" title="读提交（RC）"></a>读提交（RC）</h3><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>设置隔离级别</td><td>设置隔离级别</td></tr><tr><td>开启事务</td><td>开启事务（先开启事务）</td></tr><tr><td>查询数据</td><td>查询数据</td></tr><tr><td>修改数据</td><td></td></tr><tr><td>查询数据（数据改变）</td><td>查询数据（数据无改变）</td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>查询数据（数据改变）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611659480293.png" alt="1611659480293"></p><blockquote><p>小结：</p><p>​        在RC模式下，我们发现，当另一个事务没有提交数据修改时，当前事务时读不到修改后的数据的，这就避免了读未提交模式的脏读。但有一个问题，在当前事务中，两次select的数据不一样，这就存在了不可重复读的问题。</p><p>​        PS：RC隔离级别是Oracle数据库默认的隔离级别。</p></blockquote><h3 id="可重复读（RR）"><a href="#可重复读（RR）" class="headerlink" title="可重复读（RR）"></a>可重复读（RR）</h3><table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>设置隔离级别</td><td>设置隔离级别</td></tr><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>查询数据</td><td>查询数据</td></tr><tr><td>修改数据</td><td></td></tr><tr><td></td><td>查询数据（数据无改变）</td></tr><tr><td>修改数据</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>查询数据（数据无改变）</td></tr><tr><td></td><td>提交事务</td></tr><tr><td></td><td>查询数据（数据改变）</td></tr></tbody></table><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611645479829.png" alt="1611645479829"></p><blockquote><p>小结：</p><p>​        在 RR 模式下，我们解决了不可重复读的问题，即在这种隔离级别下，一个事务中我们能够保证获取一样的数据（即使有其他事务正在改当前的数据行）。但是无法避免幻读，<strong>幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致</strong>但是不同数据库对不同的RR级别有不同的实现，有时候加上间隙锁来避免幻读。</p></blockquote><h3 id="InnoDB解决了幻读"><a href="#InnoDB解决了幻读" class="headerlink" title="InnoDB解决了幻读"></a>InnoDB解决了幻读</h3><blockquote><p><strong>在RR的隔离级别下</strong>，InnoDB使用MVCC和next-key locks(间隙锁)解决幻读。MVCC解决的是普通读（快照读）的幻读，间隙锁解决的是当前读情况下的幻读。</p></blockquote><h4 id="幻读是什么"><a href="#幻读是什么" class="headerlink" title="幻读是什么"></a>幻读是什么</h4><blockquote><p>​    幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。</p></blockquote><p><strong>以下是修改情况下的幻读问题</strong>： mvcc 默认解决了读情况下的幻读，但是未解决修改情况下的幻读。</p><blockquote><p>幻读现象：事务2中没有id为4的数据，但是能修改成功。</p></blockquote><p><img src="/2021/01/17/database/mysql/mysql-%E4%BA%8B%E5%8A%A1/1611662492067.png" alt="1611662492067"></p><h4 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h4><ul><li>不可重复读：多次读取一条记录，发现该记录中某些列值被修改过。</li><li>幻读：只要是说多次读取一个范围内的记录（包括直接查询所有记录结果或者做聚合统计），发现结果不一致（一般指的是记录增多，记录的减少应该也算是幻读）。</li></ul><h4 id="避免幻读"><a href="#避免幻读" class="headerlink" title="避免幻读"></a>避免幻读</h4><h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><blockquote><ul><li><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事物看到的数据都是一致的。</p></li><li><p>根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p></li></ul></blockquote><h6 id="InnoDB-的-MVCC-实现-隔离级别为可重复读"><a href="#InnoDB-的-MVCC-实现-隔离级别为可重复读" class="headerlink" title="InnoDB 的 MVCC 实现(隔离级别为可重复读)"></a>InnoDB 的 MVCC 实现(隔离级别为可重复读)</h6><p>InnoDB 的 MVCC 通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的<strong>创建时间</strong>，一个保存了行的<strong>过期时间（或者删除时间）</strong>，当然存储的并不是实际的时间值，而是<strong>系统版本号</strong>。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为<strong>事务的版本号</strong>，用来和查询到的每行记录的版本号作对比。下面详细介绍一下在可重复读隔离级别下（RR级别下），MVCC 的具体是如何操作的。</p><blockquote><ul><li><p>系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p></li><li><p>事务版本号：事务开始时的系统版本号。</p></li><li><p>创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值</p></li><li><p>删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值</p></li></ul></blockquote><ul><li><p>SELECT </p><ul><li><p>InnoDB 会根据以下两个条件检查每行记录： </p><ul><li>只查找版本小于或等于事务的系统版本号的行。（这样可以确保事务读取的行，要么是在事务开始前已存在的，要么是事务自身插入或者修改过的）</li><li>行的删除版本要么未定义，要么大于当前事务版本号。（这样可以确保事务读取到的行在事务开始之前未被删除）</li></ul><p>只有符合以上两个条件的记录，才能返回作为查询结果。</p></li></ul></li><li><p>INSERT </p><ul><li>InnoDB 为新插入的每一行保存当前的系统版本号作为行版本号。</li></ul></li><li><p>DELETE </p><ul><li>InnoDB 为删除的每一行保存当前的系统版本号作为行的删除版本号。</li></ul></li><li><p>UPDATE </p><ul><li>InnoDB 新增一条记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li></ul></li></ul><blockquote><p>优点：</p><ol><li>因为有了两个隐藏列来记录数据的状态，所以大多数读操作都可以不加锁</li><li>性能好，同时可以保证读取的数据是正确的</li></ol><p>缺点：</p><ol><li>需要额外的空间记录每行的状态</li><li>需要行状态的维护和检查</li></ol></blockquote><h4 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h4><p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p><ul><li>使用串行化读的隔离级别</li><li>MVCC + next-key locks ： next-key  locks 由 record locks (索引加锁) 和 gap locks (间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li></ul><blockquote><p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p></blockquote><p>参考：</p><p><a href="https://juejin.cn/post/6844903827255066631">https://juejin.cn/post/6844903827255066631</a></p><p><a href="https://juejin.cn/post/6844903994188365831">https://juejin.cn/post/6844903994188365831</a></p><p><a href="https://juejin.cn/post/6844903799534911496">https://juejin.cn/post/6844903799534911496</a></p><p>《高性能MySQL》第三版</p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句执行顺序</title>
      <link href="2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="编写语句顺序"><a href="#编写语句顺序" class="headerlink" title="编写语句顺序"></a>编写语句顺序</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8</span>)  <span class="keyword">SELECT</span> </span><br><span class="line">(<span class="number">9</span>)  <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">1</span>)  <span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">3</span>)  <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">2</span>)  <span class="keyword">ON</span><span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">4</span>)  <span class="keyword">WHERE</span><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">5</span>)  <span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line">(6)  WITH &#123;CUBE|ROLLUP&#125;</span><br><span class="line">(<span class="number">7</span>)  <span class="keyword">HAVING</span><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span><span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">11</span>) LIMIT<span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h1 id="实际查询顺序"><a href="#实际查询顺序" class="headerlink" title="实际查询顺序"></a>实际查询顺序</h1><blockquote><p>可以看到一共有11个步骤，最先执行的是FROM操作，最后执行的是LIMIT操作。<strong>每个操作都会产生一张虚拟表，该虚拟表作为一个处理的输入。这些虚拟表对用户是透明的，只有最后一步生成的虚拟表才会返回给用户</strong>。如果没有在查询中指定某一子句，则将跳过相应的步骤。</p></blockquote><p><strong>具体分析查询处理的各个阶段</strong>：</p><ol><li><strong>FROM</strong>：对 FROM 子句中的左表 <left_table> 和右表 <right_table> 执行笛卡儿积（ Cartesianproduct ），产生虚拟表 VT1</right_table></left_table></li><li><strong>ON</strong>：对虚拟表 VT1 应用 ON 筛选，只有那些符合 <join_condition> 的行才被插入虚拟表 VT2 中</join_condition></li><li><strong>JOIN</strong>：如果指定了 OUTER JOIN （如 LEFT OUTER JOIN 、 RIGHT OUTER JOIN ），那么保留表中未匹配的行作为外部行添加到虚拟表 VT2 中，产生虚拟表 VT3 。如果 FROM 子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止</li><li><strong>WHERE</strong>：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中</where_condition></li><li><strong>GROUP BY</strong>：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5</li><li><strong>CUBE|ROLLUP</strong>：对表VT5进行CUBE或ROLLUP操作，产生表VT6</li><li><strong>HAVING</strong>：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。</having_condition></li><li><strong>SELECT</strong>：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中</li><li><strong>DISTINCT</strong>：去除重复数据，产生虚拟表VT9</li><li><strong>ORDER BY</strong>：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。11）</order_by_list></li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11，并返回给查询用户</li></ol><p>参考：<a href="https://juejin.cn/post/6864555988873707527">https://juejin.cn/post/6864555988873707527</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句执行流程</title>
      <link href="2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语句执行过程详解"><a href="#SQL语句执行过程详解" class="headerlink" title="SQL语句执行过程详解"></a>SQL语句执行过程详解</h1><blockquote><p>当向 MySQL 发送一个请求的时候，MySQL 到底做了什么：</p></blockquote><ol><li>客户端发送一条查询给 MySQL 服务器。</li><li> MySQL 服务器先检查<strong>查询缓存</strong>，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>MySQL 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li><li>MySQL 根据优化器生成的执行计划，再调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端。</li></ol><p><strong>MySQL 架构图</strong></p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1611364747576.png" alt="1611364747576"></p><p><strong>MySQL 语句执行流程</strong></p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1611366694959.png" alt="1611366694959"></p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ol><li><p>MySQL 查询缓存保存查询返回的完整结构。</p></li><li><p>当查询命中该缓存时，MySQL 会立刻返回结果，跳过了解析、优化和执行阶段。  </p></li><li><p>查询缓存系统会跟踪查询中涉及的每个表，如果这些表发生了变化，那么和这个表相关的所有缓存数据都将失效。</p></li><li><p>MySQL 将缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了以下因素，即查询本身、当前要查询的数据库、客户端协议的版本等一些其他可能影响返回结果的信息。</p></li><li><p>当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。</p></li><li><p>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含函数NOW()或者CURRENT_DATE()的查询不会缓存。包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。</p></li><li><p>有一点需要注意， MySQL 并不是会因为查询中包含一个不确定的函数而不检查查询缓存，因为检查查询缓存之前，MySQL 解析查询语句，所以也无法知道语句中是否有不确定的函数。</p></li><li><p>事实则是，如果查询语句中包含任何的不确定的函数，那么其查询结果不会被缓存，因为查询缓存中也无法找到对应的缓存结果。</p></li><li><p>有关查询缓存的配置如下所示。</p><blockquote><ul><li><code>query_cache_type</code> ：是否打开查询缓存。可以设置为 OFF 、 ON 和 DEMAND 。 DEMAND 表示只有在查询语句中明确写明 SQL_CACHE 的语句才会放入查询缓存。</li><li><code>query_cache_size</code> ：查询缓存使用的总内存空间。</li><li><code>query_cache_min_res_unit</code>：在查询缓存中分配内存块时的最小单元。较小的该值可以减少碎片导致的内存空间浪费，但是会导致更频繁的内存块操作。</li><li><code>query_cache_limit</code>：MySQL 能够查询的最大查询结果。如果查询结果大于这个值，则不会被缓存。因为查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后， MySQL 才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除。</li></ul></blockquote></li></ol><p>对查询缓存的优化是数据库性能优化的重要一环。判断流程大致如下图所示。</p><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1652e56415f8dc20" alt="查询缓存判断流程图"></p><p> 缓存命中率可以通过如下公式计算： Qcache_hits / ( Qcache_hits + Com_select ) 来计算。</p><h2 id="解析和预处理"><a href="#解析和预处理" class="headerlink" title="解析和预处理"></a>解析和预处理</h2><ul><li>解析器通过关键字将 SQL 语句进行解析，并生成对应的解析树。MySQL解析器将使用MySQL语法规则验证和解析查询。</li><li>预处理器则根据一些 MySQL 规则进行进一步检查解析树是否合法，例如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</li></ul><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><ul><li>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。</li><li>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条 SQL 语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过 SQL 语句生成执行计划的整个过程，进而可以提高语句的执行速度。</li></ul><p><img src="/2021/01/17/database/mysql/mysql-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1652e56416132c0d" alt="执行计划缓存"></p><blockquote><ul><li><p> MySQL使用基于成本的查询优化器( Cost-Based Optimizer，CBO )。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。</p></li><li><p>优化器会根据优化规则对关系表达式进行转换，这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，然后 CBO 会根据统计信息和代价模型( Cost Model )计算每个执行计划的 Cost，从中挑选 Cost 最小的执行计划。由上可知， CBO 中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响 CBO 选择最优计划。</p></li><li><p>有关优化器的原理十分复杂，这里就不进行详细讲解了，大家可以自行学习。</p></li></ul></blockquote><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><ul><li>在解析和优化阶段， MySQL 将生成查询对应的执行计划， MySQL 的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码。</li></ul><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><ul><li>如果查询可以被缓存，那么 MySQL 在这个阶段也会将结果存放到查询缓存中。</li><li>MySQL 将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时， MySQL 就可以开始向客户端逐步返回结果集了。</li></ul><p>参考：</p><p><a href="https://juejin.cn/post/6844903655439597582">https://juejin.cn/post/6844903655439597582</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot启动流程分析（一）：SpringApplication类初始化过程</title>
      <link href="2021/01/15/java/spring/java-spring-springBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>2021/01/15/java/spring/java-spring-springBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SpringBoot项目的mian函数"><a href="#一、SpringBoot项目的mian函数" class="headerlink" title="一、SpringBoot项目的mian函数"></a>一、SpringBoot项目的mian函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、-SpringBootApplication"><a href="#1、-SpringBootApplication" class="headerlink" title="1、@SpringBootApplication"></a>1、@SpringBootApplication</h2><p>后续 SpringBoot 自动装配中详解</p><h2 id="2、SpringApplication-run-DemoApplication-class-args"><a href="#2、SpringApplication-run-DemoApplication-class-args" class="headerlink" title="2、SpringApplication.run(DemoApplication.class, args);"></a>2、SpringApplication.run(DemoApplication.class, args);</h2><p>根据 <code>run()</code> 方法查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified source using default settings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySource the primary source to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">/* 静态助手，可以使用默认设置从指定的源运行&#123;@link SpringApplication&#125;。 @param primarySource加载的主要源@param args应用程序参数（通常从Java main方法传递）@返回运行中的&#123;@link ApplicationContext&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySources the primary sources to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">/* 静态帮助程序，可用于使用默认设置和用户提供的参数从指定的源运行&#123;@link SpringApplication&#125;。 @param primarySources提供要加载的主要源@param args应用程序参数（通常从Java main方法传递）@returning正在运行的&#123;@link ApplicationContext&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication  的 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/hello-shf/p/10976646.html">https://www.cnblogs.com/hello-shf/p/10976646.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring，SpringMVC，SpringBoot，SpringCloud的理解</title>
      <link href="2021/01/15/java/spring/java-spring-spring-SpringMVC-SpringBoot-SpringCloud/"/>
      <url>2021/01/15/java/spring/java-spring-spring-SpringMVC-SpringBoot-SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><ul><li> Spring 是一个轻量级的控制反转( IoC )和面向切面( AOP )的容器框架。 Spring 使你能够编写更干净、更可管理、并且更易于测试的代码。</li><li> Spring MVC 是 Spring 的一个模块，一个 web 框架。通过 Dispatcher Servle ,  ModelAndView 和 View Resolver ，开发 web 应用变得很容易。主要针对的是网站应用程序或者服务开发—— URL 路由、 Session 、模板引擎、静态 Web 资源等等。</li><li> Spring 配置复杂，繁琐，所以推出了 Spring boot ，约定优于配置，简化了 Spring 的配置流程。</li><li> Spring Cloud 构建于 Spring Boot 之上，是一个关注全局的服务治理框架。</li></ul></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="Spring-VS-SpringMVC"><a href="#Spring-VS-SpringMVC" class="headerlink" title="Spring VS SpringMVC"></a>Spring VS SpringMVC</h2><ul><li><p>Spring 是一个一站式的轻量级的 java 开发框架，核心是控制反转（ IOC ）和面向切面（ AOP ），针对于开发的WEB 层( SpringMVC )、业务层( Ioc )、持久层( jdbcTemplate )等都提供了多种配置解决方案；</p></li><li><p>SpringMVC 是 Spring 基础之上的一个 MVC 框架，主要处理 web 开发的路径映射和视图渲染，属于 Spring 框架中 WEB 层开发的一部分；</p></li></ul><h2 id="SpringMVC-VS-SpringBoot"><a href="#SpringMVC-VS-SpringBoot" class="headerlink" title="SpringMVC VS SpringBoot"></a>SpringMVC VS SpringBoot</h2><ul><li><p> SpringMVC 属于一个企业 WEB 开发的 MVC 框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等， XML、 config 等配置相对比较繁琐复杂；</p></li><li><p> SpringBoot 框架相对于 SpringMVC 框架来说，更专注于开发微服务后台接口，不开发前端视图；</p></li></ul><h2 id="SpringBoot-和-SpringCloud"><a href="#SpringBoot-和-SpringCloud" class="headerlink" title="SpringBoot 和 SpringCloud"></a>SpringBoot 和 SpringCloud</h2><ul><li><p> SpringBoot 使用了默认大于配置的理念，集成了快速开发的 Spring 多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消 xml 配置，是一套快速配置开发的脚手架，能快速开发单个微服务；</p></li><li><p> SpringCloud 大部分的功能插件都是基于 SpringBoot 去实现的， SpringCloud 关注于全局的微服务整合和管理，将多个 SpringBoot 单体微服务进行整合以及管理； SpringCloud 依赖于 SpringBoot 开发，而 SpringBoot 可以独立开发；</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Spring是核心，提供了基础功能；</li><li>Spring MVC 是基于 Spring 的一个 MVC 框架 ；</li><li>Spring Boot 是为简化 Spring 配置的快速开发整合包；</li><li>Spring Cloud 是构建在 Spring Boot 之上的服务治理框架。</li></ul><p>参考：</p><p><a href="https://juejin.cn/post/6844903956284440583">https://juejin.cn/post/6844903956284440583</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired 注解实现原理（Spring的自动装配）</title>
      <link href="2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h1><ul><li>@Autowired 注解是如何实现自动装配的？</li><li>当为类型为 A 的 Bean 装配类型为 B 的属性时，如果此时 Spring 容器中存在多个类型为 B 的 bean ，此时 Spring 是如何处理的？</li><li>自动装配的模型是什么？有哪几种？和 Autowired 注解有什么关联？</li></ul><h1 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h1><ol><li>pom依赖</li><li>配置类 <code>AppConfig</code>，在配置类中指定扫描哪些包下的文件</li><li>定义两个 service 接口以及实现类，然后在 <code>ClassAServiceImpl</code> 中为其注入 <code>ClassBService</code> 的实现类</li><li>启动类 <code>TestApplication</code> ，在启动类中通过调用 <code>getBean()</code> 方法获取到 <code>ClassAService</code> 类，然后调用 <code>find()</code> 方法，在 <code>find()</code> 方法中会打印注入的 <code>ClassBrService</code> 对象</li><li>运行 main() 方法，最终会在 query() 方法中打印出 ClassBService 对象。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 指定扫描哪些包下的文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.yangl.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassAService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassAService;</span><br><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassBService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAServiceImpl</span> <span class="keyword">implements</span> <span class="title">ClassAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassAServiceImpl 注入 ClassBService</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ClassBService classBService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(classBService);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassBService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassBService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassBServiceImpl</span> <span class="keyword">implements</span> <span class="title">ClassBService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yangl.test.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.yangl.test.service.ClassAService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">ClassAService classAService = applicationContext.getBean(ClassAService.class);</span><br><span class="line">classAService.find();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.yangl.test.service.impl.ClassBServiceImpl@453da22c</span><br></pre></td></tr></table></figure></blockquote><h1 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h1><h2 id="3-1、入口，源码分析"><a href="#3-1、入口，源码分析" class="headerlink" title="3.1、入口，源码分析"></a>3.1、入口，源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a constructor, field, setter method, or config method as to be autowired by</span></span><br><span class="line"><span class="comment"> * Spring&#x27;s dependency injection facilities. This is an alternative to the JSR-330</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> javax.inject.Inject&#125; annotation, adding required-vs-optional semantics.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Constructors&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Only one constructor of any given bean class may declare this annotation with the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #required&#125; attribute set to &#123;<span class="doctag">@code</span> true&#125;, indicating &lt;i&gt;the&lt;/i&gt; constructor</span></span><br><span class="line"><span class="comment"> * to autowire when used as a Spring bean. Furthermore, if the &#123;<span class="doctag">@code</span> required&#125;</span></span><br><span class="line"><span class="comment"> * attribute is set to &#123;<span class="doctag">@code</span> true&#125;, only a single constructor may be annotated</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125;. If multiple &lt;i&gt;non-required&lt;/i&gt; constructors declare the</span></span><br><span class="line"><span class="comment"> * annotation, they will be considered as candidates for autowiring. The constructor</span></span><br><span class="line"><span class="comment"> * with the greatest number of dependencies that can be satisfied by matching beans</span></span><br><span class="line"><span class="comment"> * in the Spring container will be chosen. If none of the candidates can be satisfied,</span></span><br><span class="line"><span class="comment"> * then a primary/default constructor (if present) will be used. Similarly, if a</span></span><br><span class="line"><span class="comment"> * class declares multiple constructors but none of them is annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125;, then a primary/default constructor (if present) will be used.</span></span><br><span class="line"><span class="comment"> * If a class only declares a single constructor to begin with, it will always be used,</span></span><br><span class="line"><span class="comment"> * even if not annotated. An annotated constructor does not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Fields&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Fields are injected right after construction of a bean, before any config methods</span></span><br><span class="line"><span class="comment"> * are invoked. Such a config field does not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Methods&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Config methods may have an arbitrary name and any number of arguments; each of</span></span><br><span class="line"><span class="comment"> * those arguments will be autowired with a matching bean in the Spring container.</span></span><br><span class="line"><span class="comment"> * Bean property setter methods are effectively just a special case of such a general</span></span><br><span class="line"><span class="comment"> * config method. Such config methods do not have to be public.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowired Parameters&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Although &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125; can technically be declared on individual method</span></span><br><span class="line"><span class="comment"> * or constructor parameters since Spring Framework 5.0, most parts of the</span></span><br><span class="line"><span class="comment"> * framework ignore such declarations. The only part of the core Spring Framework</span></span><br><span class="line"><span class="comment"> * that actively supports autowired parameters is the JUnit Jupiter support in</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> spring-test&#125; module (see the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di&quot;&gt;TestContext framework&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * reference documentation for details).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Multiple Arguments and &#x27;required&#x27; Semantics&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In the case of a multi-arg constructor or method, the &#123;<span class="doctag">@link</span> #required&#125; attribute</span></span><br><span class="line"><span class="comment"> * is applicable to all arguments. Individual parameters may be declared as Java-8 style</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.Optional&#125; or, as of Spring Framework 5.0, also as &#123;<span class="doctag">@code</span> <span class="doctag">@Nullable</span>&#125;</span></span><br><span class="line"><span class="comment"> * or a not-null parameter type in Kotlin, overriding the base &#x27;required&#x27; semantics.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Autowiring Arrays, Collections, and Maps&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In case of an array, &#123;<span class="doctag">@link</span> java.util.Collection&#125;, or &#123;<span class="doctag">@link</span> java.util.Map&#125;</span></span><br><span class="line"><span class="comment"> * dependency type, the container autowires all beans matching the declared value</span></span><br><span class="line"><span class="comment"> * type. For such purposes, the map keys must be declared as type &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment"> * which will be resolved to the corresponding bean names. Such a container-provided</span></span><br><span class="line"><span class="comment"> * collection will be ordered, taking into account</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.Ordered Ordered&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.Order <span class="doctag">@Order</span>&#125; values of the target</span></span><br><span class="line"><span class="comment"> * components, otherwise following their registration order in the container.</span></span><br><span class="line"><span class="comment"> * Alternatively, a single matching target bean may also be a generally typed</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Collection&#125; or &#123;<span class="doctag">@code</span> Map&#125; itself, getting injected as such.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Not supported in &#123;<span class="doctag">@code</span> BeanPostProcessor&#125; or &#123;<span class="doctag">@code</span> BeanFactoryPostProcessor&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that actual injection is performed through a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; which in turn means that you &lt;em&gt;cannot&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125; to inject references into</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * types. Please consult the javadoc for the &#123;<span class="doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * class (which, by default, checks for the presence of this annotation).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Qualifier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declares whether the annotated dependency is required.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明是否需要带注释的依赖项,默认 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1、AutowiredAnnotationBeanPostProcessor"><a href="#3-1-1、AutowiredAnnotationBeanPostProcessor" class="headerlink" title="3.1.1、AutowiredAnnotationBeanPostProcessor"></a>3.1.1、AutowiredAnnotationBeanPostProcessor</h3><p>由 Autowired 注释可以看到</p><blockquote><p>Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor} class (which, by default, checks for the presence of this annotation)</p><p>请咨询{@link AutowiredAnnotationBeanPostProcessor}类的javadoc（默认情况下，该类检查此注释的存在）。</p></blockquote><p>AutowiredAnnotationBeanPostProcessor 继承关系如下图：</p><p><img src="/2021/01/15/java/spring/java-spring-spring@Autowired%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1611021808079.png" alt="1611021808079"></p><p><strong>可见它间接</strong></p><ul><li><strong>实现 InstantiationAwareBeanPostProcessor ，就具备了实例化前后(而不是初始化前后)管理对象的能力，</strong></li><li><strong>实现了 BeanPostProcessor ，具有初始化前后管理对象的能力，</strong></li><li><strong>实现 BeanFactoryAware ，具备随时拿到 BeanFactory 的能力，</strong></li></ul><p><strong>也就是说这个 AutowiredAnnotationBeanPostProcessor 具备一切后置处理器的能力。</strong></p><h2 id="3-2、源码分析"><a href="#3-2、源码分析" class="headerlink" title="3.2、源码分析"></a>3.2、源码分析</h2><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p><strong>在容器启动，为对象赋值的时候，遇到@Autowired注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是Autowired的原理。</strong></p><p>参考：</p><p><a href="https://juejin.cn/post/6844903957135884295">https://juejin.cn/post/6844903957135884295</a></p><p><a href="https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w">https://mp.weixin.qq.com/s/q6zs7xRjpcB4YxLw6w477w</a></p><p><a href="https://juejin.cn/post/6844904032784515086">https://juejin.cn/post/6844904032784515086</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 的 Controller 是单例还是多例？怎么保证并发的安全</title>
      <link href="2021/01/15/java/spring/java-spring-springController%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84/"/>
      <url>2021/01/15/java/spring/java-spring-springController%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    <strong>controller 默认是单例的，正因为单例所以不是线程安全的</strong>。不要使用非静态的成员变量，否则会发生数据逻辑混乱</p><h1 id="怎么保证并发的安全"><a href="#怎么保证并发的安全" class="headerlink" title="怎么保证并发的安全"></a>怎么保证并发的安全</h1><ul><li>不要在 controller 中定义成员变量。</li><li>万一必须要定义一个非静态成员变量时候，则通过注解 @Scope(“prototype”) ，将其设置为多例模式。</li><li>在 Controller 中使用 ThreadLocal 变量</li></ul><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>Spring bean 作用域有以下5个：</p><p><strong>singleton:</strong> 单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；</p><p><strong>prototype：</strong> 原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；</p><p>（下面是在web项目下才用到的）</p><p><strong>request：</strong> 搞web的大家都应该明白 request 的域了吧，就是每次请求都新产生一个实例，和 prototype 不同就是创建后，接下来的管理，spring 依然在监听；</p><p><strong>session:</strong> 每次会话，同上；</p><p><strong>global session:</strong> 全局的web域，类似于 servlet 中的 application 。</p><p>参考：</p><p><a href="https://juejin.cn/post/6908685222116605965">https://juejin.cn/post/6908685222116605965</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory和FactoryBean的区别</title>
      <link href="2021/01/15/java/spring/java-spring-springBeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>2021/01/15/java/spring/java-spring-springBeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><ul><li><code>BeanFactory</code>：Spring Bean 容器的根接口</li><li><code>FactoryBean</code>：各个对象的工厂接口，如果bean实现了这个接口，它将被用作对象的工厂，而不是直接作为bean实例。</li></ul></blockquote><h1 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a>1、BeanFactory</h1><blockquote><ul><li><p> <strong><code>BeanFacotry</code> 是 Spring 中比较原始的 Factory 。</strong>如 <code>XMLBeanFactory</code> 就是一种典型的 <code>BeanFactory</code> 。原始的 <code>BeanFactory</code> 无法支持 Spring 的许多插件，如 AOP 功能、 Web 应用等。</p></li><li><p> <strong><code>ApplicationContext</code> 接口，它由 <code>BeanFactory</code> 接口派生而来。</strong> <code>ApplicationContext</code> 包含<code>BeanFactory</code> 的所有功能。</p></li></ul></blockquote><h2 id="1-1-源码"><a href="#1-1-源码" class="headerlink" title="1.1 源码"></a>1.1 源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span></span><br><span class="line"><span class="comment">//如果需要得到工厂本身，需要转义</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字，获取在IOC容器中得到bean实例</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean实例的Class类型</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ul><li>从 IoC 容器中获取 Bean ( byName or byType )</li><li>检索 IoC 容器中是否包含指定的 Bean</li><li>判断 Bean 是否为单例</li></ul><h1 id="2、FactoryBean"><a href="#2、FactoryBean" class="headerlink" title="2、FactoryBean"></a>2、FactoryBean</h1><h2 id="2-1源码"><a href="#2-1源码" class="headerlink" title="2.1源码"></a>2.1源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从工厂中获取bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean工厂创建的对象的类型</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean工厂创建的对象是否是单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        从它定义的接口可以看出，<code>FactoryBean </code>表现的是一个工厂的职责。   <strong>即一个 Bean A 如果实现了<code>FactoryBean</code> 接口，那么 A 就变成了一个工厂，根据 A 的名称获取到的实际上是工厂调用 <code>getObject()</code> 返回的对象，而不是 A 本身，如果要获取工厂 A 自身的实例，那么需要在名称前面加上 ‘&amp;’ 符号。</strong></p><ul><li>getObject(‘name’)返回工厂中的实例</li><li>getObject(‘&amp;name’)返回工厂本身的实例</li></ul><p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p><h2 id="2-2、使用场景"><a href="#2-2、使用场景" class="headerlink" title="2.2、使用场景"></a>2.2、使用场景</h2><p>说了这么多，为什么要有 <code>FactoryBean</code> 这个东西呢，有什么具体的作用吗？<br>FactoryBean 在 Spring 中最为典型的一个应用就是用来<strong>创建AOP的代理对象</strong>。</p><p>我们知道 AOP 实际上是 Spring 在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说， AOP 代理对象通过 Java 的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在 Spring 中就是——<code>ProxyFactoryBean</code>。所以， FactoryBean 为我们实例化 Bean 提供了一个更为灵活的方式，我们可以通过 FactoryBean 创建出更为复杂的 Bean 实例。</p><h1 id="3、区别"><a href="#3、区别" class="headerlink" title="3、区别"></a>3、区别</h1><p><code>BeanFactory</code> 是接口，提供了 IoC 容器最基本的形式，给具体的 IoC 容器的实现提供了规范，</p><p><code>FactoryBean</code> 也是接口，为 IoC 容器中 Bean 的实现提供了更加灵活的方式， <code>FactoryBean</code> 在 IoC 容器的基础上给 Bean 的实现加上了一个简单<strong>工厂模式</strong>和<strong>装饰模式</strong>(如果想了解装饰模式参考：修饰者模式(装饰者模式， Decoration ) 我们可以在 getObject() 方法中灵活配置。其实在 Spring 源码中有很多 FactoryBean 的实现类.</p><p><strong>区别：</strong> BeanFactory 是个 Factory ，也就是 IoC 容器或对象工厂， FactoryBean 是个 Bean 。在 Spring 中，<strong>所有的 Bean 都是由 BeanFactory (也就是 IoC 容器)来进行管理的。</strong></p><p>但<strong>对 FactoryBean 而言，这个 Bean 不是简单的 Bean ，而是一个能生产或者修饰对象生成的工厂 Bean ,它的实现与设计模式中的工厂模式和修饰器模式类似</strong></p><blockquote><ul><li><code>BeanFactory</code> 是 Spring 容器的顶层接口， <code>FactoryBean</code> 更类似于用户自定义的工厂接口。</li><li> 他们两个都是个工厂，但 <code>FactoryBean</code> 本质上还是一个 Bean，也归 <code>BeanFactory</code> 管理</li></ul></blockquote><p>参考：</p><p><a href="https://juejin.cn/post/6844903967600836621">https://juejin.cn/post/6844903967600836621</a></p><p><a href="https://juejin.cn/post/6844904099662544903">https://juejin.cn/post/6844904099662544903</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 解决循环依赖的问题</title>
      <link href="2021/01/15/java/spring/java-spring-spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/15/java/spring/java-spring-spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ul><li><p>通常来说，如果问Spring内部如何解决循环依赖，一定是单默认的<strong>单例</strong> Bean 中，属性互相引用的场景</p></li><li><p><strong>原型</strong>( Prototype )的场景是<strong>不支持</strong>循环依赖的，通常会走到 <code>AbstractBeanFactory</code>类中下面的判断，抛出异常</p></li><li><p>构造器的循环依赖，就更不用说了，<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependency-resolution">官方文档</a>都摊牌了，你想让构造器注入支持循环依赖，是不存在的，不如把代码改了。</p></li></ul></blockquote><h1 id="Spring解决循环依赖"><a href="#Spring解决循环依赖" class="headerlink" title="Spring解决循环依赖"></a><strong>Spring</strong>解决循环依赖</h1><p>在 Spring 的 <code>DefaultSingletonBeanRegistry</code> 类中，维护了三个 <strong>Map</strong> ，也就是我们通常说的<strong>三级缓存</strong>（三级缓存并非官方文档描述，只是一种对代码的理解称呼）</p><blockquote><p>个人认为并不能理解为缓存，缓存的最终目的是为了解决性能，而这三个map的目的更多的是标识一个bean的创建状态。</p><p><code>singletonObjects</code> 表示bean已经完整的被创建</p><p><code>singletonFactories</code> 在单例工厂中的表示bean正在被创建</p><p><code>earlySingletonObjects</code> 在early中的表示已经被创建但完整</p></blockquote><ul><li><code>singletonObjects</code> 它是我们最熟悉的朋友，俗称“<strong>单例池</strong>”“<strong>容器</strong>”，缓存创建完成单例Bean的地方。</li><li><code>singletonFactories</code> 映射创建Bean的原始工厂</li><li><code>earlySingletonObjects</code> 映射Bean的<strong>早期</strong>引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为“<strong>Bean</strong>”，只是一个<strong>Instance</strong>.</li></ul><blockquote><p><code>singletonFactories</code>  与 <code>earlySingletonObjects</code> 只是临时保存数据的集合，bean创建完毕后，就会清除里面的内容</p></blockquote><h1 id="循环依赖的本质"><a href="#循环依赖的本质" class="headerlink" title="循环依赖的本质"></a>循环依赖的本质</h1><ol><li>利用缓存识别已经遍历过的节点；</li><li>利用Java引用，先提前设置对象地址，后完善bean；</li></ol><p>参考：<a href="https://juejin.cn/post/6844904122160775176">https://juejin.cn/post/6844904122160775176</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 的生命周期</title>
      <link href="2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h1><p><img src="/2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/162465267a0c2c59" alt="img"></p><p><strong>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</strong></p><ol><li>Spring 启动，查找并加载需要被 Spring 管理的 bean，进行 Bean 的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了 DisposableBean 接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ol><h1 id="Bean-完整的生命周期"><a href="#Bean-完整的生命周期" class="headerlink" title="Bean 完整的生命周期"></a>Bean 完整的生命周期</h1><p><img src="/2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/585cbd557cb14e9b987f874012847d28_tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 的作用域</title>
      <link href="2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>2021/01/13/java/spring/java-spring-springBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-bean的作用域"><a href="#Spring-bean的作用域" class="headerlink" title="Spring bean的作用域"></a>Spring bean的作用域</h2><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><pre><code>什么是 spring bean？    在 Spring 中，那些组成应用程序的主体及由 Spring IoC 容器所管理的对象，被称之为 bean 。简单地讲，bean 就是由 IoC 容器初始化、装配及管理的对象</code></pre><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>singleton（单例模式）</td><td>在 Spring Ioc 容器中仅存在一个 Bean 实例，Bean 以单例方式存在，默认模式下即为单例</td></tr><tr><td>prototype（原型模式）</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用 <code>getBean()</code> 时，相等于执行 <code>new XxxBean()</code></td></tr><tr><td>request（HTTP请求）</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于 <code>WebApplicationContext</code>环境</td></tr><tr><td>session（会话）</td><td>同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同 Bean，仅适用于<code>WebApplicationContext</code> 环境</td></tr><tr><td>globalSession（全局会话）</td><td>一般用于 <code>Portlet</code> 应用环境，该作用域仅适用于 <code>WebApplicationContext</code> 环境</td></tr></tbody></table><p>​        几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于 <code>web的Spring ApplicationContext</code> 环境。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="2021/01/13/java/spring/java-spring-springAOP/"/>
      <url>2021/01/13/java/spring/java-spring-springAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h1><ul><li>AOP是一种编程范式，通过添加切面点，在不改动已有核心逻辑代码的前提下，添加功能或更改代码流程。</li></ul><h1 id="AOP用来做什么？"><a href="#AOP用来做什么？" class="headerlink" title="AOP用来做什么？"></a>AOP用来做什么？</h1><ul><li>我们可以将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非业务逻辑的方法中，进而在这些行为改变的时候不影响业务逻辑的代码</li></ul><h1 id="AOP的两种代理方式"><a href="#AOP的两种代理方式" class="headerlink" title="AOP的两种代理方式"></a>AOP的两种代理方式</h1><ul><li><p>以 AspectJ 为代表的静态代理。</p><blockquote><p>​        静态代理是指 AOP 框架在编译阶段生成 AOP 代理类，因此也称为编译时增强。ApsectJ 是静态代理的实现之一，也是最为流行的。静态代理由于在编译时就生成了代理类，效率相比动态代理要高一些。AspectJ 可以单独使用，也可以和 Spring 结合使用。</p></blockquote></li><li><p>以 Spring AOP 为代表的动态代理。</p><blockquote><p>​        与静态代理不同，动态代理就是说 AOP 框架不会去修改编译时生成的字节码，而是在运行时在内存中生成一个 AOP 代理对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>​        Spring AOP 中的动态代理主要有两种方式：<strong>JDK 动态代理</strong> 和 <strong>CGLIB 动态代理</strong>。</p><p>​        JDK 代理通过反射来处理被代理的类，并且要求被代理类必须实现一个接口。核心类是 <code>InvocationHandler</code> 接口 和 <code>Proxy</code> 类。  </p><p>​        而当目标类没有实现接口时，Spring AOP 框架会使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。</p><p>​        CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code>，那么它是无法使用 CGLIB 做动态代理的。核心类是 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类</p></blockquote></li></ul><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><h2 id="1-切面-Aspect"><a href="#1-切面-Aspect" class="headerlink" title="(1)切面(Aspect)"></a>(1)切面(Aspect)</h2><blockquote><p>​        切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</p></blockquote><ul><li><strong>使用 <code>@Aspect</code> 注解的类就是切面</strong></li></ul><h2 id="2-目标对象-Target"><a href="#2-目标对象-Target" class="headerlink" title="(2) 目标对象(Target)"></a>(2) 目标对象(Target)</h2><blockquote><p>      目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p></blockquote><h2 id="3-连接点-JoinPoint"><a href="#3-连接点-JoinPoint" class="headerlink" title="(3) 连接点(JoinPoint)"></a>(3) 连接点(JoinPoint)</h2><blockquote><p> 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p><ul><li>方法(表示程序执行点，即在哪个目标方法)</li><li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li></ul><p>  简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。</p></blockquote><ul><li>使用 <code>@Before(&quot;pointcut()&quot;)</code> 实现</li></ul><h2 id="4-切入点-PointCut"><a href="#4-切入点-PointCut" class="headerlink" title="(4) 切入点(PointCut)"></a>(4) 切入点(PointCut)</h2><blockquote><p>切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。   </p><p>   一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。</p></blockquote><ul><li>使用 <code>@Pointcut(&quot;execution(* com.yangl.test.aop.service..*(..))&quot;)</code> 实现</li><li>匹配规则是 <code>com.yangl.test.aop.service</code>包下的所有类的所有函数。</li></ul><h2 id="5-通知-Advice"><a href="#5-通知-Advice" class="headerlink" title="(5) 通知(Advice)"></a>(5) 通知(Advice)</h2><blockquote><p>通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before说明这是一个前置通知，log函数中是要前置执行的代码，JoinPoint是连接点，</span></span><br><span class="line"><span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-织入-Weaving"><a href="#6-织入-Weaving" class="headerlink" title="(6) 织入(Weaving)"></a>(6) 织入(Weaving)</h2><blockquote><p>​        织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p></blockquote><h1 id="7-增强器-Adviser"><a href="#7-增强器-Adviser" class="headerlink" title="(7) 增强器(Adviser)"></a>(7) 增强器(Adviser)</h1><p>  Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。  </p><p>  Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractPointcutAdvisor是默认接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Advice advice; <span class="comment">//Advice</span></span><br><span class="line"><span class="keyword">private</span> Pointcut pointcut; <span class="comment">//切入点</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">publicvoidinit() &#123;</span><br><span class="line"><span class="comment">// AnnotationMatchingPointcut 是依据修饰类和方法的注解进行拦截的切入点。</span></span><br><span class="line"><span class="keyword">this</span>.pointcut = newAnnotationMatchingPointcut((Class) <span class="keyword">null</span>, Log.class);</span><br><span class="line"><span class="comment">//通知</span></span><br><span class="line"><span class="keyword">this</span>.advice = newLogMethodInterceptor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IoC</title>
      <link href="2021/01/13/java/spring/java-spring-springIOC/"/>
      <url>2021/01/13/java/spring/java-spring-springIOC/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-IoC"><a href="#什么是-IoC" class="headerlink" title="什么是 IoC"></a>什么是 IoC</h1><ul><li>控制反转，是一种思想，不是一种实现。Java 领域中描述的是对象的创建和管理的问题。</li><li>传统开发，A 中要使用 B 的对象，需要在 A 中 new 出 B 的对象</li><li>IoC 思想实现：不通过 new 关键字来创建对象，而是通过 IoC 容器( Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面获取即可。</li><li>控制 ：指的是对象创建（实例化、管理）的权力</li><li>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</li><li>IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。</li></ul><h1 id="IoC-解决了什么问题"><a href="#IoC-解决了什么问题" class="headerlink" title="IoC 解决了什么问题"></a>IoC 解决了什么问题</h1><p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p><ul><li>对象之间的耦合度或者说依赖程度降低；</li><li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li></ul><h1 id="DI（依赖注入）Dependency-Injection"><a href="#DI（依赖注入）Dependency-Injection" class="headerlink" title="DI（依赖注入）Dependency Injection"></a>DI（依赖注入）Dependency Injection</h1><p>是Ioc的一种实现方式，<strong>3种方式</strong></p><ul><li>构造器注入<ul><li>有参构造</li></ul></li><li>setter方法注入</li><li>接口注入</li></ul><h1 id="Spring-IOC的初始化过程："><a href="#Spring-IOC的初始化过程：" class="headerlink" title="Spring IOC的初始化过程："></a><strong>Spring IOC的初始化过程：</strong></h1><p><img src="/2021/01/13/java/spring/java-spring-springIOC/165fea36b569d4f4" alt="img"></p><ol><li>首先初始化上下文，生成 <code>ClassPathXmlApplicationContext</code> 对象</li><li>再获取 <code>resourcePatternResolver</code> 对象将 <code>xml</code> 解析成 <code>Resource</code> 对象。</li><li>利用1生成的 <code>context</code> 、 <code>resource</code> 初始化工厂，并将 <code>resource</code> 解析成 <code>beandefinition</code> </li><li>再将 <code>beandefinition</code> 注册到 <code>beanfactory</code> 中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务(二)</title>
      <link href="2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/"/>
      <url>2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a>@Transactional 注解使用详解</h1><h2 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a>@Transactional 的作用范围</h2><ul><li>方法 ：推荐将注解使用于方法上，不过需要注意的是：该注解只能应用到 public 方法上，否则不生效。</li><li>类 ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li>接口 ：不推荐在接口上使用。</li></ul><h2 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a>@Transactional 的常用配置参数</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED</td></tr><tr><td>isolation</td><td>事务的隔离级别，默认值采用 DEFAULT</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>readOnly</td><td>指定事务是否为只读事务，默认值为 false。</td></tr><tr><td>rollbackFor</td><td>用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td></tr></tbody></table><h2 id="Transactional-事务注解原理"><a href="#Transactional-事务注解原理" class="headerlink" title="@Transactional 事务注解原理"></a>@Transactional 事务注解原理</h2><ul><li>@Transactional 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</li><li>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</li><li>Spring AOP 自调用问题<ul><li>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有@Transactional 注解的方法的事务会失效。这是由于Spring AOP代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</li><li>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</li></ul></li></ul><h1 id="Transactional注有哪些属性"><a href="#Transactional注有哪些属性" class="headerlink" title="@Transactional注有哪些属性"></a>@Transactional注有哪些属性</h1><h2 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a><strong>propagation属性</strong></h2><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li></ul><h2 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a><strong>isolation 属性</strong></h2><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h2 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a><strong>timeout 属性</strong></h2><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><h2 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a><strong>readOnly 属性</strong></h2><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h2 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a><strong>rollbackFor 属性</strong></h2><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h2 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性"></a><strong>noRollbackFor</strong>属性</h2><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p><h1 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h1><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p><h2 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h2><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。 </p><p><img src="/2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/170f0e025a51a1b4.png" alt="在这里插入图片描述"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p><strong>注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p><h2 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h2><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 <code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 <code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h2 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional  注解属性 rollbackFor 设置错误"></a>3、@Transactional  注解属性 rollbackFor 设置错误</h2><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p><p><img src="/2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%BA%8C)/170f0e025b17b3ca.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span></span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Class&lt;?&gt; exceptionClass, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exceptionClass.getName().contains(<span class="keyword">this</span>.exceptionName)) &#123;</span><br><span class="line">            <span class="comment">// Found it!</span></span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h2><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由<code>Spring</code>生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.insertB();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> insert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h2><p>这种情况是最常见的一种@Transactional注解失效场景，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insert = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h2 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h2><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>@Transactional 注解的看似简单易用，但如果对它的用法一知半解，还是会踩到很多坑的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务(一)</title>
      <link href="2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%B8%80)/"/>
      <url>2021/01/13/java/spring/java-spring-spring%E4%BA%8B%E5%8A%A1(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><ul><li>事务是一组逻辑上的操作，要么都执行，要么都不执行</li><li>事务能否生效需要数据库引擎的支持，比如常用的 MySQL 数据库默认使用支持事务的innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了。</li></ul><h1 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h1><ul><li>原子性：一个事务的操作，要么全部执行，要么全部不执行</li><li>一致性：执行事务前后，数据保持一致</li><li>隔离性：一个事务的执行不受其他事务的影响</li><li>持久性：事务提交后对数据库的影响是永久的</li></ul><h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul><li>多个任务对同一个数据进行操作</li><li>丢失修改：多个事务对同一个数据进行修改，之后的事务修改的结果覆盖了之前的。</li><li><strong>脏读</strong>：一个事务对数据的修改还没有提交，另一个事务就访问使用了这个数据。</li><li><strong>不可重复读</strong>：一个事务多次对一个数据读取，在这个中间另一个事务修改了该数据，导致，前一个前后读取的结果不一样。</li><li><strong>幻读</strong>：前一个事务读了几条记录，后一个事务插入或删除了记录，导致前一个事务再次读的时候数据多了或少了。</li></ul><h1 id="SQL-标准定义了四个隔离级别"><a href="#SQL-标准定义了四个隔离级别" class="headerlink" title="SQL 标准定义了四个隔离级别"></a>SQL 标准定义了四个隔离级别</h1><ul><li>READ-UNCOMMITTED(<strong>读取未提交</strong>)： 最低的隔离级别，<strong>允许读取尚未提交的数据变更</strong>，可能会导致脏读、幻读或不可重复读</li><li>READ-COMMITTED(<strong>读取已提交</strong>): <strong>允许读取并发事务已经提交的数据</strong>，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li>REPEATABLE-READ（<strong>可重读</strong>）: <strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(<strong>可串行化</strong>): 最高的隔离级别，完全服从ACID的隔离级别。<strong>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰</strong>，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><h1 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h1><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><ul><li>通过TransactionTemplate和TransactionManager手动管理事务</li></ul><h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><ul><li>使用 @Transactional注解进行事务管理，基于AOP实现的</li></ul><h1 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h1><ul><li>PlatformTransactionManager： （平台）事务管理器接口，Spring 事务策略的核心。<ul><li>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</li><li>Spring 并不直接管理事务，而是提供了多种事务管理器 。Spring 事务管理器的接口是： PlatformTransactionManager 。通过这个接口，Spring 为各个平台如 JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransactionDefinition： 事务（属性）定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。<ul><li>这个类就定义了一些基本的事务属性</li><li>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>TransactionStatus： 事务运行状态<ul><li>TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TransactionDefinition接口中定义五个隔离级别"><a href="#TransactionDefinition接口中定义五个隔离级别" class="headerlink" title="TransactionDefinition接口中定义五个隔离级别"></a><strong>TransactionDefinition接口中定义五个隔离级别</strong></h1><blockquote><p><strong>ISOLATION_DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别</strong>，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应；</p><p><strong>ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别</strong>，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</p><p><strong>ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取</strong>。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p><p><strong>ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读</strong>。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p><p><strong>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别</strong>。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p></blockquote><ul><li><h1 id="TransactionDefinition接口中定义了七个事务传播行为"><a href="#TransactionDefinition接口中定义了七个事务传播行为" class="headerlink" title="TransactionDefinition接口中定义了七个事务传播行为"></a>TransactionDefinition接口中定义了七个事务传播行为</h1></li></ul><blockquote><p>事务传播行为：</p><ul><li>解决业务层方法之间相互调用的事务问题</li><li>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</li></ul></blockquote><h2 id="TransactionDefinition-PROPAGATION-REQUIRED"><a href="#TransactionDefinition-PROPAGATION-REQUIRED" class="headerlink" title="TransactionDefinition.PROPAGATION_REQUIRED"></a>TransactionDefinition.PROPAGATION_REQUIRED</h2><ul><li>使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。<strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</strong>。也就是说：</li><li>如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被Propagation.REQUIRED的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于<strong>同一事务 ，只要一个方法回滚，整个事务均回滚</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-REQUIRES-NEW"><a href="#TransactionDefinition-PROPAGATION-REQUIRES-NEW" class="headerlink" title="TransactionDefinition.PROPAGATION_REQUIRES_NEW"></a>TransactionDefinition.PROPAGATION_REQUIRES_NEW</h2><ul><li>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW修饰的内部方法会<strong>新开启自己的事务</strong>，且开启的事务相互独立，互不干扰。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NESTED"><a href="#TransactionDefinition-PROPAGATION-NESTED" class="headerlink" title="TransactionDefinition.PROPAGATION_NESTED"></a>TransactionDefinition.PROPAGATION_NESTED</h2><ul><li>如果当前存在事务，则创建一个事务作为当前事务的<strong>嵌套事务</strong>来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li><li>也就是说：在外部方法未开启事务的情况下Propagation.NESTED和Propagation.REQUIRED作用相同，修饰的内部方法都会<strong>新开启自己的事务</strong>，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务的话，Propagation.NESTED修饰的内部方法属于<strong>外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-MANDATORY"><a href="#TransactionDefinition-PROPAGATION-MANDATORY" class="headerlink" title="TransactionDefinition.PROPAGATION_MANDATORY"></a>TransactionDefinition.PROPAGATION_MANDATORY</h2><ul><li>如果当前存在事务，则加入该事务；<strong>如果当前没有事务，则抛出异常</strong>。（mandatory：强制性）</li></ul><h2 id="TransactionDefinition-PROPAGATION-SUPPORTS"><a href="#TransactionDefinition-PROPAGATION-SUPPORTS" class="headerlink" title="TransactionDefinition.PROPAGATION_SUPPORTS"></a>TransactionDefinition.PROPAGATION_SUPPORTS</h2><ul><li>如果当前存在事务，则加入该事务；<strong>如果当前没有事务，则以非事务的方式继续运行</strong>。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NOT-SUPPORTED"><a href="#TransactionDefinition-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="TransactionDefinition.PROPAGATION_NOT_SUPPORTED"></a>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</h2><ul><li><strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起。</li></ul><h2 id="TransactionDefinition-PROPAGATION-NEVER"><a href="#TransactionDefinition-PROPAGATION-NEVER" class="headerlink" title="TransactionDefinition.PROPAGATION_NEVER"></a>TransactionDefinition.PROPAGATION_NEVER</h2><ul><li>以非事务方式运行，<strong>如果当前存在事务，则抛出异常</strong>。</li></ul><h1 id="配置事务的属性"><a href="#配置事务的属性" class="headerlink" title="配置事务的属性"></a>配置事务的属性</h1><blockquote><ul><li>isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</li><li>propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。</li><li>timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</li><li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中concorrentHashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk8-concorrentHashMap/"/>
      <url>2021/01/04/java/map/java-map-jdk8-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中concorrentHashMap源码解析"><a href="#JDK8中concorrentHashMap源码解析" class="headerlink" title="JDK8中concorrentHashMap源码解析"></a>JDK8中concorrentHashMap源码解析</h1><h1 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap()"></a>ConcurrentHashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the default initial table size (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用默认的初始表大小（16）创建一个新的空Map。 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity"><a href="#ConcurrentHashMap-int-initialCapacity" class="headerlink" title="ConcurrentHashMap(int initialCapacity)"></a>ConcurrentHashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment">    * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment">    * to dynamically resize.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个具有初始表大小的新的空映射*容纳指定数量的元素，而无需</span></span><br><span class="line"><span class="comment">    * 动态调整大小。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity该实现执行内部大小调整以容纳许多元素。 </span></span><br><span class="line"><span class="comment">    * 如果元素的初始容量为负，则抛出IllegalArgumentException </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                  MAXIMUM_CAPACITY :</span><br><span class="line">                  tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">       <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment">  * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;) and</span></span><br><span class="line"><span class="comment">  * initial table density (&#123;<span class="doctag">@code</span> loadFactor&#125;).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">  * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment">  * given the specified load factor.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment">  * establishing the initial table size</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">  * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size based on</span></span><br><span class="line"><span class="comment"> * the given number of elements (&#123;<span class="doctag">@code</span> initialCapacity&#125;), table</span></span><br><span class="line"><span class="comment"> * density (&#123;<span class="doctag">@code</span> loadFactor&#125;), and number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads (&#123;<span class="doctag">@code</span> concurrencyLevel&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment"> * performs internal sizing to accommodate this many elements,</span></span><br><span class="line"><span class="comment"> * given the specified load factor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor the load factor (table density) for</span></span><br><span class="line"><span class="comment"> * establishing the initial table size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment"> * updating threads. The implementation may use this value as</span></span><br><span class="line"><span class="comment"> * a sizing hint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment"> * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment"> * nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、put方法"><a href="#2、put方法" class="headerlink" title="2、put方法"></a>2、put方法</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putVal-K-key-V-value-boolean-onlyIfAbsent"><a href="#putVal-K-key-V-value-boolean-onlyIfAbsent" class="headerlink" title="putVal(K key, V value, boolean onlyIfAbsent)"></a>putVal(K key, V value, boolean onlyIfAbsent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果table为空， 初始化table,</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前hash 的位置有没有值，没有值， 直接使使cas 无阻塞设置</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果正在扩容中</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁住单个 node</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检查是否有变更</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个节点hash 值不为0， 意思是当前节点为普通节点的时候， 这里应该比较容易理解， 比较hash 值， key equals 是否相等， 如果hash 冲突就添加链表， 记录链表长度(binCount)，之后会根据长度调整， 是否使用红黑树代替链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek !=   &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 尾插法</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果已经是树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 阀值，默认是8， 超过会转换成树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 转化为 tree</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ol><li>若数组空，则初始化，完成之后，转2</li><li>计算当前桶位是否有值 </li></ol><ul><li>无,则 CAS 创建,失败后继续自旋,直到成功</li><li>有,转3</li></ul><ol start="3"><li>判断桶位是否为转移节点(扩容ing) </li></ol><ul><li>是,则一直自旋等待扩容完成,之后再新增</li><li>否,转4</li></ul><ol start="4"><li>桶位有值,对当前桶位加synchronize锁 </li></ol><ul><li>链表，新增节点到链尾</li><li>红黑树，红黑树版方法新增</li></ul><ol start="5"><li>新增完成之后,检验是否需要扩容</li></ol></blockquote><h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用sizeCtl中记录的大小初始化表 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// sizeCtl: table 初始化和resize的标志位，表初始化和调整大小控件。</span></span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="comment">// sizeCtl为负值时，将初始化或调整表的大小</span></span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin(丢失了初始化竞赛；旋转一下)</span></span><br><span class="line">           <span class="comment">// 设置SIZECTL为-1，设置成功开始初始化， 不成功继续循环。</span></span><br><span class="line">           <span class="comment">// compareAndSwapInt 非阻塞同步原语： arg0, arg1, arg2, arg3 分别为对象实例，目标对象属性，当前预期值，要设的值, 设置成功返回 true, 失败 false</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><p>执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，而其它线程只能通过Thread.yield()让出CPU时间片等待table初始化完成。</p></blockquote><h1 id="3、图解流程"><a href="#3、图解流程" class="headerlink" title="3、图解流程"></a>3、图解流程</h1><p><img src="/2021/01/04/java/map/java-map-jdk8-concorrentHashMap/1610412313108.png" alt="1610412313108"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="jdk7-和-jdk8-的差异"><a href="#jdk7-和-jdk8-的差异" class="headerlink" title="jdk7 和 jdk8 的差异"></a>jdk7 和 jdk8 的差异</h2><ul><li>jdk7 使用 ReentrantLock + segment + hashentry + unsafe</li><li>jdk8 使用 Synchronized + CAS + Node + NodeTree + Unsafe</li></ul><h2 id="jdk8-总结"><a href="#jdk8-总结" class="headerlink" title="jdk8 总结"></a>jdk8 总结</h2><ul><li>jdk8 用 Synchronized + CAS + Node + NodeTree 代替 Segment ，只有在hash 冲突， 或者修改已经值的时候才去加锁， 锁的粒度更小，大幅减少阻塞</li><li>jdk8 链表节点数量大于8时，会将链表转化为红黑树进行存储，查询时间复杂度从O(n)，变成遍历红黑树O(logN)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中concorrentHashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk7-concorrentHashMap/"/>
      <url>2021/01/04/java/map/java-map-jdk7-concorrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中concorrentHashMap源码解析"><a href="#JDK7中concorrentHashMap源码解析" class="headerlink" title="JDK7中concorrentHashMap源码解析"></a>JDK7中concorrentHashMap源码解析</h1><h1 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h1><p>Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦<strong>初始化就不能改变</strong>，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h1 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h1><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default initial capacity for this table,</span></span><br><span class="line"><span class="comment">    * used when not otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认的数组大小16(HashMap里的那个数组)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default load factor for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 扩容因子0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default concurrency level for this table, used when not</span></span><br><span class="line"><span class="comment">    * otherwise specified in a constructor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 默认并发标准16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The minimum capacity for per-segment tables.  Must be a power</span></span><br><span class="line"><span class="comment">    * of two, at least two to avoid immediate resizing on next use</span></span><br><span class="line"><span class="comment">    * after lazy construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 每段表的最小容量。必须为2的幂，至少为2的幂，以免在延迟构造后立即调整下次使用时的大小。*/</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// ConcurrentHashMap中的数组</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="comment">    * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="comment">    * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 段是哈希表的专用版本。该子类是ReentrantLock的机会子类，只是为了简化一些锁定并避免单独构造。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The per-segment table. Elements are accessed via</span></span><br><span class="line"><span class="comment">        * entryAt/setEntryAt providing volatile semantics.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/* 每个细分表。元素通过提供可变语义的entryAtsetEntryAt访问。 */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment">        * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The total number of mutative operations in this segment.</span></span><br><span class="line"><span class="comment">        * Even though this may overflows 32 bits, it provides</span></span><br><span class="line"><span class="comment">        * sufficient accuracy for stability checks in CHM isEmpty()</span></span><br><span class="line"><span class="comment">        * and size() methods.  Accessed only either within locks or</span></span><br><span class="line"><span class="comment">        * among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table is rehashed when its size exceeds this threshold.</span></span><br><span class="line"><span class="comment">        * (The value of this field is always &lt;tt&gt;(int)(capacity *</span></span><br><span class="line"><span class="comment">        * loadFactor)&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The load factor for the hash table.  Even though this value</span></span><br><span class="line"><span class="comment">        * is same for all segments, it is replicated to avoid needing</span></span><br><span class="line"><span class="comment">        * links to outer object.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">       Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">           <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">           <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">           <span class="keyword">this</span>.table = tab;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="comment">    * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* ConcurrentHashMap列表条目。请注意，它永远不会作为用户可见的Map.Entry导出。 */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;</span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。</p><ol><li>必要参数校验。</li><li>校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造**默认值是 16。</li><li>寻找并发级别 concurrencyLevel 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</li><li>记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>。</li><li>记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15。</li><li><strong>初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 20.75=1.5</strong>，插入第二个值时才会进行扩容。</li></ol></blockquote><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap()"></a>ConcurrentHashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with a default initial capacity (16),</span></span><br><span class="line"><span class="comment">    * load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用默认的初始容量（16），</span></span><br><span class="line"><span class="comment">   * 负载因子（0.75）和concurrencyLevel（16）创建一个新的空映射。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity"><a href="#ConcurrentHashMap-int-initialCapacity" class="headerlink" title="ConcurrentHashMap(int initialCapacity)"></a>ConcurrentHashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity,</span></span><br><span class="line"><span class="comment">    * and with default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 创建一个具有指定初始容量，默认负载因子（0.75）和concurrencyLevel（16）的新的空映射。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果元素的初始容量为负，则IllegalArgumentException。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial capacity</span></span><br><span class="line"><span class="comment">    * and load factor and with the default concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment">    * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment">    * elements is negative or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量和负载因子以及默认的concurrencyLevel（16）创建一个新的空映射。 @param initialCapacity该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @throws IllegalArgumentException如果元素的初始容量为负或负载系数为非正值（从1.6开始）*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel"><a href="#ConcurrentHashMap-int-initialCapacity-float-loadFactor-int-concurrencyLevel" class="headerlink" title="ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)"></a>ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">    * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">    * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">    * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">    * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">    * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">    * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">    * nonpositive.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用指定的初始容量，负载因子和并发级别创建一个新的空映射。 @param initialCapacity初始容量。该实现执行内部大小调整以容纳许多元素。 @param loadFactor负载系数阈值，用于控制调整大小。当每个仓的平均元素数超过此阈值时，可以执行大小调整。 @param concurrencyLevelLevel并发更新线程的估计数量。该实现执行内部大小调整以尝试容纳这么多线程。如果初始容量为负，或者负载系数或concurrencyLevel为非正值，则@throws IllegalArgumentException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 参数检验</span></span><br><span class="line">       <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂次方数（例如 concurrencyLevel=16，sshift 则为 4 ）</span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// &gt;= concurrencyLevel 2的幂数（例如 concurrencyLevel=16，ssize 则为 16）</span></span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">           ++sshift;</span><br><span class="line">           <span class="comment">// ssize 右移两位 即 ssize = ssize * 2</span></span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 32 - 4 = 28 (段位移)</span></span><br><span class="line">       <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">       <span class="comment">// 16 - 1 = 15 （段 mask）</span></span><br><span class="line">       <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 计算 segment 段内最小的数组长度，2的幂次方倍</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">       <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">           ++c;</span><br><span class="line">       <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">       <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create segments and segments[0]</span></span><br><span class="line">       <span class="comment">// 创建 segments=Segment[ssize] 数组并初始化 segments[0]</span></span><br><span class="line">       Segment&lt;K,V&gt; s0 =</span><br><span class="line">           <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                            (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">       Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">       UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">       <span class="keyword">this</span>.segments = ss;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li><p>根据 initialCapacity, loadFactor, concurrencyLevel 创建 Segment 数组并初始化 Segment[0]</p></li><li><p>计算出段位移：this.segmentShift = 32 - sshift;</p></li><li><p>计算出段Mask :  this.segmentMask = ssize - 1;</p></li></ul></blockquote><h2 id="ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#ConcurrentHashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new map with the same mappings as the given map.</span></span><br><span class="line"><span class="comment">    * The map is created with a capacity of 1.5 times the number</span></span><br><span class="line"><span class="comment">    * of mappings in the given map or 16 (whichever is greater),</span></span><br><span class="line"><span class="comment">    * and a default load factor (0.75) and concurrencyLevel (16).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 使用与给定map相同的map创建一个新map。创建的映射的容量是给定映射中映射数量的1.5倍或16（最大），默认加载因子（0.75）和concurrencyLevel（16）。map中的@param m */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">            DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">       putAll(m);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、put方法"><a href="#3、put方法" class="headerlink" title="3、put方法"></a>3、put方法</h1><h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment">    * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment">    * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** 将指定的键映射到此表中的指定值。键或值都不能为null。 &lt;p&gt;可以通过使用等于原始键的键调用&lt;tt&gt; get &lt;tt&gt;方法来检索该值。 <span class="doctag">@param</span>与指定值关联的键key @ param与指定键关联的值@返回与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值如果指定的键或值为null，则&lt;tt&gt; key &lt;tt&gt;没有映射<span class="doctag">@throws</span> NullPointerException */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// value 值为空，直接抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 经过一系列的计算得出 key 的 hash 值 (为了更好的均匀散列表的下标)</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Segment[] 数组中下标所在的位置</span></span><br><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="comment">// 如果 Segment[] 数组为空则创建一个 Segment&lt;&gt; 元素，若不为空则直接 put</span></span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ensureSegment-int-k"><a href="#ensureSegment-int-k" class="headerlink" title="ensureSegment(int k)"></a>ensureSegment(int k)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">    * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/* 返回给定索引的段，创建它并记录在段表中（通过CAS）（如果尚不存在）。 @param k索引 @返回 段 */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">       <span class="comment">// raw offset 原始偏移</span></span><br><span class="line">       <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">       Segment&lt;K,V&gt; seg;</span><br><span class="line">       <span class="comment">// 根据原始偏移获取指定段的值，如果为空</span></span><br><span class="line">       <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 复制一份和segment 0一样的segment （使用 segment0 作为原型）</span></span><br><span class="line">           Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">           <span class="keyword">int</span> cap = proto.table.length;<span class="comment">// 段数组大小</span></span><br><span class="line">           <span class="keyword">float</span> lf = proto.loadFactor;<span class="comment">// 加载因子</span></span><br><span class="line">           <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);<span class="comment">// 阈值</span></span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">           <span class="comment">// 再次根据原始偏移量获取指定段的值，如果为空</span></span><br><span class="line">           <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">               == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">               <span class="comment">// 根据已有属性创建段 Segment s</span></span><br><span class="line">               Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">               <span class="comment">// 再次根据原始偏移量获取指定段的值，为空则循环</span></span><br><span class="line">               <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                      == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 利用 cas 进行赋值</span></span><br><span class="line">                   <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> seg;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>：</p><blockquote><ul><li>如果指定段 segments[j] 为空，则复制 segments[0] 到指定段 segments[j]</li><li>UNSAFE.compareAndSwapObject 原子性操作保证线程安全 （利用了CAS）</li></ul></blockquote><h1 id="4、Segment内置方法解析"><a href="#4、Segment内置方法解析" class="headerlink" title="4、Segment内置方法解析"></a>4、Segment内置方法解析</h1><h2 id="put-K-key-int-hash-V-value-boolean-onlyIfAbsent"><a href="#put-K-key-int-hash-V-value-boolean-onlyIfAbsent" class="headerlink" title="put(K key, int hash, V value, boolean onlyIfAbsent)"></a>put(K key, int hash, V value, boolean onlyIfAbsent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryLock() 尝试获取锁，获取不到执行 scanAndLockForPut 方法</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 获取当前 hash 值在改 tab 中的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取执行 tab 中的头节点 Entry</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// key 存在</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="comment">// 记录当前值为旧值</span></span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 如果不是设置的空值替换，则直接替换原有值。</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 转向下一个节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 头插法</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 不存在则创建节点</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">// 键值对的数量 +1</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 键值对数量达到阈值，（并且数组长度要小于最大定义长度）</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 为超过阈值，直接将 node 放在指定位置</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改成功，返回原值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scanAndLockForPut-K-key-int-hash-V-value"><a href="#scanAndLockForPut-K-key-int-hash-V-value" class="headerlink" title="scanAndLockForPut(K key, int hash, V value)"></a>scanAndLockForPut(K key, int hash, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment"> * acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment"> * return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment"> * methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment"> * traversal speed doesn&#x27;t matter, we might as well help warm</span></span><br><span class="line"><span class="comment"> * up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在尝试获取锁的同时扫描包含给定 key 的节点，如果找不到则创建并返回一个节点。返回时，保证锁定被保持。与大多数方法不同，不筛选对方法等于的调用：由于遍历速度并不重要，因此我们也可能会帮助预热关联的代码和访问。 </span></span><br><span class="line"><span class="comment">@ reurn 如果找不到 key ，则返回一个新节点，否则返回null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Gets the table entry for the given segment and hash</span></span><br><span class="line">       <span class="comment">// 根据 segment 和 hash 获取 entry</span></span><br><span class="line">       HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">       HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">       HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 重试次数</span></span><br><span class="line">       <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">       <span class="comment">// 循环尝试获取锁</span></span><br><span class="line">       <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">           HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">           <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                       <span class="comment">// 创建节点</span></span><br><span class="line">                       node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                   retries = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                   <span class="comment">// 头结点就是</span></span><br><span class="line">                   retries = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">// 转向下一个节点</span></span><br><span class="line">                   e = e.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">               <span class="comment">// 尝试了MAX_SCAN_RETRIES次还没拿到锁,</span></span><br><span class="line">               <span class="comment">// TODO</span></span><br><span class="line">               lock();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">               <span class="comment">// 验证头结点是否改变，如果改变，retries重置，从头开始</span></span><br><span class="line">               e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">               retries = -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rehash-HashEntry-lt-K-V-gt-node"><a href="#rehash-HashEntry-lt-K-V-gt-node" class="headerlink" title="rehash(HashEntry&lt;K,V&gt; node)"></a>rehash(HashEntry&lt;K,V&gt; node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment"> * given node to new table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 双倍扩容，将原有数据放入新 table 中 */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reclassify nodes in each list to new table.  Because we</span></span><br><span class="line"><span class="comment"> * are using power-of-two expansion, the elements from</span></span><br><span class="line"><span class="comment"> * each bin must either stay at same index, or move with a</span></span><br><span class="line"><span class="comment"> * power of two offset. We eliminate unnecessary node</span></span><br><span class="line"><span class="comment"> * creation by catching cases where old nodes can be</span></span><br><span class="line"><span class="comment"> * reused because their next fields won&#x27;t change.</span></span><br><span class="line"><span class="comment"> * Statistically, at the default threshold, only about</span></span><br><span class="line"><span class="comment"> * one-sixth of them need cloning when a table</span></span><br><span class="line"><span class="comment"> * doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="comment"> * collectable as soon as they are no longer referenced by</span></span><br><span class="line"><span class="comment"> * any reader thread that may be in the midst of</span></span><br><span class="line"><span class="comment"> * concurrently traversing table. Entry accesses use plain</span></span><br><span class="line"><span class="comment"> * array indexing because they are followed by volatile</span></span><br><span class="line"><span class="comment"> * table write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/** 将每个列表中的节点重新分类为新表。因为我们使用的是2的幂次展开，所以每个bin中的元素必须保持相同的索引或以2个偏移量的幂移动。通过捕获旧节点因为其下一个字段不会更改而可以重复使用的情况，我们消除了不必要的节点创建。从统计上讲，在默认阈值下，当表加倍时，仅其中的六分之一需要克隆。一旦它们被并发遍历表中的任何读取器线程不再引用，它们替换的节点将立即被垃圾回收。条目访问使用纯数组索引，因为它们后面是易失表写入。 */</span></span><br><span class="line">   <span class="comment">// 旧数组的引用</span></span><br><span class="line">HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// 旧数组的长度</span></span><br><span class="line"><span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新数组的阈值</span></span><br><span class="line">threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">(HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line"><span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历就数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算旧数组值在新数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                <span class="comment">// 单节点直接放到新的数组上</span></span><br><span class="line">newTable[idx] = e;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot(重用同一插槽中的连续序列)</span></span><br><span class="line">                <span class="comment">// 拷贝第一个节点到新的数组节点上（方便后面头插法）</span></span><br><span class="line">HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line"><span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line"> last != <span class="keyword">null</span>;</span><br><span class="line"> last = last.next) &#123;</span><br><span class="line"><span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">lastIdx = k;</span><br><span class="line">lastRun = last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newTable[lastIdx] = lastRun;</span><br><span class="line"><span class="comment">// Clone remaining nodes（拷贝剩余节点）</span></span><br><span class="line"><span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">V v = p.value;</span><br><span class="line"><span class="keyword">int</span> h = p.hash;</span><br><span class="line"><span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">// 添加新的节点(链表头插入方式)</span></span><br><span class="line">node.setNext(newTable[nodeIndex]);</span><br><span class="line">newTable[nodeIndex] = node;</span><br><span class="line">table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、图解流程"><a href="#5、图解流程" class="headerlink" title="5、图解流程"></a>5、图解流程</h1><p><img src="/2021/01/04/java/map/java-map-jdk7-concorrentHashMap/concurrentHashMap.jpg" alt="1610410777381"></p><p>参考：<a href="https://juejin.cn/post/6844903520957644808#heading-4">https://juejin.cn/post/6844903520957644808#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8中hashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk8-hashmap/"/>
      <url>2021/01/04/java/map/java-map-jdk8-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8中hashMap源码解析"><a href="#JDK8中hashMap源码解析" class="headerlink" title="JDK8中hashMap源码解析"></a>JDK8中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>因为主要说的是1.8版本中的实现。而1.8中HashMap是数组+链表+红黑树实现的，大概如下图所示。后面还是主要介绍Hash Map中主要的一些成员以及方法原理。</p><p>那么上述图示中的结点Node具体类型是什么，源码如下。Node是HashMap的内部类，实现了Map.Entery接口，主要就是存放我们put方法所添加的元素。其中的next就表示这可以构成一个单向链表，这主要是通过链地址法解决发生hash冲突问题。而当桶中的元素个数超过阈值的时候就换转为红黑树。</p><h2 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">    * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基本哈希箱节点，用于大多数条目。 （请参阅下面的</span></span><br><span class="line"><span class="comment">    * TreeNode子类，以及LinkedHashMap中的Entry子类。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// hash桶中的结点Node,实现了Map.Entry</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;<span class="comment">// 链表的next指针</span></span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重写Object的hashCode</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// equals方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TreeNode-lt-k-v-gt"><a href="#TreeNode-lt-k-v-gt" class="headerlink" title="TreeNode&lt;**k**,**v**&gt;"></a><strong>TreeNode</strong>&lt;**k**,**v**&gt;</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;<span class="comment">//左子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;<span class="comment">//右子树</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;<span class="comment">// 颜色属性</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 返回当前节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2、HashMap中的成员变量以及含义"><a href="#2、HashMap中的成员变量以及含义" class="headerlink" title="2、HashMap中的成员变量以及含义"></a>2、HashMap中的成员变量以及含义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量初始化=16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量 = 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认加载因子.一般HashMap的扩容的临界点是当前HashMap的大小 &gt; DEFAULT_LOAD_FACTOR * </span></span><br><span class="line"><span class="comment">//DEFAULT_INITIAL_CAPACITY = 0.75F * 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数大于该值的时候，会由链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当hash桶中的某个bucket上的结点数小于该值的时候，红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash算法,计算传入的key的hash值，下面会有例子说明这个计算的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。下面会有例子说明</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash桶</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存的entrySet</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶的实际元素个数 != table.length</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容或者更改了map的计数器。含义：表示这个HashMap结构被修改的次数，结构修改是那些改变HashMap中的映射数量或者</span></span><br><span class="line"><span class="comment">//修改其内部结构（例如，重新散列rehash）的修改。 该字段用于在HashMap失败快速（fast-fail）的Collection-views</span></span><br><span class="line"><span class="comment">//上创建迭代器。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临界值，当实际大小（cap*loadFactor）大于该值的时候，会进行扩充</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="3、HashMap构造方法"><a href="#3、HashMap构造方法" class="headerlink" title="3、HashMap构造方法"></a>3、HashMap构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用默认的初始容量</span></span><br><span class="line"><span class="comment">    *（16）和默认的加载因子（0.75）构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;，它具有指定的初始*容量和默认负载因子（0.75）。 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity初始容量。 </span></span><br><span class="line"><span class="comment"> * @如果初始容量为负，则抛出IllegalArgumentException。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用指定的初始*容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;/ tt&gt;。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor负载系数</span></span><br><span class="line"><span class="comment">    * @如果初始容量为负*或负载系数为非正数，则抛出IllegalArgumentException </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用与指定的&lt;tt&gt; Map &lt;/ tt&gt;相同的映射构造一个新的&lt;tt&gt; HashMap &lt;/ tt&gt;。 &lt;tt&gt; HashMap &lt;/ tt&gt;是使用默认负载因子（0.75）和足以将*映射保存在指定的&lt;tt&gt; Map &lt;/ tt&gt;中的初始容量创建的。 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>要在其地图中放置其映射的地图*如果指定的地图为null，则抛出NullPointerException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">    * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.putAll和Map构造函数。映射时的</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>最初构造此映射时，返回<span class="doctag">@false</span>，否则为true（中继到afterNodeInsertion方法）。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//该函数将传递的map集合中的所有元素加入本map实例中</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果本map实例的table为null，没有初始化，那么需要初始化</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">               <span class="comment">// 实际大小：ft = m.size() / 0.75 + 1;</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">// 判断刚刚计算的大小是否小于最大值1&lt;&lt;&lt;30</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//计算的实际大小ft大于当前的阈值threshhold，那么将threshhold重新计算，tableSizeFor传递的</span></span><br><span class="line">           <span class="comment">//参数是计算的大小，即重新计算大于ft的最小二次幂</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果table!=null，并且m.size() &gt; threshhold，直接进行扩容处理</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">// 将map中的所有元素加入本map实例中</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、put-方法"><a href="#4、put-方法" class="headerlink" title="4、put 方法"></a>4、put 方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定值与该映射中的指定键相关联。</span></span><br><span class="line"><span class="comment">    * 如果该映射先前包含键的映射，则将替换旧</span></span><br><span class="line"><span class="comment">    * 值。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>键与指定值关联的键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>值与指定键关联的值</span></span><br><span class="line"><span class="comment">    * @返回与&lt;tt&gt; key &lt;/ tt&gt;关联的先前值，或者</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt; null &lt;/ tt&gt;（如果没有&lt;tt&gt; key &lt;/ tt&gt;的映射）。</span></span><br><span class="line"><span class="comment">    * （返回&lt;tt&gt; null &lt;/ tt&gt;还可以表明该地图</span></span><br><span class="line"><span class="comment">    * 先前将&lt;tt&gt; null &lt;/ tt&gt;与&lt;tt&gt; key &lt;/ tt&gt;关联。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现Map.put和相关方法。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 哈希键的哈希值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 键的键</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 值的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> only如果为true，则不更改现有值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> 退出，如果为false，则表处于创建模式。 </span></span><br><span class="line"><span class="comment">   * @返回上一个值；如果没有，则返回null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//table == null 或者table的长度为0，调用resize方法进行扩容</span></span><br><span class="line"><span class="comment">//这里也说明：table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里就是调用了Hash算法的地方，具体的计算可参考后面写到的例子</span></span><br><span class="line"> <span class="comment">// 这里定位坐标的做法在上面也已经说到过</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         <span class="comment">// 如果计算得到的桶下标值中的Node为null，就新建一个Node加入该位置(这个新的结点是在</span></span><br><span class="line">     <span class="comment">// table数组中)。而该位置的hash值就是调用hash()方法计算得到的key的hash值</span></span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//这里表示put的元素用自己key的hash值计算得到的下表和桶中的第一个位置元素产生了冲突，具体就是</span></span><br><span class="line"> <span class="comment">//(1)key相同，value不同</span></span><br><span class="line"> <span class="comment">//(2)只是通过hash值计算得到的下标相同，但是key和value都不同。这里处理的方法就是链表和红黑树</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//上面已经计算得到了该hash对应的下标i，这里p=tab[i]。这里比较的有：</span></span><br><span class="line">     <span class="comment">//(1)tab[i].hash是否等于传入的hash。这里的tab[i]就是桶中的第一个元素</span></span><br><span class="line">     <span class="comment">//(2)比较传入的key和该位置的key是否相同</span></span><br><span class="line">     <span class="comment">//(3)如果都相同，说明是同一个key，那么直接替换对应的value值(在后面会进行替换)</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">// 将桶中的第一个元素赋给e，用来记录第一个位置的值</span></span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             <span class="comment">// 这里判断为红黑树。hash值不相等，key不相等；为红黑树结点</span></span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//判断为链表结点</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="comment">//如果达到链表的尾部</span></span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 在尾部插入新的结点</span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 前面的binCount是记录链表长度的，如果该值大于8，就会转变为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//如果在遍历链表的时候，判断得出要插入的结点的key和链表中间的某个结点的key相</span></span><br><span class="line">             <span class="comment">//同，就跳出循环,后面也会更新旧的value值</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">//e = p.next。遍历链表所用</span></span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//判断插入的是否存在HashMap中，上面e被赋值，不为空，则说明存在，更新旧的键值对</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value; <span class="comment">// 用传入的参数value更新旧的value值</span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;<span class="comment">// 返回旧的value值</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// modCount修改</span></span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 容量超出就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>​    可以看到主要逻辑在put方法中调用了putVal方法，传递的参数是调用了hash()方法计算key的hash值，主要逻辑在putVal中。可以结合注释熟悉这个方法的执行，我在这里大概总结一下这个方法的执行：</p><ol><li><p>首先 <strong>(tab = table) == null || (n = tab.length) == 0</strong>这一块判断hash桶是否为null，如果为null那么会调用resize方法扩容。后面我们会说到这个方法</p></li><li><p>定位元素在桶中的位置，具体就是通过<strong>key的hash值和hash桶的长度</strong>计算得到下标i，如果计算到的位置处没有元素(null)，那么就新建结点然后添加到该位置。</p></li><li><p>如果table[i]处不为null，已经有元素了，那么就表明产生hash冲突,这里可能是三种情况</p><p>①判断key是不是一样，如果key一样，那么就将新的值替换旧的值；</p><p>②如果不是因为key一样，那么需要判断当前该桶是不是已经转为了红黑树，是的话就构造一个TreeNode结点插入红黑树；</p><p>③不是红黑树，就使用链地址法处理冲突问题。这里主要就是遍历链表，如果在遍历过程中也找到了key一样的元素，那么久还是使用新值替换旧值。否则会遍历到链表结尾处，到这里就直接新添加一个Node结点插入链表，插入之后还需要判断是不是已将超过了转换为红黑树的阈值8，如果超过就会转为红黑树。</p></li><li><p>最后需要修改modCount的值。</p></li><li><p>判断插入后的size大小是不是超过了threshhold，如果超过需要进行扩容。</p></li></ol></blockquote><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化或加倍表大小。如果为null，则根据字段阈值中保持的初始容量目标分配。 </span></span><br><span class="line"><span class="comment">    * 否则，因为我们使用的是2的幂，所以每个bin中的</span></span><br><span class="line"><span class="comment">    * 元素必须保持相同的索引，或者在新表中以2的偏移量移动。 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @返回 table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// oldTab 指向旧的 table 数组</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// oldTab 不为 null 的话，oldCap 为原 table 的长度，oldTab为null的话，oldCap为0</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">// 阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果数组的长度在扩容后小于最大容量 并且oldCap大于默认值16(这里的newCap也是在原来的</span></span><br><span class="line">       <span class="comment">// 长度上扩展两倍)</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           <span class="comment">// 这里的oldThr=tabSizeFor(initialCapacity),从上面的构造方法看出，如果不是调用的</span></span><br><span class="line">       <span class="comment">// 无参构造，那么threshhold肯定都会是经过tabSizeFor运算得到的2的整数次幂的,所以可以将</span></span><br><span class="line">       <span class="comment">// 其作为Node数组的长度(个人理解)</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           <span class="comment">// 这里说的是我们调用无参构造函数的时候(table == null,threshhold = 0)，新的容量等于默</span></span><br><span class="line">       <span class="comment">// 认的容量，并且threshhold也等于默认加载因子*默认初始化容量</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">// 计算新的resize上限</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//容量 * 加载因子</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       <span class="comment">//以新的容量作为长度，创建一个新的Node数组存放结点元素</span></span><br><span class="line">   <span class="comment">//当然，桶数组的初始化也是在这里完成的</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">//原来的table不为null</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// 原table中下标j位置不为null</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//将原来的table[j]赋为null</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果该位置没有链表，即只有数组中的那个元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">// 通过新的容量计算在新的table数组中的下标：(n-1)&amp;hash</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">// 如果是红黑树结点，重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">//遍历链表，进行重新映射</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 原位置</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// loTail处为null，那么直接加到该位置</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">// loTail为链表尾结点，添加到尾部</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 原位置+旧容量</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="comment">// hiTail处为null，就直接点添加到该位置</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// hiTail为链表尾结点，尾插法添加</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                   <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 旧链表迁移新链表,链表元素相对位置没有变化; </span></span><br><span class="line">                       <span class="comment">// 实际是对对象的内存地址进行操作 </span></span><br><span class="line">                           loTail.next = <span class="keyword">null</span>; <span class="comment">// 链表尾元素设置为null</span></span><br><span class="line">                           newTab[j] = loHead; <span class="comment">// 数组中位置为j的地方存放链表的head结点</span></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断当前oldTab长度是否为空，如果为空，则进行初始化桶数组，也就回答了<strong>无参构造函数初始化为什么没有对容量和阈值进行赋值</strong>，如果不为空，则进行位运算，左移一位，2倍运算扩容。</p><p>扩容，创建一个新容量的数组，遍历旧的数组： </p><ul><li>如果节点为空，直接赋值插入</li><li>如果节点为红黑树，则需要进行进行拆分操作（个人对红黑树还没有理解，所以先不说明）</li><li>如果为链表，根据hash算法进行重新计算下标，将链表进行拆分分组（相信看到这里基本上也知道链表拆分的大致过程了）</li></ul></blockquote><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode(int hash, Object key)"></a><strong>getNode</strong>(<strong>int</strong> hash, Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.get and related methods.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Map.get和相关方法。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">    * @返回节点，如果没有则返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">//计算存放在数组table中的位置.具体计算方法上面也已经介绍了</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//先查找是不是就是数组中的元素</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">//该位置为红黑树根节点或者链表头结点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="comment">//如果first为红黑树结点，就在红黑树中遍历查找</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="comment">//不是树结点，就在链表中遍历查找</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK7中hashMap源码解析</title>
      <link href="2021/01/04/java/map/java-map-jdk7-hashmap/"/>
      <url>2021/01/04/java/map/java-map-jdk7-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK7中hashMap源码解析"><a href="#JDK7中hashMap源码解析" class="headerlink" title="JDK7中hashMap源码解析"></a>JDK7中hashMap源码解析</h1><h1 id="1、hashMap数据结构"><a href="#1、hashMap数据结构" class="headerlink" title="1、hashMap数据结构"></a>1、hashMap数据结构</h1><p>hashMap底层数据结构是数组 + 单链表，对 key 计算 hashCode 散列到数组中， 相同的 hashCode 的 key 添加到同一个链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash标中的结点Node,实现了Map.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Entry构造器，需要key的hash，key，value和next指向的结点</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Object的hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、HashMap-对象的属性"><a href="#2、HashMap-对象的属性" class="headerlink" title="2、HashMap 对象的属性"></a>2、HashMap 对象的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 默认初始容量-必须为2的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 最大容量，如果两个构造函数都使用参数隐式指定了更高的值，则使用该容量。必须是两个&lt;= 1 &lt;&lt; 30的幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在构造函数中未指定时使用的负载系数。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当表未膨胀时要共享的空表实例。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 该表，根据需要调整大小。长度必须始终为2的幂。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 此映射中包含的键-值映射数。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 下一个要调整大小的大小值（容量负载因子）。</span></span><br><span class="line"><span class="comment">// If table == EMPTY_TABLE then this is the initial capacity at which the</span></span><br><span class="line"><span class="comment">// table will be created when inflated.</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 哈希表的负载因子。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 对该HashMap进行结构修改的次数结构修改是指更改HashMap中的映射次数或以其他方式修改其内部结构（例如重新哈希）的修改。此字段用于使HashMap的Collection-view上的迭代器快速失败。 （请参见ConcurrentModificationException）。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default threshold of map capacity above which alternative hashing is</span></span><br><span class="line"><span class="comment"> * used for String keys. Alternative hashing reduces the incidence of</span></span><br><span class="line"><span class="comment"> * collisions due to weak hash code calculation for String keys.</span></span><br><span class="line"><span class="comment"> * &lt;p/&gt;</span></span><br><span class="line"><span class="comment"> * This value may be overridden by defining the system property</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> jdk.map.althashing.threshold&#125;. A property value of &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment"> * forces alternative hashing to be used at all times whereas</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> -1&#125; value ensures that alternative hashing is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 映射容量的默认阈值，高于该阈值时，字符串键将使用替代哈希。备用哈希可减少由于字符串键的哈希码计算能力较弱而导致的冲突发生率。 &lt;p&gt;可以通过定义系统属性&#123;@code jdk.map.althashing.threshold&#125;来覆盖此值。属性值&#123;@code 1&#125;强制始终使用替代哈希，而&#123;@code -1&#125;值确保从不使用替代哈希。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure><h1 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">    * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;，它具有默认的初始容量（16）和默认的负载系数（0.75）。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap(int initialCapacity)"></a>HashMap(int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap(int initialCapacity, float loadFactor)"></a>HashMap(int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">    * capacity and load factor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">    *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//使用指定的初始容量和负载因子构造一个空的&lt;tt&gt; HashMap &lt;tt&gt;。 @param initialCapacity初始容量@param loadFactor负载系数@throws IllegalArgumentException如果初始容量为负或负载系数为非正</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = initialCapacity;</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>HashMap(Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">    * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">    * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">    * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 构造一个新的&lt;tt&gt; HashMap &lt;tt&gt;，其映射与指定的&lt;tt&gt; Map &lt;tt&gt;相同。 &lt;tt&gt; HashMap &lt;tt&gt;是使用默认负载因子（0.75）和足以将映射保存在指定的&lt;tt&gt; Map &lt;tt&gt;中的初始容量创建的。 @param m要在其 Map 中放置其映射的 Map @throws NullPointerException如果指定的 Map 为null</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                     DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">       inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">       putAllForCreate(m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="4、put方法"><a href="#4、put方法" class="headerlink" title="4、put方法"></a>4、put方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">    * value is replaced.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 将指定值与该映射中的指定键相关联。如果该映射先前包含该键的映射，则将替换旧值。 </span></span><br><span class="line"><span class="comment">// @param 与指定值关联的键key </span></span><br><span class="line"><span class="comment">// @param 与指定键关联的值</span></span><br><span class="line"><span class="comment">// @return 与&lt;tt&gt; key &lt;tt&gt;或&lt;tt&gt; null &lt;tt&gt;关联的先前值&lt;tt&gt; key &lt;tt&gt;没有映射。 （返回&lt;tt&gt; null &lt;tt&gt;也可以表明该映射先前将&lt;tt&gt; null &lt;tt&gt;与&lt;tt&gt; key &lt;tt&gt;关联。）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次调用时，table是空的，进行初始化</span></span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">// 如果 key 值为空，则调用 putForNullKey 的方法</span></span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 计算 hash 值</span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 计算 key 在 Entry 数组数组中的位置，相当于对该数组取余。</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">// 遍历该位置上的链表</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 如果存在相同的 key 值， 则直接覆盖并返回旧值</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 没有找到，则添加该 entity</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="inflateTable-threshold"><a href="#inflateTable-threshold" class="headerlink" title="inflateTable(threshold)"></a>inflateTable(threshold)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inflates the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 填充表</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一次初始化时调用</span></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">       <span class="comment">// 找到 &gt;= 2 size的2的幂方数（ 例如：15 则是 16 , 17 则是 32）</span></span><br><span class="line">       <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 计算阈值，16 * 0.75 = 12 （&gt;=size的2的幂方数 * 加载因子）</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       initHashSeedAsNeeded(capacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="putForNullKey-V-value"><a href="#putForNullKey-V-value" class="headerlink" title="putForNullKey(V value)"></a>putForNullKey(V value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 空键的put方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 遍历下标是 0 的数组</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           <span class="comment">// 如果存在键值为 null ， 则覆盖原有的值，并且返回原始值 </span></span><br><span class="line">           <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 如果不存在，则添加元素节点</span></span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hash-Object-k"><a href="#hash-Object-k" class="headerlink" title="hash(Object k)"></a>hash(Object k)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">    * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">    * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">    * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">    * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检索对象哈希码，并将补充哈希函数应用于</span></span><br><span class="line"><span class="comment">    * 结果哈希，以防止质量差的哈希函数。 </span></span><br><span class="line"><span class="comment">    * 这很关键，因为HashMap使用2的幂的哈希表，否则</span></span><br><span class="line"><span class="comment">    * 哈希码的冲突在低位没有区别。注意：空键始终映射到哈希0，因此索引为0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       <span class="comment">// 此函数可确保在每个位位置仅相差</span></span><br><span class="line">       <span class="comment">// 恒定倍数的hashCode具有有限的冲突次数（默认负载因子为约8）。</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="indexFor-int-h-int-length"><a href="#indexFor-int-h-int-length" class="headerlink" title="indexFor(int h, int length)"></a>indexFor(int h, int length)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 返回哈希码h的索引。</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// hashCode 逻辑与(length-1)   所以要长度必须为2的非零幂</span></span><br><span class="line">       <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="addEntry(int hash, K key, V value, int bucketIndex)"></a>addEntry(int hash, K key, V value, int bucketIndex)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment">    * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment">    * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     将具有指定键，值和哈希码的新条目添加到指定存储桶。如果有必要，此方法负责调整表的大小。 </span></span><br><span class="line"><span class="comment">  子类重写此方法以更改put方法的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 添加元素， bucketIndex 表示数组下标</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 元素个数大于阈值，并且数组元素不为空</span></span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">           <span class="comment">// 2倍扩容</span></span><br><span class="line">           resize(<span class="number">2</span> * table.length);</span><br><span class="line">           hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 扩容后重新计算数组的下标值</span></span><br><span class="line">           bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建元素节点</span></span><br><span class="line">       createEntry(hash, key, value, bucketIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="resize-int-newCapacity"><a href="#resize-int-newCapacity" class="headerlink" title="resize(int newCapacity)"></a>resize(int newCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">    * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">    * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">    * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">    * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">    *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">    *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">    *        is irrelevant).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">/ ** </span><br><span class="line">* 将此映射的内容重新映射为</span><br><span class="line">* 具有更大容量的新数组。当此映射中的</span><br><span class="line">* 键数达到其阈值时，将自动调用此方法。 </span><br><span class="line">* </span><br><span class="line">   * 如果当前容量为MAXIMUM_CAPACITY，则此方法不会</span><br><span class="line">* 调整地图大小，而是将阈值设置为Integer.MAX_VALUE。 </span><br><span class="line">* 这样可以防止将来的通话。 </span><br><span class="line">* </span><br><span class="line">   * <span class="meta">@param</span> newCapacity新容量，必须是<span class="number">2</span>的幂； </span><br><span class="line">   * 必须大于当前容量，除非当前</span><br><span class="line">   * 容量为MAXIMUM_CAPACITY（在这种情况下，无关紧要）。</span><br><span class="line">   * /</span><br><span class="line">   <span class="comment">// 扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="comment">// 数组最大扩容到2的30次方</span></span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">       <span class="comment">// 把旧数组的所有元素拷贝到新数组里</span></span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       <span class="comment">// 扩容后，重新计算阈值</span></span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="transfer-Entry-newTable-boolean-rehash"><a href="#transfer-Entry-newTable-boolean-rehash" class="headerlink" title="transfer(Entry[] newTable, boolean rehash)"></a>transfer(Entry[] newTable, boolean rehash)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有条目从当前表传输到newTable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 重新计算新数组的下标位置</span></span><br><span class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">               <span class="comment">// 头插法</span></span><br><span class="line">               e.next = newTable[i];</span><br><span class="line">               newTable[i] = e;</span><br><span class="line">               e = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="createEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#createEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="createEntry(int hash, K key, V value, int bucketIndex)"></a>createEntry(int hash, K key, V value, int bucketIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment">    * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment">    * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment">    * clone, and readObject.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 与addEntry相似，只是在创建条目时将使用此版本</span></span><br><span class="line"><span class="comment">* 作为Map构造或“伪构造”（克隆，</span></span><br><span class="line"><span class="comment">* 反序列化）的一部分。此版本无需担心调整表的大小。 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">   * 子类重写此方法，以更改HashMap（Map），</span></span><br><span class="line"><span class="comment">   * clone和readObject的行为。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 创建元素，放在头节点</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">       table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、get方法"><a href="#5、get方法" class="headerlink" title="5、get方法"></a>5、get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="getForNullKey"><a href="#getForNullKey" class="headerlink" title="getForNullKey()"></a>getForNullKey()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Offloaded version of get() to look up null keys.  Null keys map</span></span><br><span class="line"><span class="comment"> * to index 0.  This null case is split out into separate methods</span></span><br><span class="line"><span class="comment"> * for the sake of performance in the two most commonly used</span></span><br><span class="line"><span class="comment"> * operations (get and put), but incorporated with conditionals in</span></span><br><span class="line"><span class="comment"> * others.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Entry-lt-K-V-gt-getEntry-Object-key"><a href="#Entry-lt-K-V-gt-getEntry-Object-key" class="headerlink" title="Entry&lt;K,V&gt; getEntry(Object key)"></a>Entry&lt;K,V&gt; getEntry(Object key)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the entry associated with the specified key in the</span></span><br><span class="line"><span class="comment">  * HashMap.  Returns null if the HashMap contains no mapping</span></span><br><span class="line"><span class="comment">  * for the key.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = e.next) &#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">             ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="6-常见面试题"><a href="#6-常见面试题" class="headerlink" title="6. 常见面试题"></a>6. 常见面试题</h1><h2 id="6-1-HashMap的put方法逻辑"><a href="#6-1-HashMap的put方法逻辑" class="headerlink" title="6.1 HashMap的put方法逻辑"></a>6.1 HashMap的put方法逻辑</h2><ol><li>判断entry是否是空数组，如果是初始化一个长度是16，阈值是12的数组</li><li>判断key是否等于null，如果是null，就放在下标是0的数组位置上，并插入头结点</li><li>对key的hashCode二次hash，并对(length-1)逻辑与，算出数组下标位置</li><li>遍历该下标位置上的链表，如果找到该key，就覆盖旧值并返回</li><li>判断当前元素个数是否大于阈值，如果大于就执行2倍扩容，把原数组的元素重新hash到新数组中</li><li>用当前key创建一个节点，插到下标数组链表的头结点</li></ol><h2 id="6-2-为什么HashMap的容量必须是2的倍数"><a href="#6-2-为什么HashMap的容量必须是2的倍数" class="headerlink" title="6.2 为什么HashMap的容量必须是2的倍数"></a>6.2 为什么HashMap的容量必须是2的倍数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算机中，与运算比求余运算更快，采用了 hashCode &amp; (length-1)。</strong> </p><blockquote><p> 假如length是16，(length-1)的二进制就是 1111，比15小的数逻辑与之后就是自身，比15大的数，只有低4位的数才能运算出值。是为了更方便与运算。</p></blockquote><h2 id="6-3-HashMap线程不安全体现在哪些方面？"><a href="#6-3-HashMap线程不安全体现在哪些方面？" class="headerlink" title="6.3 HashMap线程不安全体现在哪些方面？"></a>6.3 HashMap线程不安全体现在哪些方面？</h2><p>由于hash冲突的时候插入链表，采用的是头插法，导致扩容后链表的顺序和原来顺序相反，多个线程同时扩容会出现环形链表，get的时候陷入死循环。</p><h1 id="7-HashMap还有哪些缺点"><a href="#7-HashMap还有哪些缺点" class="headerlink" title="7. HashMap还有哪些缺点"></a>7. HashMap还有哪些缺点</h1><ol><li>使用单链表解决hash冲突，导致最坏的情况get的效率降至O(N)</li><li>链表采用头插法，导致多线程扩容出现环形链表</li><li>扩容需要把每个元素重新hash放到新数组里，性能太差</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> map </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK提供的"><a href="#JDK提供的" class="headerlink" title="JDK提供的"></a>JDK提供的</h1><ul><li>ConcurrentHashMap: 线程安全的 HashMap</li><li>CopyOnWriteArrayList: 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li><li>ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li>BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li>ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><ul><li>HashMap的线程安全版</li><li>无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</li></ul><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><ul><li>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。</li><li>CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。</li><li>怎么操作<ul><li>在写操作的时候，先将原来的数组复制一份，在副本上进行写操作，写完后将副本替换原来的数据，保证了写操作不会影响多操作</li></ul></li><li>CopyOnWriteArrayList 写操作源码<ul><li>CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();<span class="comment">//加锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><ul><li>非阻塞队列</li><li>使用链表作为数据结构</li><li>使用CAS非阻塞算法实现线程安全</li></ul><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><ul><li><p>阻塞队列</p></li><li><p>广泛使用在“生产者-消费者”问题中</p></li></ul><ul><li>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</li></ul><ul><li><p>实现类</p><p><img src="/2020/12/31/java/juc/java-juc-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/Image.png" alt="img"></p></li></ul><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><ul><li>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</li><li>ArrayBlockingQueue 一旦创建，容量不能改变。</li><li>并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</li></ul><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><ul><li>LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</li></ul><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><ul><li>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</li><li>并发控制采用的是 ReentrantLock</li></ul><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h1><ul><li>使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。</li></ul><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><ul><li>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</li></ul><p>![img](java-juc-并发容器/Image [1].png)</p><ul><li>跳表的本质是同时维护了多个链表，并且链表是分层的，最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</li><li>跳表内的所有链表的元素都是<strong>排序</strong>的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。</li></ul><p>![img](java-juc-并发容器/Image [2].png)</p><ul><li>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</li><li>跳表是一种利用空间换时间的算法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atomic原子类</title>
      <link href="2020/12/31/java/juc/java-juc-Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>2020/12/31/java/juc/java-juc-Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h1><ul><li> Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</li></ul><h1 id="JUC-包中的原子类是哪4类"><a href="#JUC-包中的原子类是哪4类" class="headerlink" title="JUC 包中的原子类是哪4类?"></a>JUC 包中的原子类是哪4类?</h1><ul><li>基本类型：使用原子的方式更新基本类型<ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul></li><li>数组类型：使用原子的方式更新数组里的某个元素<ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul></li><li>引用类型<ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul></li><li>对象的属性修改类型<ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(); </span><br><span class="line"><span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    count.incrementAndGet(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="AtomicInteger 类的原理"></a>AtomicInteger 类的原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><ul><li><p> AtomicInteger 类主要利用 CAS ( compare and swap ) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p></li><li><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的  objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset 。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双重校验锁实现单例</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--线程池</title>
      <link href="2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><ul><li>线程池提供了一种限制和管理资源</li><li>好处：<ul><li>降低资源消耗：线程的创建和销毁需要消耗资源</li><li>提高响应速度：当任务达到的时候，任务可以不用等待线程创建就能立即执行</li><li>提高线程的可管理性：线程是稀缺资源，不可以无限创建，需要统一分配和调度、监控</li></ul></li></ul><h1 id="Runable接口和Callable接口的区别"><a href="#Runable接口和Callable接口的区别" class="headerlink" title="Runable接口和Callable接口的区别"></a>Runable接口和Callable接口的区别</h1><ul><li>Runable 接口没有返回结果和抛出异常</li><li>Callable 接口偶返回结果和抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h1><h2 id="使用-Executors"><a href="#使用-Executors" class="headerlink" title="使用 Executors"></a>使用 Executors</h2><blockquote><p>// 允许创建线程的数量为 Integer.MAX_VALUE，可能会导致创建大量线程，从而导致 OOM</p><p>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</p><p>// 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM<br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);</p><p>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</p><p>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);</p></blockquote><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><ul><li>FixedThreadPool ： 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的数量始终不变。当有一个新的任务提交时，线程池中若有空闲的线程，则立即执行。若没有，则新的任务会暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li>FixedThreadPool ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li><li>因为最大线程数固定，不会拒绝任务，在任务比较多的时候会导致 OOM</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610064973712.png" alt="1610064973712"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><ul><li>SingkeThreadExecutor：方法返回<strong>一个只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会碑额保存在一个队列中，等待线程空闲，按先入先出的顺序执行队列中的任务。</li><li>SingleThreadExecutor ：使用无界队列 LinkedBlockQueue （队列的容量 Integer.MAX_VALUE）作为线程池的队列</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065305945.png" alt="1610065305945"></p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><ul><li>CachedThreadPool：<strong>可以根据实际情况调整线程数量的线程池</strong>。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可以复用的线程。若所有的线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<ul><li>CachedThreadPool 的 corePoolSize 被设置为空 (0) , maxinumPoolSize 被设置为 Integer.MAX_VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maxinunPool 中线程处理任务的速度时， CacheThreadPool 会不断创建新的线程，极端情况下，这样会导致耗尽 CPU 和 内存资源。</li><li>CacheThreadPool 允许创建的线程数量为 Integer.MAX_VALUE , 可能会创建大量线程，造成 OOM.</li></ul></li></ul><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><ul><li>ScheduledThreadPool：创建一个定长线程池，支持 定时及周期性任务执行</li><li>ScheduledThreadPoolExecutor ：使用的任务队列 DelayQueue 封装了一个 PriortyQueue 会对队列中的任务进行排序，执行所需时间段的放在前面先被执行 （ScheduleFuture 的 time 变量小的先执行），如果执行所需时间相同则先提交的任务将被先执行 （ScheduleFuture 的 squenceNumber 变量小的先执行）。</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/1610065993004.png" alt="1610065993004"></p><h2 id="使用-ThreadPoolExecutor"><a href="#使用-ThreadPoolExecutor" class="headerlink" title="使用 ThreadPoolExecutor"></a>使用 ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>corePoolSize：核心线程数线程数定义了<strong>最小可以同时运行的线程数量</strong>。</p></li><li><p>maxinumPoolSize：当<strong>队列中存在的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</strong>。</p></li><li><p>workQueue：当<strong>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放在队列中</strong>。</p></li><li><p>keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</p></li><li><p>unit：keepAliveTime 参数的时间单位。</p></li><li><p>threadFactory：executor 创建新线程的时候会用到</p></li><li><p>handler ：饱和策略，<strong>当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略</strong></p><ul><li>ThreadPoolExecutor.<strong>AbortPolicy</strong>：抛出  RejectedExecutionException 来拒绝新任务的处理。</li><li>ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>：调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行 (run) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务的提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.<strong>DiscardPolicy</strong>： 不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.<strong>DiscardOldestPolicy</strong>： 此策略将丢弃最早的未处理的任务请求。</li></ul></li></ul><h3 id="ThreadPoolExecutor中的execute方法和submit方法区别"><a href="#ThreadPoolExecutor中的execute方法和submit方法区别" class="headerlink" title="ThreadPoolExecutor中的execute方法和submit方法区别"></a>ThreadPoolExecutor中的execute方法和submit方法区别</h3><ul><li>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否</li><li>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值， get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout, TimeUnit unit) 方法会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h3 id="shutdown-和shutDownNow"><a href="#shutdown-和shutDownNow" class="headerlink" title="shutdown()和shutDownNow()"></a>shutdown()和shutDownNow()</h3><ul><li>shutdown()：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow()：关闭线程池，线程的状态变为 STOP。线程池会终止正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-和-isShutdown"><a href="#isTerminated-和-isShutdown" class="headerlink" title="isTerminated() 和 isShutdown()"></a>isTerminated() 和 isShutdown()</h3><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                MAX_POOL_SIZE,<span class="comment">//</span></span><br><span class="line">                KEEP_ALIVE_TIME,<span class="comment">//</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//  executor.execute(worker);</span></span><br><span class="line">            Future&lt;?&gt; result = executor.submit(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h1><p>需要根据实际业务场景来划分</p><ul><li>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自旋锁-手动实现</title>
      <link href="2020/12/31/java/juc/java-juc-%E8%87%AA%E6%97%8B%E9%94%81-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/12/31/java/juc/java-juc-%E8%87%AA%E6%97%8B%E9%94%81-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="yield-自旋实现同步"><a href="#yield-自旋实现同步" class="headerlink" title="yield + 自旋实现同步"></a>yield + 自旋实现同步</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YieldLock</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁实现：使用AtomicReference</span></span><br><span class="line"><span class="comment"> * - AtomicReference原子性，底层实现CAS操作，可以对比普通对象的引用。</span></span><br><span class="line"><span class="comment"> * - 使用unsafe.compareAndSwapObject来完成，支持普通对象的CAS操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">AtomicReference&lt;Thread&gt; lock = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="keyword">while</span> (!lock.compareAndSet(<span class="keyword">null</span>, t)) &#123;</span><br><span class="line">t.yield();</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 尝试获取锁失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 获取锁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 释放锁&quot;</span>);</span><br><span class="line">lock.compareAndSet(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sleep-自旋方式实现同步"><a href="#sleep-自旋方式实现同步" class="headerlink" title="sleep + 自旋方式实现同步"></a>sleep + 自旋方式实现同步</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepLock</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁实现：使用AtomicReference</span></span><br><span class="line"><span class="comment"> * - AtomicReference原子性，底层实现CAS操作，可以对比普通对象的引用。</span></span><br><span class="line"><span class="comment"> * - 使用unsafe.compareAndSwapObject来完成，支持普通对象的CAS操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">AtomicReference&lt;Thread&gt; lock = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line"><span class="keyword">while</span> (!lock.compareAndSet(<span class="keyword">null</span>, t)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 空转&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 获取锁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">System.out.println(t.getName() + <span class="string">&quot;***************** 释放锁&quot;</span>);</span><br><span class="line">lock.compareAndSet(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/java_lyvee/article/details/98966684">https://blog.csdn.net/java_lyvee/article/details/98966684</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存泄漏--ThreadLocal</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F--ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ul><li>内存泄漏是堆内存中不再使用的对象，但是垃圾收集器没有将它们删除的情况，因此它们将会被不必要的一直存在。这样会消耗内存资源，降低系统性能，最终可能导致OOM发生。</li></ul><h1 id="Java中内存泄漏的类型"><a href="#Java中内存泄漏的类型" class="headerlink" title="Java中内存泄漏的类型"></a>Java中内存泄漏的类型</h1><h2 id="static字段引起内存泄漏"><a href="#static字段引起内存泄漏" class="headerlink" title="static字段引起内存泄漏"></a>static字段引起内存泄漏</h2><ul><li>静态的资源一般与整个应用拥有相匹配的生命周期</li><li>尽量减少使用。</li></ul><h2 id="未关闭的资源导致内存泄漏"><a href="#未关闭的资源导致内存泄漏" class="headerlink" title="未关闭的资源导致内存泄漏"></a>未关闭的资源导致内存泄漏</h2><ul><li>创建连接或打开流时，JVM会为这些资源分配内存。如果连接没有关闭，会导致占有内存。</li><li>可以在finally块中或try-with-resources块中关闭</li></ul><h2 id="不正确的hashCode和equals"><a href="#不正确的hashCode和equals" class="headerlink" title="不正确的hashCode和equals"></a>不正确的hashCode和equals</h2><ul><li>重写不合理会导致内存泄漏</li><li>用最佳的方式重写hashCode和equals</li></ul><h2 id="引用了外部类的内部类"><a href="#引用了外部类的内部类" class="headerlink" title="引用了外部类的内部类"></a>引用了外部类的内部类</h2><ul><li>使用了一个非静态的内部类对象，这个时候内部类依赖于外部类对象。即使用完了内部类，这个对象也不会被收集</li><li>如果内部类不访问外部类的成员，可以转换为静态类</li></ul><h2 id="重写了finalize方法"><a href="#重写了finalize方法" class="headerlink" title="重写了finalize方法"></a>重写了finalize方法</h2><h2 id="ThreadLoacl造成内存泄漏"><a href="#ThreadLoacl造成内存泄漏" class="headerlink" title="ThreadLoacl造成内存泄漏"></a>ThreadLoacl造成内存泄漏</h2><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><ul><li>每个线程拥有自己本地专属的变量，可以用ThreadLoal类。</li><li>ThreadLoal类让每个线程绑定自己的值，存储线程私有数据。避免线程出现竞争。</li><li>ThreadLocal类是使用ThreadLoalMap类来实现定制化的HashMap的。调用ThreadLocal类的set或get方法，实际调用的是ThreadLocalMap类的get、set方法。</li><li>变量最终是存在ThreadLocalMap中。</li><li>ThreadLocalMap可以存以ThreadLocal为key，Object对象为value的值对。</li><li>ThreadLocalMap中的key是ThreadLocal的弱引用，而value是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。</li><li>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录<strong>。使用完 ThreadLocal方法后 最好手动调用remove()方法</strong></li></ul><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><blockquote><ul><li><p>每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行set方法中，是从当前线程的<code>threadLocals</code>变量获取。</p></li><li><p>所以在线程1中set的值，对线程2来说是摸不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰。</p></li></ul></blockquote><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><blockquote><p>没有链表结构，那发生hash冲突了怎么办？</p><ol><li>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小<code>0x61c88647</code>。</li><li>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：<ol><li>如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； </li><li>不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value； </li><li>很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</li></ol></li><li>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</li><li>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--AQS源码解析</title>
      <link href="2020/12/31/java/juc/java-juc-AQS%E6%BA%90%E7%A0%81/"/>
      <url>2020/12/31/java/juc/java-juc-AQS%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="FIFO图解"><a href="#FIFO图解" class="headerlink" title="FIFO图解"></a>FIFO图解</h2><p><img src="/2020/12/31/java/juc/java-juc-AQS%E6%BA%90%E7%A0%81/1612860334591.png" alt="1612860334591"></p><h1 id="NonfairSync（同步对象的非公平锁）"><a href="#NonfairSync（同步对象的非公平锁）" class="headerlink" title="NonfairSync（同步对象的非公平锁）"></a>NonfairSync（同步对象的非公平锁）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks </span></span><br><span class="line"><span class="comment"> * 同步对象的非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     * 执行锁定。尝试立即进行驳船，并在出现故障时备份到正常状态.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自旋一次</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 自旋成功，设置当前线程占有锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 自旋未获取锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acquire-1"><a href="#acquire-1" class="headerlink" title="acquire(1)"></a>acquire(1)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在独占模式下获取，忽略中断。</span></span><br><span class="line"><span class="comment"> * 通过至少调用一次&#123;<span class="doctag">@link</span> tryAcquire&#125;并返回成功来实现。</span></span><br><span class="line"><span class="comment"> * 否则，线程将排队，并可能反复阻塞和解除阻塞，并调用&#123;<span class="doctag">@link</span> tryAcquire&#125;直到成功。</span></span><br><span class="line"><span class="comment"> * 此方法可用于实现方法&#123;<span class="doctag">@link</span> Locklock&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg获取参数。</span></span><br><span class="line"><span class="comment"> * 此值会传送到&#123;<span class="doctag">@link</span> tryAcquire&#125;，但否则不会被解释，可以代表您喜欢的任何内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>tryAcquire()</code> 尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而 CLH 队列中可能还有别的线程在等待）；</li><li><code>addWaiter()</code> 将该线程加入等待队列的尾部，并标记为独占模式；</li><li><code>acquireQueued()</code> 使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断 <code>selfInterrupt()</code> ，将中断补上。</li></ol><h3 id="tryAcquire-arg"><a href="#tryAcquire-arg" class="headerlink" title="tryAcquire(arg)"></a>tryAcquire(arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> * 为当前线程和给定模式创建并排队节点.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * @参数模式 Node.EXCLUSIVE 表示独占，Node.SHARED 表示共享</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前线程及节点模式  创建节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速方式直接放到队尾。上一步失败则通过enq入队。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取尾节点引用</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 尾节点不为空，说明已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="enq-node"><a href="#enq-node" class="headerlink" title="enq(node)"></a>enq(node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * 将节点插入队列，必要时进行初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 要插入的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>节点的前任节点的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cas 自旋，知道成功的加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize 必须初始化</span></span><br><span class="line">            <span class="comment">// 如果tial为空，则新建一个节点，并将tail指向head</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="acquireQueued(addWaiter(Node.EXCLUSIVE), arg))"></a>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> * 以排他的不间断模式获取已在队列中的线程。</span></span><br><span class="line"><span class="comment"> * 用于条件等待方法以及获取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否成功获取锁</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记线程等待过程中是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿到前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是head，即该节点为老二，那么便有资格去尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功，当前节点设置成 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 原 head 节点出队，出队后不存在任何引用，会被GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回是否被中断过</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断获取锁失败后是否可以挂起，如果可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果线程被中断过，就将 interrupted 标记为 true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="setHead-node"><a href="#setHead-node" class="headerlink" title="setHead(node)"></a>setHead(node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment"> * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment"> * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将队列头设置为节点，从而出队。</span></span><br><span class="line"><span class="comment"> * 仅通过 acquire 方法调用。</span></span><br><span class="line"><span class="comment"> * 出于 GC 和抑制不必要的信号和遍历的目的，还应清空未使用的字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;<span class="comment">// head指向当前节点</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;<span class="comment">// 当前节点的 thread 设置为空</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;<span class="comment">// 当前节点的 头节点设置为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="shouldParkAfterFailedAcquire-p-node"><a href="#shouldParkAfterFailedAcquire-p-node" class="headerlink" title="shouldParkAfterFailedAcquire(p, node)"></a>shouldParkAfterFailedAcquire(p, node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment"> * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment"> * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 检查并更新无法获取的节点的状态。</span></span><br><span class="line"><span class="comment"> * 如果线程应阻塞，则返回true。</span></span><br><span class="line"><span class="comment"> * 这是所有采集循环中的主要信号控制。</span></span><br><span class="line"><span class="comment"> * 要求 pred == node.prev。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred 节点的前任保持状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 如果线程应该阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         * 该节点已经设置了状态，要求释放以发出信号，以便可以安全地停放。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，</span></span><br><span class="line"><span class="comment">         *      它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         * 前任已取消。跳过前任并指示重试。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         * waitStatus 必须为 0 或 PROPAGATE 。表示我们需要一个信号，但不要停车。</span></span><br><span class="line"><span class="comment">         * 呼叫者将需要重试以确保在停车之前无法获取。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。</span></span><br><span class="line">        <span class="comment">// 有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p></blockquote><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> * 停车的便捷方法，然后检查是否中断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 park() 使线程进入 waiting 状态</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nonfairTryAcquire-acquires"><a href="#nonfairTryAcquire-acquires" class="headerlink" title="nonfairTryAcquire(acquires)"></a>nonfairTryAcquire(acquires)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行不公平的 tryLock。 </span></span><br><span class="line"><span class="comment"> * tryAcquire 是在子类中实现的，但是都需要对 trylock 方法进行不公平的尝试。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取 state 变量的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 没有线程占用锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 自旋一次，（compareAndSetState原子操作，替换）</span></span><br><span class="line">            <span class="comment">// 占用锁成功，设置独占线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="comment">// 获取锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程已经占用该锁</span></span><br><span class="line">        <span class="comment">// 重入次数 + acquires (acquires=1)</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新重入次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>调用自定义同步器的 tryAcquire() 尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则 addWaiter() 将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued() 使线程在等待队列中休息，有机会时（轮到自己，会被 unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回 true ，否则返回 false 。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断 selfInterrupt() ，将中断补上。</li></ol><p><img src="/2020/12/31/java/juc/java-juc-AQS%E6%BA%90%E7%A0%81/1612923550174.png" alt="1612923550174"></p><h2 id="sync-release-1"><a href="#sync-release-1" class="headerlink" title="sync.release(1)"></a>sync.release(1)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 以独占模式发布。</span></span><br><span class="line"><span class="comment"> * 如果&#123;<span class="doctag">@link</span> tryRelease&#125;返回true，则通过解锁一个或多个线程来实现。</span></span><br><span class="line"><span class="comment"> * 此方法可用于实现方法&#123;<span class="doctag">@link</span> Lockunlock&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg释放参数。</span></span><br><span class="line"><span class="comment"> * 该值会传送到&#123;<span class="doctag">@link</span> tryRelease&#125;，但否则不会被解释，可以代表您喜欢的任何内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 找到头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// //唤醒等待队列里的下一个线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease-arg"><a href="#tryRelease-arg" class="headerlink" title="tryRelease(arg)"></a>tryRelease(arg)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 该方法不比考虑线程安全，</span></span><br><span class="line"><span class="comment"> * 因为如果有其他线程修改 state 值后， state对该方法是可见的，</span></span><br><span class="line"><span class="comment"> * 最多不唤醒下一个线程，而是由新的线程获取state的状态 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c = 0 时，代表没有锁（可重入锁计数为0）</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 state 的状态</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor-h"><a href="#unparkSuccessor-h" class="headerlink" title="unparkSuccessor(h)"></a>unparkSuccessor(h)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果状态是否定的（即可能需要信号），请尝试清除以预期发出信号。</span></span><br><span class="line"><span class="comment">     * 如果失败或等待线程更改状态，则可以。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 释放线程保留在后续线程中，该线程通常只是下一个节点。</span></span><br><span class="line"><span class="comment">     * 但是，如果已取消或明显为空，请从尾部向后移动以找到实际的未取消后继。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h1><h2 id="tryAcquire-arg-1"><a href="#tryAcquire-arg-1" class="headerlink" title="tryAcquire(arg)"></a>tryAcquire(arg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Queries whether any threads have been waiting to acquire longer</span></span><br><span class="line"><span class="comment"> * than the current thread.</span></span><br><span class="line"><span class="comment"> * 查询是否有任何线程在等待获取比当前线程更长的时间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An invocation of this method is equivalent to (but may be</span></span><br><span class="line"><span class="comment"> * more efficient than):</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;</span></span><br><span class="line"><span class="comment"> * hasQueuedThreads()&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 对此方法的调用等效于（但可能比它更有效）：</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt; &#123;<span class="doctag">@code</span> getFirstQueuedThread（）！= Thread.currentThread（）&amp;&amp; hasQueuedThreads（）&#125; &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that because cancellations due to interrupts and</span></span><br><span class="line"><span class="comment"> * timeouts may occur at any time, a &#123;<span class="doctag">@code</span> true&#125; return does not</span></span><br><span class="line"><span class="comment"> * guarantee that some other thread will acquire before the current</span></span><br><span class="line"><span class="comment"> * thread.  Likewise, it is possible for another thread to win a</span></span><br><span class="line"><span class="comment"> * race to enqueue after this method has returned &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment"> * due to the queue being empty.</span></span><br><span class="line"><span class="comment"> * 请注意，由于中断和超时引起的取消可能随时发生，</span></span><br><span class="line"><span class="comment"> * 因此&#123;<span class="doctag">@code</span> true&#125;返回值不能保证某些其他线程将在当前线程之前获取。</span></span><br><span class="line"><span class="comment"> * 同样，由于队列为空，因此此方法返回&#123;<span class="doctag">@code</span> false&#125;后，另一个线程也有可能赢得竞争。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is designed to be used by a fair synchronizer to</span></span><br><span class="line"><span class="comment"> * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> * Such a synchronizer&#x27;s &#123;<span class="doctag">@link</span> #tryAcquire&#125; method should return</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125;, and its &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; method should</span></span><br><span class="line"><span class="comment"> * return a negative value, if this method returns &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * (unless this is a reentrant acquire).  For example, the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * tryAcquire&#125; method for a fair, reentrant, exclusive mode</span></span><br><span class="line"><span class="comment"> * synchronizer might look like this:</span></span><br><span class="line"><span class="comment"> * 方法设计为由公平同步器使用，以避免&lt;a href=&quot;AbstractQueuedSynchronizerbarging&quot;&gt;插入&lt;a&gt;。</span></span><br><span class="line"><span class="comment"> * 此类同步器的&#123;<span class="doctag">@link</span> tryAcquire&#125;方法应返回&#123;<span class="doctag">@code</span> false&#125;，并且如果此方法返回&#123;<span class="doctag">@code</span> true&#125;（除非这是可重入获取），则其&#123;<span class="doctag">@link</span> tryAcquireShared&#125;方法应返回负值。</span></span><br><span class="line"><span class="comment"> * 例如，用于公平，可重入，互斥模式同步器的&#123;<span class="doctag">@code</span> tryAcquire&#125;方法可能如下所示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment"> *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment"> *     // A reentrant acquire; increment hold count</span></span><br><span class="line"><span class="comment"> *     return true;</span></span><br><span class="line"><span class="comment"> *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment"> *     return false;</span></span><br><span class="line"><span class="comment"> *   &#125; else &#123;</span></span><br><span class="line"><span class="comment"> *     // try to acquire normally</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment"> *         current thread, and &#123;<span class="doctag">@code</span> false&#125; if the current thread</span></span><br><span class="line"><span class="comment"> *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// 正确性取决于 head 被初始化</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    <span class="comment">// 如果当前线程是第一个入队，则在tail和head.next之前是准确的。</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order </span></span><br><span class="line">    <span class="comment">// 以相反的初始化顺序读取字段</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--AQS</title>
      <link href="2020/12/31/java/juc/java-juc-AQS/"/>
      <url>2020/12/31/java/juc/java-juc-AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><ul><li> AQS ： AbstractQueuedSynchronizer ，即队列同步器。 是一个用来构建锁和同步器的框架</li></ul><h1 id="AQS-的原理"><a href="#AQS-的原理" class="headerlink" title="AQS 的原理"></a>AQS 的原理</h1><ul><li>如果请求的资源空闲，当前请求资源的线程就可以获取资源，并且给资源加上锁。如果当前请求的资源被占用，就需要一套阻塞和唤醒机制， AQS 使用 CLH 队列实现，将目前获取不到资源的锁的现场，加入到队列中</li><li>CLH  队列<ul><li>AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个节点 （Node） 来实现锁的分配。</li><li>虚拟的双向队列，并没有队列实例，仅存在节点间的指向关系。</li></ul></li><li>AQS 使用一个volatile int state 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。 AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</li></ul><blockquote><p>AQS结构大概由3部分组成：</p><ol><li>用 volatile 修饰的整数类型的 state 状态，用于表示同步状态，提供 getState 和 setState 来操作同步状态</li><li>提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心</li><li>AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法</li></ol></blockquote><h1 id="AQS-资源共享方式"><a href="#AQS-资源共享方式" class="headerlink" title="AQS 资源共享方式"></a>AQS 资源共享方式</h1><ul><li> Exclusive (独占)：：只有一个线程能执行， 如 ReentantLock</li><li>Share（共享）：多个线程可同时执行， 如 Semaphore/CountDownLatch</li></ul><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>在 AQS 独占式资源共享方式中</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到先拿到锁。</li><li>非公平锁：当线程要获取锁时，无视队列的顺序直接去抢锁（CAS），谁先抢到就是谁的</li></ul><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><ul><li>以 ReentrantLock 为例， state 初始化为 0 ， 表示未锁定状态。 A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 share +1 。此后，其他线程再 tryAcquire() 时就会失败， 直到 A 线程 unlock() 到 state = 0 （即释放锁）为止， 其他线程才有机会获取该锁。当然，锁释放之前， A 线程自己是可以重复获取此锁的 （state 会累加），这就是可重入的概念。但是要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的</li></ul><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><ul><li>再以 CountDownLatch 为例，任务分配为 N 个线程去执行， state 也初始化为 N（注意 N 要与线程个数一致）。 该 N 个子线程是并行执行的， 每个子线程执行完后 countDown() 一次， state 会 CAS 减1。等到所有子线程都执行完后 （即 state =0）, 会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</li><li>（倒计时器）： CountDownLatch 是一个同步工具类， 用来协调多个线程之间同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，在开始执行。</li></ul><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><ul><li>Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源， Semaphore （信号量）可以指定多个线程同时访问某个资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> num = i;</span><br><span class="line">       cachedThreadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//请求获得许可，如果有可获得的许可则继续往下执行，许可数减1。否则进入阻塞状态</span></span><br><span class="line">                   semaphore.acquire();</span><br><span class="line">                   <span class="comment">//执行</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;Accessing: &quot;</span> + num);</span><br><span class="line">                   Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 模拟随机执行时长</span></span><br><span class="line">                   <span class="comment">//释放</span></span><br><span class="line">                   semaphore.release();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Release...&quot;</span> + num);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cachedThreadPool.shutdown();</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h1><ul><li>可以实现线程间的技术等待</li><li>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--JMM和volatile关键字</title>
      <link href="2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM和volatile关键字"><a href="#JMM和volatile关键字" class="headerlink" title="JMM和volatile关键字"></a>JMM和volatile关键字</h1><h1 id="JMM相关"><a href="#JMM相关" class="headerlink" title="JMM相关"></a>JMM相关</h1><h2 id="CPU缓存模型"><a href="#CPU缓存模型" class="headerlink" title="CPU缓存模型"></a>CPU缓存模型</h2><blockquote><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。<strong>于是就有了在CPU和主内存之间增加缓存的设计</strong>。最靠近CPU的缓存称为L1，然后依次是 L2，L3和主内存，CPU缓存模型如图下图所示。</p><ul><li>CPU访问数据 -&gt; L1 L2 高速缓存 -&gt; 一致性协议 -&gt; 内存</li></ul></blockquote><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609942893338.png" alt="1609942893338"></p><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><ul><li><p>JMM描述的是变量存储到内存和从内存中读取变量的细节。</p></li><li><p>Java中实例变量和类变量都是存在于主内存，是线程共享的。</p><blockquote><ul><li>每个线程都有一个自己的工作内存，它从主内存读取数据到工作内存中进行使用。这样就可能造成了一个线程在主内存中修改了一个变量的值，而另一个线程还在使用之前拷贝的值，就造成了数据的不一致型。</li><li>解决：把变量声明为volatile，指示这个变量是不稳定的，没用使用的时候需要从主内存中读取。</li></ul></blockquote></li></ul><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609943944217.png" alt="1609943944217"></p><blockquote><ul><li>主内存 所有线程共享的内存区域 线程内存 线程自己私有的内存区域 主内存和线程内存通过save和load操作进行交互 所有提到的内存区域并不是真实存在的，而是虚拟存在的，就和虚拟机的运行时数据区一样。</li></ul></blockquote><h2 id="JMM-的八种内存交互操作"><a href="#JMM-的八种内存交互操作" class="headerlink" title="JMM 的八种内存交互操作"></a>JMM 的八种内存交互操作</h2><p><img src="/2020/12/31/java/juc/java-juc-jmm%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/1609946346742.png" alt="1609946346742"></p><ol><li>lock(锁定)：作用于<strong>主内存</strong>中的变量，一个变量在同一时间只能被一个线程锁定，即把变量标识为线程<strong>独占</strong>状态。</li><li>read(读取)：作用于<strong>主内存</strong>变量，表示把一个变量值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。</li><li>load(载入)：作用于线程的<strong>工作内存</strong>的变量，表示把 read 操作从主内存中读取的变量值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。</li><li>use(使用)：作用于线程的<strong>工作内存</strong>中的变量，表示把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。</li><li>assign(赋值)：作用于线程的<strong>工作内存</strong>的变量，表示把执行引擎返回的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。</li><li>store(存储)：作用于线程的<strong>工作内存</strong>中的变量，把工作内存中的一个变量的值传递给主内存，以便下一步的 write 操作使用。</li><li>write(写入)：作用于<strong>主内存</strong>的变量，表示把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，表示把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ol><p>JMM 还规定了以上八种操作需按照如下规则进行：</p><ul><li>不允许read 和 load、store 和 write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许线程将没有 assign 的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施 use 和 store 操作之前，必须经过 load 和 assign 操作。</li><li>一个变量同一时间只能有一个线程对其进行 lock 操作。但 lock 操作可以被同一条线程重复执行多次，多次 lock 之后，必须执行相同次数 unlock 才可以解锁。</li><li>如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。</li><li>如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="JMM-三大特征"><a href="#JMM-三大特征" class="headerlink" title="JMM 三大特征"></a>JMM 三大特征</h2><blockquote><p>JMM 三大特征分别是：原子性，可见性，有序性。整个 JMM 实际上也是围绕着这三个特征建立起来的，并且也是 Java 并发编程的基础。</p></blockquote><p><strong>原子性</strong>：原子性是指一个操作是不可分割、不可中断的，要么全部执行成功要么全部执行失败。</p><ul><li>synchronized 修饰的代码块之间的操作都是原子性的，<strong>volatile不保证原子性</strong></li></ul><p><strong>可见性</strong>：可见性是指所有线程都能看到共享内存的最新状态。即当一个线程修改了一个共享变量的值时，其他线程能够立即看到该变量的最新值。</p><ul><li>volatile 关键字之外，final 和 synchronized 也能实现可见性。</li></ul><p><strong>有序性</strong>：有序性是指程序执行的顺序按照代码的先后顺序执行。</p><ul><li><p>可以通过 volatile 和 synchronized 关键字来保证多线程之间操作的有序性。</p><ul><li><p>volatile 关键字是通过在主存中加入内存屏障来达到禁止指令重排序，来保证有序性。</p></li><li><p>synchronized 关键字原理是，一个变量在同一时刻只能被一个线程 lock，并且必须 unlock 后，其他线程才可以重新 lock，使得被 synchronized 修饰的代码块在多线程之间是串行执行的。</p></li></ul></li></ul><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ul><li>volatitle可以保证变量的可见性。</li></ul><h2 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h2><ul><li>volatile写是在前⾯和后⾯分别插⼊<strong>内存屏障</strong>，⽽volatile读操作是在后⾯插⼊两个内存屏障。</li></ul><h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><blockquote><p>compare-and-swap–比较并替换</p></blockquote><ul><li>CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：如果当前值等于预期值，则将内存修改为新值，否则不做任何操作。</li><li>Java中Unsafe类</li><li>每次在执行CAS操作时，线程会根据valueOffset去内存中获取当前值去跟expect的值做对比如果一致则修改并返回true，如果不一致说明有别的线程也在修改此对象的值，则返回false</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><ul><li>一个线程对变量进行了修改，然后又修改会原来的值，对于其他线程来说好像没有变化。</li><li>解决ABA最简单的方案就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号</li></ul><h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><ul><li>volatile是线程同步的轻量级实现，只能修饰变量；而synchronized可以修饰方法及代码块</li><li>volatile关键字能够保证数据的可见性，不能保证数据的原子性；synchronized两者都可以保证</li><li>volatile解决的是多个线程访问变量的可见性；synchronized解决的是多线程之间访问资源的同步性</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--synchronized</title>
      <link href="2020/12/31/java/juc/java-juc-synchronized/"/>
      <url>2020/12/31/java/juc/java-juc-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>synchronized 是为了解决多线程同步访问资源的问题。 synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</li><li>Java多线程依赖于操作系统原生线程，所以挂起或者唤醒一个线程，需要操作系统帮忙完成。而操作系统需要从用户状态切换成内核状态，时间相对较长，时间成本高。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>修改实例方法：作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</p><blockquote><p>多个线程操作同一个实例的加锁方法时，线程安全</p></blockquote></li><li><p>修饰静态方法：作用于当前类对象(Class对象，每个类都有一个Class对象)，进入同步代码前要获得当前类对象（Class对象）的锁。</p><blockquote><p>多个线程操作同一个Class的多个实例时，线程安全。（如果是非静态方法加的synchronized那么则是不安全的，因为不是同一把锁）</p></blockquote></li><li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p><blockquote><ul><li><p>synchronized(this){}，当前实例对象锁</p></li><li><p>synchronized(ObjA.class){}，class对象锁</p></li></ul></blockquote></li></ul><blockquote><ul><li>在 java 中，每一个对象有且仅有一个同步锁。这也意味着：同步锁是依赖于对象存在的。</li><li>当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。（例如：synchronized(ObjA) 就获取了 “ObjA这个对象” 的同步锁）</li><li>不同线程对同步锁的访问是互斥的。（也就是说：某个时间点，对象的同步锁只能被一个线程获取到，通过同步锁，能实现多线程间 “对象/方法” 的互斥访问）</li></ul></blockquote><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>HotSpot 虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头</strong>（Header），<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong></p><ul><li>普通对象的对象头包含两个部分：<strong>Mark Word</strong> 和 <strong>Class Metadata Address</strong> （类型指针）</li><li>如果是数组的对象头还额外包括 <strong>Array length</strong> 数组长度部分</li></ul><h3 id="Mark-word："><a href="#Mark-word：" class="headerlink" title="Mark word："></a>Mark word：</h3><ul><li>用于存储对象自身的运行时数据，如 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li></ul><h3 id="Class-Metadata-Address：类型指针"><a href="#Class-Metadata-Address：类型指针" class="headerlink" title="Class Metadata Address：类型指针"></a>Class Metadata Address：类型指针</h3><ul><li>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪一个类的实例</li></ul><h3 id="Array-length：数组长度"><a href="#Array-length：数组长度" class="headerlink" title="Array length：数组长度"></a>Array length：数组长度</h3><ul><li>如果对象是数组类型。则虚拟机用3个 Word （字宽）存储对象头，如果对象是非数组类型，则用 2 字节宽存储对象头。在 32 位虚拟机中，一字节宽等于 4 字节，及 32bit。</li></ul><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象hashCode或锁信息等运行时数据。</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><h4 id="Mark-Word详解"><a href="#Mark-Word详解" class="headerlink" title="Mark Word详解"></a>Mark Word详解</h4><p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><blockquote><p>例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，MarkWord的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，</p><p>在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p></blockquote><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609892506114.png" alt="1609892506114"></p><h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><ul><li><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做<strong>内部锁</strong>或者<strong>Monitor锁</strong>。</p></li><li><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系又存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header       = <span class="literal">NULL</span>;</span><br><span class="line">   _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">   _waiters      = <span class="number">0</span>,</span><br><span class="line">   _recursions   = <span class="number">0</span>;</span><br><span class="line">   _object       = <span class="literal">NULL</span>;</span><br><span class="line">   _owner        = <span class="literal">NULL</span>;</span><br><span class="line">   _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">   _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">   _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">   _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="/2020/12/31/java/juc/java-juc-synchronized/1609893330560.png" alt="1609893330560"></p><h2 id="synchronized-关键字底层原理是JVM层面的"><a href="#synchronized-关键字底层原理是JVM层面的" class="headerlink" title="synchronized 关键字底层原理是JVM层面的**"></a>synchronized 关键字底层原理是JVM层面的**</h2><h3 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h3><ol><li>synchronized 同步语句块的实现使用的是 <strong>monitorenter</strong> 和 <strong>monitoreexit</strong> 指令， 其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置</li><li>当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor 对象的特有权。<strong>当计数器为 0 则可以成功获取monitor</strong>，获取后将锁计数器设为 1 就是 加1 （<strong>重入时计数器的值也会加 1</strong>）， 。相对应的在执行 monitorexit 指令后， 所得计数器就会 -1，当锁计数器变为0，标明锁被释放。</li><li>如果获取对象的锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</li><li>（monitor 对象存在于每个 java 对象的对象头中 ，synchronized 锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因）</li></ol><h3 id="synchronized-修饰方法的情况"><a href="#synchronized-修饰方法的情况" class="headerlink" title="synchronized 修饰方法的情况"></a>synchronized 修饰方法的情况</h3><ol><li><p>JVM 通过 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p></li><li><p>用的是一个隐式的 monitorenter 和 monitorexit 指令。</p><blockquote><ol><li>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。</li><li>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</li><li>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词），然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</li><li>在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</li></ol></blockquote></li></ol><h2 id="synchronized-锁优化的过程（锁升级）"><a href="#synchronized-锁优化的过程（锁升级）" class="headerlink" title="synchronized 锁优化的过程（锁升级）"></a>synchronized 锁优化的过程（锁升级）</h2><ul><li>锁的状态有：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，随着锁竞争的激烈而逐渐升级。锁只可以升级不可以降级，这种策略是为了提高获取锁和释放锁的效率。</li></ul><blockquote><p>Synchronized的实现依赖于与某个对象向关联的monitor（监视器）实现，而monitor是基于底层操作系统的Mutex Lock实现的，而基于Mutex Lock实现的同步必须经历从用户态到核心态的转换，这个开销特别大，成本非常高。所以频繁的通过Synchronized实现同步会严重影响到程序效率，而这种依赖于Mutex Lock实现的锁机制也被称为“重量级锁”，为了减少重量级锁带来的性能开销，JDK对Synchronized进行了种种优化。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li>单个线程重复访问资源的时候没有必要向操作系统重新申请轻量级锁。</li></ul><h4 id="获取锁："><a href="#获取锁：" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><h4 id="释放锁："><a href="#释放锁：" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><p><strong>偏向锁的释放采用了一种只有竞争才会释放锁的机制</strong>，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><blockquote><p>在有锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里?</p><p>下面先看偏向锁的情况，偏向锁时，mark word中记录了线程id，没有足够的额外空间存储hashcode，所以，答案是：</p><ol><li>当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；</li><li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li><li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。</li></ol><p>因为mark word里没地方同时放bias信息和identity hash code。 HotSpot VM是假定“实际上只有很少对象会计算identity hash code”来做优化的；换句话说如果实际上有很多对象都计算了identity hash code的话，HotSpot VM会被迫使用比较不优化的模式。</p></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>多个线程重复访问资源的时候，可以使用指针竞争的方式来获取轻量级锁</li></ul><h4 id="获取锁：-1"><a href="#获取锁：-1" class="headerlink" title="获取锁："></a><strong><em>获取锁</em></strong>：</h4><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><h4 id="释放锁：-1"><a href="#释放锁：-1" class="headerlink" title="释放锁："></a><strong><em>释放锁</em></strong>：</h4><pre><code>&gt; 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</code></pre><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p><blockquote><p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p></blockquote><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><ul><li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li>如果没有在第一时间获取到轻量级锁，可能需要等一会儿就可以获取锁。这时使用 CAS 的操作不断自旋该线程。默认限定 10 次，没有获取锁，就用传统方式挂起线程。</li><li>在自旋的基础上， Java1.6 引入了适应性自旋锁。它的等待时间不是固定的，而是由前一次操作的时间以及锁拥有的状态来决定。</li></ul><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><ul><li><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p></li><li><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p></li></ul><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul><li>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法。</li></ul><h3 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h3><ul><li>偏向锁：通常只有一个线程访问临界区</li><li>轻量级锁：可以有多个线程交替进入临界区，竞争不激烈的时候，稍微自旋就能获得锁</li><li>重量级锁：线程间出现激烈的竞争就需要重量级锁，未获得锁的线程就会进入阻塞队列，需要操作系统介入。</li></ul><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的开销，和执行非同步方法比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td><td>追求响应时间。同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>锁竞争不适用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="锁的膨胀流程图解"><a href="#锁的膨胀流程图解" class="headerlink" title="锁的膨胀流程图解"></a>锁的膨胀流程图解</h3><p><img src="/2020/12/31/java/juc/java-juc-synchronized/165adaeab7580a64.png" alt="165adaeab7580a64"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程--基本概念</title>
      <link href="2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>2020/12/31/java/juc/java-juc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li>进程：程序的一次执行过程，程序的运行就是一个进程从创建、运行到消亡的过程。进程是计算机运行的基本单位，进程之间是相互独立的。</li><li>线程：线程是 CPU 执行的基本单位，一个进程可以分为多个线程，多个线程对进程的资源使用存在竞争关系。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>创建：线程 new 之后进入创建状态，调用 start() 方法进入就绪状态。</li><li>就绪：线程就绪状态需要等待 CPU 调用执行</li><li>运行：线程获取了 CPU 时间，进入运行中状态</li><li>等待：wait、join、LockSupport.park 进入等待状态，需要其他线程通知才能进入运行状态 （notify、notifyAll、LockSupport.unPark）</li><li>超时等待：在等待的基础上加了一个超时时间，超时时间到了就自动进入运行状态（sleep，wait（long），LockSupport.pariUntil，LockSupport.parkNanos）</li><li>阻塞：线程调用同步方法或者代码块，未获得锁时，进入阻塞状态</li><li>终止：线程执行完 run 方法后进入终止状态</li></ul><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li>并行：多个处理器上，执行多个任务</li><li>并发：单个处理器上，多个任务交替执行。线程通过轮询获取 CPU 的执行时间。</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>多个线程同时被阻塞，他们中的一个或者多个都在等待某个资源被释放。由于无限期的阻塞，线程无法正常终止。</li></ul><h2 id="线程死锁的四个必要条件"><a href="#线程死锁的四个必要条件" class="headerlink" title="线程死锁的四个必要条件"></a>线程死锁的四个必要条件</h2><ul><li>互斥条件：某一个资源某一时刻只能有一个线程使用</li><li>请求和保持条件：一个线程在请求其他资源的时候，对其中持有的资源不释放</li><li>不可剥夺条件：线程已获得的资源在未使用的情况下不能被其他线程强行剥夺，只能由该线程使用完毕后自己释放</li><li>循环等待条件：多个线程形成的一种首位相接的等待资源的关系。</li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ul><li><p>破坏线程死锁产生的四个条件之一</p><blockquote><ul><li>破坏互斥条件：这个条件我们没法破坏，因为我们用锁本来就是想让他们互斥（临界资源需要互斥访问）</li><li>破坏请求和保持条件：一次性申请所有的资源。</li><li>破坏不可剥夺条件：占用部分资源的现场进一步申请其他资源时，如果申请不到，可以主动释放他自己占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。</li></ul></blockquote></li></ul><h2 id="sleep和yeild方法"><a href="#sleep和yeild方法" class="headerlink" title="sleep和yeild方法"></a>sleep和yeild方法</h2><ul><li>sleep方法在超时等待一定时间后会自动唤醒，进入就绪状态；yield方法是当前线程进入就绪状态线程调</li><li>sleep方法后，无论其他线程的优先级都有机会运行；执行yield方法，只会给相同优先级或更高优先级的方法的线程运行的机会</li><li>sleep方法会抛出InterruptedException异常，而yield方法没有任何异常声明</li><li>循环中调用yield方法，yield死循环：线程yield之后有获得了cpu，导致其他线程无法获取资源</li></ul><h2 id="调用start方法，为什么不直接调用run方法"><a href="#调用start方法，为什么不直接调用run方法" class="headerlink" title="调用start方法，为什么不直接调用run方法"></a>调用start方法，为什么不直接调用run方法</h2><ul><li>调用 start 方法方可启动线程并使线程进入就绪状态，</li><li>而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</li></ul><h2 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h2><ul><li>继承Thread类</li><li>实现Runable接口，实现run方法</li><li>实现Callable接口，实现call方法</li><li>使用线程池</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc学习--参考狂神说JUC视频笔记</title>
      <link href="2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://gitee.com/kuangstudy/openclass/tree/master/%E3%80%90%E9%81%87%E8%A7%81%E7%8B%82%E7%A5%9E%E8%AF%B4%E3%80%91JUC%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0">[遇见狂神说]JUC视频笔记</a></p><h1 id="什么是-JUC"><a href="#什么是-JUC" class="headerlink" title="什么是 JUC"></a>什么是 JUC</h1><ul><li>JUC 就是 java.util.concurrent 下面的类包，专门用于多线程的开发。</li></ul><h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="线程和进程-1"><a href="#线程和进程-1" class="headerlink" title="线程和进程"></a>线程和进程</h2><ul><li><p>进程：是代码在数据集合上的一次运行活动， 是<strong>系统</strong>进行资源分配和调度的基本单位。</p><blockquote><p>一个进程往往可以包含多个线程，至少包含一个！<br>Java默认有几个线程？ 2 个 mian、GC </p></blockquote></li><li><p>线程：是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><blockquote><p>对于Java而言：Thread、Runnable、Callable</p></blockquote></li></ul><h3 id="java如何开启线程（开不了）"><a href="#java如何开启线程（开不了）" class="headerlink" title="java如何开启线程（开不了）"></a>java如何开启线程（开不了）</h3><ul><li>Java 真的可以开启线程吗？ 开不了</li></ul><p>Java 没有权限开启线程 、Thread.start() 方法调用了一个 native 方法 start0()，它调用了底层 C++ 代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment"> * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment"> * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment"> * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment"> * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">group.add(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">start0();</span><br><span class="line">started = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!started) &#123;</span><br><span class="line">group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line"><span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">it will be passed up the call stack */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本地方法，底层的C++ ，Java 无法直接操作硬件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发编程（本质：充分利用CPU的资源）：</p><ul><li>并发（多线程操作同一个资源）<ul><li>CPU 一核 ，模拟出来多条线程，天下武功，唯快不破，快速交替</li></ul></li><li>并行（多个人一起行走）<ul><li>CPU 多核 ，多个线程可以同时执行； 线程池</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * juc测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月05日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 CPU 的核数</span></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的几个状态"><a href="#线程的几个状态" class="headerlink" title="线程的几个状态"></a>线程的几个状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新生</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">// 运行</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">// 等待，死死地等待</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">// 超时等待</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">// 终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait-sleep-区别"><a href="#wait-sleep-区别" class="headerlink" title="wait/sleep 区别"></a>wait/sleep 区别</h2><table><thead><tr><th></th><th>wait</th><th>sleep</th></tr></thead><tbody><tr><td>来自不同的类</td><td>Object</td><td>Thread</td></tr><tr><td>关于锁的释放</td><td>会释放锁</td><td>抱着锁睡觉，不会释放！</td></tr><tr><td>使用的范围是不同的</td><td>必须在同步代码块中</td><td>可以在任何地方睡</td></tr><tr><td>是否需要捕获异常</td><td>不需要</td><td>需要</td></tr></tbody></table><h1 id="Lock锁（重点）"><a href="#Lock锁（重点）" class="headerlink" title="Lock锁（重点）"></a>Lock锁（重点）</h1><h2 id="传统-Synchronized"><a href="#传统-Synchronized" class="headerlink" title="传统 Synchronized"></a>传统 Synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;</span><br><span class="line">ticket.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;</span><br><span class="line">ticket.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;</span><br><span class="line">ticket.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-C&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:正在出售&quot;</span> + number-- + <span class="string">&quot;的票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612515367488.png" alt="1612515367488"></p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612515389393.png" alt="1612515389393"></p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612515616611.png" alt="1612515616611"></p><p>公平锁：十分公平：可以先来后到<br>非公平锁：十分不公平：可以插队 （默认）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;ticket.sale();&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;</span><br><span class="line">ticket.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">50</span> ; i++) &#123;</span><br><span class="line">ticket.sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;thread-C&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock三部曲</span></span><br><span class="line"><span class="comment">// 1、 new ReentrantLock();</span></span><br><span class="line"><span class="comment">// 2、 lock.lock(); // 加锁</span></span><br><span class="line"><span class="comment">// 3、 finally=&gt; lock.unlock(); // 解锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:正在出售&quot;</span> + number-- + <span class="string">&quot;的票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized-和-Lock-区别"><a href="#Synchronized-和-Lock-区别" class="headerlink" title="Synchronized 和 Lock 区别"></a>Synchronized 和 Lock 区别</h2><ol><li>Synchronized 内置的Java关键字， Lock 是一个Java类</li><li>Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁</li><li>Synchronized 会自动释放锁，lock 必须要手动释放锁！<strong>如果不释放锁，死锁</strong></li><li>Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下<br>去，<strong>lock会有一个trylock去尝试获取锁</strong>，不会造成长久的等待</li><li>Synchronized 可重入锁，不可以中断的，非公平；Lock ，可重入锁，可以 判断锁，非公平（可以<br>自己设置）；</li><li>Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！</li></ol><h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h1><h2 id="Synchronized版本"><a href="#Synchronized版本" class="headerlink" title="Synchronized版本"></a>Synchronized版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题，生产者和消费者问题！ 等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 现场交替执行， A B 同时操作一个变量 number = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04pcSynchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Data01 data = <span class="keyword">new</span> Data01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.increment();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.decrement();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类：数字</span></span><br><span class="line"><span class="comment"> * 判断</span></span><br><span class="line"><span class="comment"> * 等待</span></span><br><span class="line"><span class="comment"> * 业务通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number != <span class="number">0</span>) &#123; <span class="comment">// != 0</span></span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line"><span class="comment">// 通知其他线程， 我+1完毕</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line">number--;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line"><span class="comment">// 通知其他线程，我-1完毕</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存在问题：虚假唤醒"><a href="#存在问题：虚假唤醒" class="headerlink" title="存在问题：虚假唤醒"></a>存在问题：虚假唤醒</h3><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612663439715.png" alt="1612663439715"></p><h4 id="if-改为-while-判断"><a href="#if-改为-while-判断" class="headerlink" title="if 改为 while 判断"></a>if 改为 while 判断</h4><blockquote><p>结论：就是用if判断的话，唤醒后线程会从 wait 之后的代码开始运行，但是不会重新判断 if 条件，直接继续运行 if 代码块之后的代码，而如果使用 while 的话，也会从 wait 之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行 while 代码块之后的代码块，成立的话继续 wait 。</p><p>这也就是为什么用 while 而不用 if 的原因了，因为线程被唤醒后，执行开始的地方是 wait 之后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题，生产者和消费者问题！ 等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 现场交替执行， A B 同时操作一个变量 number = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04pcSynchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Data01 data = <span class="keyword">new</span> Data01();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.increment();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.decrement();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类：数字</span></span><br><span class="line"><span class="comment"> * 判断</span></span><br><span class="line"><span class="comment"> * 等待</span></span><br><span class="line"><span class="comment"> * 业务</span></span><br><span class="line"><span class="comment"> * 通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">0</span>) &#123; <span class="comment">// != 0</span></span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务</span></span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line"><span class="comment">// 通知其他线程， 我+1完毕</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务</span></span><br><span class="line">number--;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line"><span class="comment">// 通知其他线程，我-1完毕</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUC版"><a href="#JUC版" class="headerlink" title="JUC版"></a>JUC版</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612664944626.png" alt="1612664944626"></p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612667627398.png" alt="1612667627398"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05pcJuc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Data02 data = <span class="keyword">new</span> Data02();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.increment();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.decrement();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.increment();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-C&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">data.decrement();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-D&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data02</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line">condition.await();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务</span></span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">condition.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line">condition.wait();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务</span></span><br><span class="line">number--;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;=&gt;&quot;</span> +number);</span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">condition.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition的优势"><a href="#Condition的优势" class="headerlink" title="Condition的优势"></a>Condition的优势</h3><ul><li>精准的通知和唤醒的线程！<ul><li>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06pcCondition</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Data03 data = <span class="keyword">new</span> Data03();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">data.printA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">data.printB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">data.printC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-C&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data03</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition1 = lock.newCondition();<span class="comment">// A:1</span></span><br><span class="line">Condition condition2 = lock.newCondition();<span class="comment">// B:2</span></span><br><span class="line">Condition condition3 = lock.newCondition();<span class="comment">// C:3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">condition1.await();</span><br><span class="line">&#125;</span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;-&gt; AAAA&quot;</span>);</span><br><span class="line">condition2.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">condition2.await();</span><br><span class="line">&#125;</span><br><span class="line">number++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;-&gt; BBBB&quot;</span>);</span><br><span class="line">condition3.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">condition3.await();</span><br><span class="line">&#125;</span><br><span class="line">number = <span class="number">1</span>;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;-&gt; CCCC&quot;</span>);</span><br><span class="line">condition1.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612674225519.png" alt="1612674225519"></p><h1 id="8锁现象"><a href="#8锁现象" class="headerlink" title="8锁现象"></a>8锁现象</h1><ul><li>如何判断锁的是谁！永远的知道什么锁，锁到底锁的是谁！</li><li>深刻理解我们的锁</li></ul><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话<ol><li>发短信</li><li>打电话</li></ol></li></ul><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话<ol><li>发短信</li><li>打电话</li></ol></li></ul><p><strong>总结</strong></p><ul><li>synchronized 锁的对象是方法的调用者！</li><li>两个方法用的是同一个锁，谁先拿到谁执行！</li></ul><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.hello();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增一个方法，不加 synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>新增一个普通方法，不加 synchronized?<ol><li>hello</li><li>发短信</li></ol></li></ul><p><strong>总结</strong></p><ul><li>新增方法没有锁！不是同步方法，不受锁的影响，故最先直接输出</li></ul><h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> * 4、两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone1.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone2.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>两个对象，两个同步方法， 发短信还是 打电话？<ol><li>打电话</li><li>发短信</li></ol></li></ul><p><strong>总结</strong></p><ul><li>两个对象，两个调用者，两把锁！</li></ul><h2 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> * 4、两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？<ol><li>发短信</li><li>打电话</li></ol></li></ul><h2 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> * 4、两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone1.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone2.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？<ol><li>发短信</li><li>打电话</li></ol></li></ul><p><strong>总结</strong></p><ul><li>synchronized 锁的对象是方法的调用者！</li><li>static 静态方法。 类一加载就有了！锁的是Class</li></ul><h2 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> * 4、两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 7、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？<ol><li>打电话</li><li>发短信</li></ol></li></ul><p><strong>总结</strong></p><ul><li>不是同一把锁</li></ul><h2 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.lock8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁，就是关于锁的8个问题</span></span><br><span class="line"><span class="comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 2、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span></span><br><span class="line"><span class="comment"> * 3、新增一个普通方法，不加 synchronized?</span></span><br><span class="line"><span class="comment"> * 4、两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span></span><br><span class="line"><span class="comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 7、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> * 8、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Phone phone1 = <span class="keyword">new</span> Phone();</span><br><span class="line">Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone1.sendSms();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">phone2.call();</span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><ul><li>1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？<ol><li>打电话</li><li>发短信</li></ol></li></ul><p><strong>总结</strong></p><ul><li>不是同一把锁</li></ul><h2 id="8锁现象总结"><a href="#8锁现象总结" class="headerlink" title="8锁现象总结"></a>8锁现象总结</h2><p>只有同一把锁，才会等待</p><ol><li>static + synchronized 修饰 ：锁定的是整个 class</li><li>非 static 修饰 ： 锁定的是 实例</li></ol><h1 id="集合不安全"><a href="#集合不安全" class="headerlink" title="集合不安全"></a>集合不安全</h1><h2 id="List不安全"><a href="#List不安全" class="headerlink" title="List不安全"></a>List不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01List</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Object&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会导致 java.util.ConcurrentModificationException 并发修改异常！</p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612686710662.png" alt="1612686710662"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>List list = new Vector&lt;&gt;();</li><li>List list = Collections.synchronizedList(new ArrayList&lt;&gt;());</li><li>List list = new CopyOnWriteArrayList&lt;&gt;()；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01List</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">// List&lt;Object&gt; arrayList = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">// List&lt;Object&gt; arrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line">List&lt;Object&gt; arrayList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong></li><li><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。</li><li><strong>CopyOnWriteArrayList</strong>使用的是Lock锁，效率会更加高效！</li></ul><h2 id="Set不安全"><a href="#Set不安全" class="headerlink" title="Set不安全"></a>Set不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Set</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;Object&gt; set = <span class="keyword">new</span> HashSet&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612687190364.png" alt="1612687190364"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>Set set = Collections.synchronizedSet(new HashSet&lt;&gt;());</li><li>Set set = new CopyOnWriteArraySet&lt;&gt;();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Set</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();</span></span><br><span class="line"><span class="comment">// Set&lt;Object&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">Set&lt;Object&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map不安全"><a href="#Map不安全" class="headerlink" title="Map不安全"></a>Map不安全</h2><p>ConcurrentHashMap 源码理解</p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612687582849.png" alt="1612687582849"></p><ol><li>可以有返回值</li><li>可以抛出异常</li><li>方法不同，run()/ call()</li></ol><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612688153209.png" alt="1612688153209"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Callable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// new Thread(new Runnable()).start();</span></span><br><span class="line"><span class="comment">// new Thread(new FutureTask&lt;V&gt;()).start();</span></span><br><span class="line"><span class="comment">// new Thread(new FutureTask&lt;V&gt;( Callable )).start();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(myThread);</span><br><span class="line"><span class="keyword">new</span> Thread(futureTask, String.valueOf(i)).start();</span><br><span class="line"><span class="comment">//这个get 方法可能会产生阻塞！把他放到</span></span><br><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>) futureTask.get();</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is called&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细节：<br>1、有缓存<br>2、结果可能需要等待，会阻塞！</p><h1 id="常用的辅助类-必会"><a href="#常用的辅助类-必会" class="headerlink" title="常用的辅助类(必会)"></a>常用的辅助类(必会)</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612688474859.png" alt="1612688474859"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01CountDownLatch</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：Go out&quot;</span>);</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待计数器归零，然后再向下</span></span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;Close Door&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解析（减法计数器）"><a href="#解析（减法计数器）" class="headerlink" title="解析（减法计数器）"></a>解析（减法计数器）</h3><blockquote><p>每次有线程调用 countDown() 数量 -1，假设计数器变为 0，countDownLatch.await() 就会被唤醒，继续执行！</p></blockquote><ul><li><p>countDownLatch.countDown(); // 数量-1</p></li><li><p>countDownLatch.await(); // 等待计数器归零，然后再向下执行</p></li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612688495451.png" alt="1612688495451"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02CyclicBarrier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;召唤神龙！&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tmp = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收到&quot;</span> + tmp + <span class="string">&quot;星龙珠&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cyclicBarrier.await(); <span class="comment">// 等待</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析（加法计数器）"><a href="#解析（加法计数器）" class="headerlink" title="解析（加法计数器）"></a>解析（加法计数器）</h3><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612688507306.png" alt="1612688507306"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月07日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Semaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开车位&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解析（信号量）"><a href="#解析（信号量）" class="headerlink" title="解析（信号量）"></a>解析（信号量）</h3><blockquote><p>作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！</p></blockquote><ul><li><p><code>semaphore.acquire()</code> 获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！</p></li><li><p><code>semaphore.release()</code> 释放，会将当前的信号量释放+1，然后唤醒等待的线程！</p></li></ul><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612762016569.png" alt="1612762016569"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ReadWriteLock</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Cache1 cache = new Cache1();</span></span><br><span class="line">Cache2 cache = <span class="keyword">new</span> Cache2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> finalI = i;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">cache.write(String.valueOf(finalI), String.valueOf(finalI));</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> finalI = i;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">cache.read(String.valueOf(finalI));</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始写入&quot;</span>);</span><br><span class="line">cacheMap.put(key, value);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:写入OK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始读取&quot;</span>);</span><br><span class="line">String value = cacheMap.get(key);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:读取Ok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache2</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 读写锁：更加细腻的控制</span></span><br><span class="line"><span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写  只希望同时只有一个线写入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">readWriteLock.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始写入&quot;</span>);</span><br><span class="line">cacheMap.put(key, value);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:写入OK&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 所有线程可以同时读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">readWriteLock.readLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始读取&quot;</span>);</span><br><span class="line">String value = cacheMap.get(key);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:读取Ok&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">readWriteLock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612763128151.png" alt="1612763128151"></p><p>阻塞队列：</p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612763178531.png" alt="1612763178531"></p><p>队列：</p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612763200134.png" alt="1612763200134"></p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612763104616.png" alt="1612763104616"></p><p>什么情况下我们会使用 阻塞队列：多线程并发处理，线程池！</p><h3 id="BlockingQueue-的四组api"><a href="#BlockingQueue-的四组api" class="headerlink" title="BlockingQueue 的四组api"></a>BlockingQueue 的四组api</h3><table><thead><tr><th></th><th>抛出异常</th><th>不会抛出异常</th><th>阻塞、等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer</td><td>put</td><td>offer(timenum.timeUnit)</td></tr><tr><td>移除</td><td>remove</td><td>poll</td><td>take</td><td>poll(timenum,timeUnit)</td></tr><tr><td>判断队首元素</td><td>element</td><td>peek</td><td>-</td><td>-</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01BlockingQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"><span class="comment">//test2();</span></span><br><span class="line"><span class="comment">//test3();</span></span><br><span class="line">test4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="comment">//抛出异常：java.lang.IllegalStateException: Queue full</span></span><br><span class="line">System.out.println(blockingQueue.add(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出异常： java.util.NoSuchElementException</span></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="comment">// 不会抛出异常,返回false</span></span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line"><span class="comment">// 不会抛出异常,返回null</span></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 如果队列已经满了，再进去一个元素，这种情况会一直等待这个队列，什么时候有了位置再进去</span></span><br><span class="line">blockingQueue.put(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.take());</span><br><span class="line">System.out.println(blockingQueue.take());</span><br><span class="line">System.out.println(blockingQueue.take());</span><br><span class="line"><span class="comment">// 如果我们再来一个，这种情况也会等待，程序会一直运行，阻塞</span></span><br><span class="line">System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">ArrayBlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line"><span class="comment">// 没有空位，返回false</span></span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS));  <span class="comment">//超时时间2s 等待如果超过2s就结束等待</span></span><br><span class="line">System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;=========== 取值 ===========&quot;</span>);</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 null</span></span><br><span class="line">System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS)); <span class="comment">//超过两秒 我们就不要等待了,如果没有</span></span><br><span class="line">System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul><li>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放一个元素！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SynchronousQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: put A&quot;</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: put B&quot;</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: put C&quot;</span>);</span><br><span class="line">blockingQueue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: get &quot;</span> + blockingQueue.take());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: get &quot;</span> + blockingQueue.take());</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: get &quot;</span> + blockingQueue.take());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul><li>三大方法</li><li>七大参数</li><li>四种拒绝策略</li></ul><h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><ul><li>程序的运行，本质：占用系统的资源！ 优化资源的使用！=&gt;池化技术</li><li>线程池、连接池、内存池、对象池///….. 创建、销毁。十分浪费资源</li><li>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</li></ul><blockquote><p>线程池的好处：（线程复用、可以控制最大并发数、管理线程）</p><ol><li>降低资源的消耗</li><li>提高响应的速度</li><li>方便管理。</li></ol></blockquote><h2 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612765381549.png" alt="1612765381549"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ThreadPoolCreate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单个线程的线程池</span></span><br><span class="line"><span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line"><span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line"><span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line"><span class="comment">// 可伸缩的线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; OK&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 线程池用完，关闭线程池</span></span><br><span class="line">threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h2><h3 id="源码解析（本质-ThreadPoolExecutor-）"><a href="#源码解析（本质-ThreadPoolExecutor-）" class="headerlink" title="源码解析（本质 ThreadPoolExecutor ）"></a>源码解析（本质 <code>ThreadPoolExecutor</code> ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment"> *        creates a new thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment"> *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment"> *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>int corePoolSize</td><td>核心线程池大小</td></tr><tr><td>int maximumPoolSize</td><td>最大核心线程池大小</td></tr><tr><td>long keepAliveTime</td><td>超时了没有人调用就会释放</td></tr><tr><td>TimeUnit unit</td><td>超时单位</td></tr><tr><td>BlockingQueue<Runnable> workQueue</Runnable></td><td>阻塞队列</td></tr><tr><td>ThreadFactory threadFactory</td><td>线程工厂：创建线程的，一般不用动</td></tr><tr><td>RejectedExecutionHandler handler</td><td>拒绝策略</td></tr></tbody></table><h2 id="四种拒接策略"><a href="#四种拒接策略" class="headerlink" title="四种拒接策略"></a>四种拒接策略</h2><ol><li><strong>new ThreadPoolExecutor.AbortPolicy()：</strong> //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常<ul><li>超出最大承载，就会抛出异常：队列容量大小 + maxPoolSize</li></ul></li><li><strong>new ThreadPoolExecutor.CallerRunsPolicy()：</strong> //该拒绝策略为：哪来的去哪里 main线程进行处理</li><li><strong>new ThreadPoolExecutor.DiscardPolicy():</strong> //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</li><li><strong>new ThreadPoolExecutor.DiscardOldestPolicy()：</strong> //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常</li></ol><h1 id="四大函数式接口（必需掌握）"><a href="#四大函数式接口（必需掌握）" class="headerlink" title="四大函数式接口（必需掌握）"></a>四大函数式接口（必需掌握）</h1><h2 id="Function-函数型接口"><a href="#Function-函数型接口" class="headerlink" title="Function 函数型接口"></a>Function 函数型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Function</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 函数型接口, 有一个输入参数，有一个输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Function&lt;String, String&gt; function = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">&quot;function&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只要是 函数型接口 可以 用 lambda表达式简化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Function&lt;String, String&gt; function1 = (str) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function1.apply(<span class="string">&quot;function1&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate-断定型接口"><a href="#Predicate-断定型接口" class="headerlink" title="Predicate 断定型接口"></a>Predicate 断定型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Predicate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断定型接口：有一个输入参数，返回值只能是 布尔值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Predicate&lt;String&gt; predicate = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate1 = (str) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> str.isEmpty();</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(predicate1.test(<span class="string">&quot;yangl&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Consummer-消费型接口"><a href="#Consummer-消费型接口" class="headerlink" title="Consummer 消费型接口"></a>Consummer 消费型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Consummer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 消费型接口: 只有输入，没有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer1 = (str)-&gt;&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;;</span><br><span class="line">consumer1.accept(<span class="string">&quot;yangl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Suppier-供给型接口"><a href="#Suppier-供给型接口" class="headerlink" title="Suppier 供给型接口"></a>Suppier 供给型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Supplier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口 没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Supplier supplier = <span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">Supplier supplier1 = ()-&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier1.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><ul><li>大数据：存储 + 计算</li><li>集合、MySQL 本质就是存储东西的；</li><li>计算都应该交给流来操作！</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612770475724.png" alt="1612770475724"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Stream</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="number">21</span>);</span><br><span class="line">User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22</span>);</span><br><span class="line">User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;c&quot;</span>,<span class="number">23</span>);</span><br><span class="line">User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;d&quot;</span>,<span class="number">24</span>);</span><br><span class="line">User u5 = <span class="keyword">new</span> User(<span class="number">5</span>,<span class="string">&quot;e&quot;</span>,<span class="number">25</span>);</span><br><span class="line">User u6 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">&quot;f&quot;</span>,<span class="number">26</span>);</span><br><span class="line">List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5, u6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line">list.stream()</span><br><span class="line">.filter(user -&gt; &#123;<span class="keyword">return</span> user.getId()%<span class="number">2</span> == <span class="number">0</span>;&#125;)</span><br><span class="line">.filter(user -&gt; &#123;<span class="keyword">return</span> user.getAge() &gt; <span class="number">23</span>;&#125;)</span><br><span class="line">.map(user -&gt; &#123;<span class="keyword">return</span> user.getName().toUpperCase();&#125;)</span><br><span class="line">.sorted((user1, user2) -&gt; &#123;<span class="keyword">return</span> user2.compareToIgnoreCase(user1);&#125;)</span><br><span class="line">.limit(<span class="number">1</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><ul><li><p>ForkJoin 在 JDK 1.7 ， 并行执行任务！提高效率。大数据量！</p></li><li><p>大数据：Map Reduce （把大任务拆分为小任务）</p></li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612771269658.png" alt="1612771269658"></p><h2 id="ForkJoin-特点：工作窃取"><a href="#ForkJoin-特点：工作窃取" class="headerlink" title="ForkJoin 特点：工作窃取"></a>ForkJoin 特点：工作窃取</h2><ul><li>这个里面维护的都是双端队列</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612771969042.png" alt="1612771969042"></p><h2 id="ForkJoin-1"><a href="#ForkJoin-1" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612771327085.png" alt="1612771327085"></p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612771340761.png" alt="1612771340761"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.forkjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Forkjoin</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;************ 普通自加 *********&quot;</span>);</span><br><span class="line">test1();</span><br><span class="line">System.out.println(<span class="string">&quot;************ ForkJoin *********&quot;</span>);</span><br><span class="line">test2();</span><br><span class="line">System.out.println(<span class="string">&quot;************ Stream *********&quot;</span>);</span><br><span class="line">test3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通累加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Long sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Long i = <span class="number">0L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">sum +=i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ForkJoin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinHelper(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">Long sum = submit.get();</span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// Stream并行流 () (]</span></span><br><span class="line"><span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">System.out.println(<span class="string">&quot;sum=&quot;</span> + sum + <span class="string">&quot; 时间：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612773347438.png" alt="1612773347438"></p><h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><ul><li>Future 设计的初衷： 对将来的某个事件的结果进行建模</li></ul><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612773374140.png" alt="1612773374140"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用： CompletableFuture</span></span><br><span class="line"><span class="comment"> * // 异步执行</span></span><br><span class="line"><span class="comment"> * // 成功回调</span></span><br><span class="line"><span class="comment"> * // 失败回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01CompletableFuture</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1();</span></span><br><span class="line">System.out.println(test2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有返回值的异步回调:runAsync</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start: runAsync=&gt;Void&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end: runAsync=&gt;Void&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">completableFuture.get(); <span class="comment">// 获取阻塞执行结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值的回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">CompletableFuture&lt;Integer&gt; completableFuture =</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start: supplyAsync=&gt;Integer&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;正常信息返回=&gt;&quot;</span> + t); <span class="comment">// 正常的返回结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;异常信息返回=&gt;&quot;</span> + u); <span class="comment">// 错误信息：</span></span><br><span class="line">&#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;异常信息：&quot;</span> + e.getMessage());</span><br><span class="line"><span class="keyword">return</span> <span class="number">404</span>; <span class="comment">// 可以获取到错误的返回结果</span></span><br><span class="line">&#125;).get();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><ul><li><p>请你谈谈你对 Volatile 的理解</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul></li><li><p>什么是JMM</p><ul><li> Java 内存模型，不存在的东西，概念！约定！</li><li>关于JMM的一些同步的约定<ul><li>线程解锁前，必须把共享变量立刻刷回主存。</li><li>线程加锁前，必须读取主存中的最新值到工作内存中！</li><li>加锁和解锁是同一把锁</li></ul></li></ul></li></ul><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Volatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加 volatile 程序就会死循环！</span></span><br><span class="line"><span class="comment">// 加 volatile 可以保证可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; <span class="comment">// 线程 1 对主内存的变化不知道的</span></span><br><span class="line"><span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num的值为：&quot;</span> + num);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num设值完成&quot;</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><ul><li>原子性：不可分割；</li><li>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Volatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="comment">//++ 不是一个原子性操作，是两个~3个操作</span></span><br><span class="line"><span class="comment">// public static void add();</span></span><br><span class="line"><span class="comment">// Code:</span></span><br><span class="line"><span class="comment">// 0: getstatic     #2                  // Field num:I</span></span><br><span class="line"><span class="comment">// 3: iconst_1</span></span><br><span class="line"><span class="comment">// 4: iadd</span></span><br><span class="line"><span class="comment">// 5: putstatic     #2                  // Field num:I</span></span><br><span class="line"><span class="comment">// 8: return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//main  gc</span></span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,num=&quot;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="如果不加-lock-和-synchronized-怎么样保证原子性"><a href="#如果不加-lock-和-synchronized-怎么样保证原子性" class="headerlink" title="如果不加 lock 和 synchronized,怎么样保证原子性"></a>如果不加 lock 和 synchronized,怎么样保证原子性</h4><ul><li>使用原子类，解决 原子性问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangl.study.jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yanglei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021年02月08日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Volatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  public static void add();</span></span><br><span class="line"><span class="comment">//    Code:</span></span><br><span class="line"><span class="comment">//       0: getstatic     #2                  // Field num:Ljava/util/concurrent/atomic/AtomicInteger;</span></span><br><span class="line"><span class="comment">//       3: invokevirtual #3                  // Method java/util/concurrent/atomic/AtomicInteger.incrementAndGet:()I</span></span><br><span class="line"><span class="comment">//       6: pop</span></span><br><span class="line"><span class="comment">//       7: return</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//main  gc</span></span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,num=&quot;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>什么是 指令重排：你写的程序，计算机并不是按照你写的那样去执行的。</li><li>源代码–&gt;编译器优化的重排–&gt; 指令并行也可能会重排–&gt; 内存系统也会重排—&gt; 执行</li></ul><h3 id="volatile可以避免指令重排"><a href="#volatile可以避免指令重排" class="headerlink" title="volatile可以避免指令重排"></a>volatile可以避免指令重排</h3><blockquote><p>Volatile 是可以保持 可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！</p></blockquote><p>内存屏障。CPU指令。作用：<br>1、保证特定的操作的执行顺序！<br>2、可以保证某些变量的内存可见性 （利用这些特性volatile实现了可见性）</p><p><img src="/2020/12/31/java/juc/java-juc-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-juc%E5%85%A5%E9%97%A8/1612776497944.png" alt="1612776497944"></p><h1 id="彻底玩转单例模式"><a href="#彻底玩转单例模式" class="headerlink" title="彻底玩转单例模式"></a>彻底玩转单例模式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h2 id="DCL-懒汉式"><a href="#DCL-懒汉式" class="headerlink" title="DCL 懒汉式"></a>DCL 懒汉式</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h3 id="单例不安全，反射"><a href="#单例不安全，反射" class="headerlink" title="单例不安全，反射"></a>单例不安全，反射</h3><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h1 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h1><h1 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式id</title>
      <link href="2020/12/21/java/distributed/java-distributed-id/"/>
      <url>2020/12/21/java/distributed/java-distributed-id/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式ID生成器"><a href="#分布式ID生成器" class="headerlink" title="分布式ID生成器"></a>分布式ID生成器</h1><h2 id="一、需求缘起"><a href="#一、需求缘起" class="headerlink" title="一、需求缘起"></a><strong>一、需求缘起</strong></h2><p>几乎所有的业务系统，都有生成一个唯一记录标识的需求，例如：</p><ul><li>消息标识：message-id</li><li>订单标识：order-id</li><li>帖子标识：tiezi-id</li></ul><p>这个记录标识往往就是数据库中的<strong>主键</strong>，数据库上会建立<strong>聚集索引</strong>（cluster index），即在物理存储上以这个字段排序。</p><p>这个记录标识上的查询，往往又有分页或者排序的业务需求，例如：</p><ul><li><p>拉取最新的一页消息</p><p>select message-id/ order by time/ limit 100</p></li><li><p>拉取最新的一页订单</p><p>select order-id/ order by time/ limit 100</p></li><li><p>拉取最新的一页帖子</p><p>select tiezi-id/ order by time/ limit 100</p></li></ul><p>所以往往要有一个time字段，并且在time字段上建立<strong>普通索引</strong>（non-cluster index）。</p><p>普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：</p><p>select message-id/ (order by message-id)/limit 100</p><p>强调，能这么做的前提是，message-id的生成基本是<strong>趋势时间递增的</strong>。</p><p>这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：</p><ul><li>全局唯一</li><li>趋势有序</li></ul><p>这也是本文要讨论的核心问题：<strong>如何高效生成趋势有序的全局唯一ID。</strong></p><h2 id="二、常见方法、不足与优化"><a href="#二、常见方法、不足与优化" class="headerlink" title="二、常见方法、不足与优化"></a><strong>二、常见方法、不足与优化</strong></h2><h3 id="方法一：使用数据库的-auto-increment-来生成全局唯一递增ID"><a href="#方法一：使用数据库的-auto-increment-来生成全局唯一递增ID" class="headerlink" title="方法一：使用数据库的 auto_increment 来生成全局唯一递增ID"></a><strong>方法一：使用数据库的 auto_increment 来生成全局唯一递增ID</strong></h3><p><strong>优点：</strong></p><ul><li>简单，使用数据库已有的功能</li><li>能够保证唯一性</li><li>能够保证递增性</li><li>步长固定</li></ul><p><strong>缺点：</strong></p><ul><li>可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了</li><li>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展</li></ul><p><strong>改进方法：</strong></p><ul><li>冗余主库，避免写入单点</li><li>数据水平切分，保证各主库生成的ID不重复</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f37346638636339373866393034366533386536313364346430643330363938642e6a7067" alt="img"></p><p>如上图所述，由1个写库变成3个写库，<strong>每个写库设置不同的auto_increment初始值，以及相同的增长步长</strong>，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）</p><p>改进后的架构保证了可用性，但<strong>缺点</strong>是：</p><ul><li>丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增）</li><li>数据库的写压力依然很大，每次生成ID都要访问数据库</li></ul><p>为了解决上述两个问题，引出了第二个常见的方案。</p><h3 id="方法二：单点批量ID生成服务"><a href="#方法二：单点批量ID生成服务" class="headerlink" title="方法二：单点批量ID生成服务"></a><strong>方法二：单点批量ID生成服务</strong></h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</p><p>数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。</p><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f39336165303932633465386334643361613932613539616661383161626235332e6a7067" alt="img"></p><p>如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。</p><p>ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了。</p><p>当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。</p><p><strong>优点</strong>：</p><ul><li>保证了ID生成的绝对递增有序</li><li>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</li></ul><p><strong>缺点</strong>：</p><ul><li>服务仍然是单点</li><li>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）</li><li>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</li></ul><p><strong>改进方法</strong>：</p><p>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：</p><p><img src="/2020/12/21/java/distributed/java-distributed-id/687474703a2f2f696d672e6d702e6974632e636e2f75706c6f61642f32303137303632352f34343963323232663763333434323039616634346466383330343739646464652e6a7067" alt="img"></p><p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。</p><p>这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived，具体就不在这里展开。</p><p>另外，ID-gen-service也可以实施水平扩展，以解决上述缺点（3），但会引发一致性问题，具体解决方案详见。</p><h3 id="方法三：uuid-guid"><a href="#方法三：uuid-guid" class="headerlink" title="方法三：uuid/guid"></a><strong>方法三：uuid/guid</strong></h3><p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。</p><p>有没有一种本地生成ID的方法，即高性能，又时延低呢？</p><p>uuid是一种常见的方案：</p><p>string ID =GenUUID();</p><p><strong>优点</strong>：</p><ul><li>本地生成ID，不需要进行远程调用，时延低</li><li>扩展性好，基本可以认为没有性能上限</li></ul><p><strong>缺点</strong>：</p><ul><li>无法保证趋势递增</li><li>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</li></ul><h3 id="方法四：取当前毫秒数"><a href="#方法四：取当前毫秒数" class="headerlink" title="方法四：取当前毫秒数"></a><strong>方法四：取当前毫秒数</strong></h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？</p><p>取当前毫秒数是一种常见方案：</p><p>uint64 ID = GenTimeMS();</p><p><strong>优点</strong>：</p><ul><li>本地生成ID，不需要进行远程调用，时延低</li><li>生成的ID趋势递增</li><li>生成的ID是整数，建立索引后查询效率高</li></ul><p><strong>缺点</strong>：</p><ul><li>如果并发量超过1000，会生成重复的ID</li></ul><p>这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</p><h3 id="方法五：类snowflake算法"><a href="#方法五：类snowflake算法" class="headerlink" title="方法五：类snowflake算法"></a><strong>方法五：类snowflake算法</strong></h3><p>snowflake是twitter开源的分布式ID生成算法，其<strong>核心思想为，</strong>一个long型的ID：</p><ul><li>41bit作为毫秒数</li><li>10bit作为机器编号</li><li>12bit作为毫秒内序列号</li></ul><p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p><p>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现<strong>自己的分布式ID生成算法</strong>。</p><p>举例，假设某公司ID生成器服务的需求如下：</p><ul><li>单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W</li><li>有2个机房，预计未来5年机房数量小于4个</li><li>每个机房机器数小于100台</li><li>目前有5个业务线有ID生成需求，预计未来业务线数量小于10个</li><li>…</li></ul><p>分析过程如下：</p><ul><li>高位取从2017年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数</li><li>每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号</li><li>5年内机房数小于4个，预留2bit给机房标识</li><li>每个机房小于100台机器，预留7bit给每个机房内的服务器标识</li><li>业务线小于10个，预留4bit给业务线标识</li></ul><p>这样设计的64bit标识，可以保证：</p><ul><li>每个业务线、每个机房、每个机器生成的ID都是不同的</li><li>同一个机器，每个毫秒内生成的ID都是不同的</li><li>同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的</li><li>将毫秒数放在最高位，保证生成的ID是趋势递增的</li></ul><p><strong>缺点</strong>：</p><ul><li>由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2020/12/21/java/distributed/java-distributed-transaction/"/>
      <url>2020/12/21/java/distributed/java-distributed-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>在分布式系统中实现事务，他其实是<strong>由多个本地事</strong>务组合而成。</li></ul><h2 id="分布式事务的主要实现有以下方案"><a href="#分布式事务的主要实现有以下方案" class="headerlink" title="分布式事务的主要实现有以下方案"></a>分布式事务的主要实现有以下方案</h2><ul><li>XA方案</li><li>TCC方案</li><li>SAGA方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案/XA方案"></a>两阶段提交方案/XA方案</h3><ul><li>XA方案：两阶段提交，有一个事务管理器的概念，负责协调多个数据的事务，事务管理器先访问各个数据库你准备好了吗？如果每个数数据库都回复OK，那么久正式提交事务，在各个数据库上执行操作；如果其中任何一个数据库回答NO，那么久回滚事务。</li></ul><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><ul><li><p>（Two-phase commit proticol）,中文叫二阶段提交</p></li><li><p>二阶段提交是一种强一致性设计。引入一个<strong>管理者协调各参与者</strong>（各本地资源）的提交回滚。二阶段指的是<strong>准备和提交</strong>两个阶段</p></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608561598519.png" alt="1608561598519"></p><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ul><li>2PC他在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态</li><li>3PC包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英文就是：CanConmit、PerCommit和DoCommit.</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608563608233.png" alt="1608563608233"></p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><ul><li>2PC和3PC都是数据库层面的，而TCC是业务层面的分布式事务</li><li>TCC 指的是 Try-Confirm-Cancel。<ul><li>Try 指的是预留，即资源的预留和锁定，注意是预留。</li><li>Confirm 指的是确认操作，这一步其实就是真正执行了。</li><li>Cancel 指的是撤销操作， 可以理解为把预留阶段的动作撤销了。</li></ul></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608564547571.png" alt="1608564547571"></p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><ul><li>本地消息表其实就是利用了 各系统本地的事务来实现分布式事务</li><li>有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候，将业务的执行和将消息的放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中的业务肯定是执行成功的。</li><li>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息可以直接改成已成功。如果调用失败也没事，会有后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</li></ul><h3 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h3><ul><li>RocketMQ就很好的支持了消息事务</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-transaction/1608565223942.png" alt="1608565223942"></p><h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><ul><li>最大努力通知其实只是表明了一种柔性事务的思想：我已经尽我的最大努力想达成事务的最终一致了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="2020/12/21/java/distributed/java-distributed-locks/"/>
      <url>2020/12/21/java/distributed/java-distributed-locks/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a><strong>基于数据库</strong></h2><blockquote><ul><li>基于数据库表记录做唯一约束（表中记录方法名称）</li><li>基于数据库表做悲观锁（InnoDB，for update）</li><li>基于数据库表做乐观锁，用于分布式锁。（version）</li></ul></blockquote><h3 id="基于数据库表数据记录做唯一约束（表中记录方法名称）"><a href="#基于数据库表数据记录做唯一约束（表中记录方法名称）" class="headerlink" title="基于数据库表数据记录做唯一约束（表中记录方法名称）"></a>基于数据库表数据记录做唯一约束（表中记录方法名称）</h3><ul><li>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</li><li>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。 创建这样一张数据库表：</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f4b2a97bdf2" alt="img"></p><ul><li>当我们想要锁住某个方法时，执行以下SQL：</li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f62c5d2d91a" alt="img"></p><ul><li><p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功（原子性），那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p></li><li><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql: </p></li></ul><p><img src="/2020/12/21/java/distributed/java-distributed-locks/16757f4df2225419" alt="img"></p><p><strong>上面这种简单的实现有以下几个问题：</strong></p><blockquote><ol><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ol><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加两个字段，一个记录当前获得锁的机器的主机信息和线程信息，另一个是count值，用于记录重入的次数，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了，并把count加1。在释放锁的时候把count值减1，当count值为0时候，删除记录即可。</li></ul></blockquote><h3 id="基于数据库表做悲观锁（InnoDB引擎，for-update语句）"><a href="#基于数据库表做悲观锁（InnoDB引擎，for-update语句）" class="headerlink" title="基于数据库表做悲观锁（InnoDB引擎，for update语句）"></a>基于数据库表做悲观锁（InnoDB引擎，for update语句）</h3><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。 我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（<strong>这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上</strong>）。</p><p>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。 我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            select * from lock where lock_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(结果不为空)&#123;</span><br><span class="line">                <span class="comment">//代表获取到锁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">        <span class="comment">//为空或者抛异常的话都表示没有获取到锁</span></span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LockException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 connection.commit() 操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p>这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</p><h3 id="基于数据库资源表做乐观锁，用于分布式锁"><a href="#基于数据库资源表做乐观锁，用于分布式锁" class="headerlink" title="基于数据库资源表做乐观锁，用于分布式锁:"></a>基于数据库资源表做乐观锁，用于分布式锁:</h3><ol><li><p>首先说明乐观锁的含义:</p><blockquote><p> 大多数是基于数据版本(VERSION)的记录机制实现的。何谓数据版本号？即为数据增加一个版本标识，<br> 在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个“VERSION”字段来实现读取出数据时<br> ，将此版本号一同读出，之后更新时，对此版本号加1。</p><p> 在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；<br> 如果版本号不一致，则会更新失败。<br>复制代码</p></blockquote></li></ol><ol start="2"><li>对乐观锁的含义有了一定的了解后，结合具体的例子，我们来推演下我们应该怎么处理：</li></ol><ul><li><p>假设我们有一张资源表，如下图所示: T_RESOURCE , 其中有6个字段ID, RESOOURCE, STATE, ADD_TIME, UPDATE_TIME, VERSION,分别表示表主键、资源、分配状态(1未分配 2已分配)、资源创建时间、资源更新时间、资源数据版本号。</p></li><li><p>假设我们现在我们对ID=5780这条数据进行分配，那么非分布式场景的情况下，我们一般先查询出来STATE=1(未分配)的数据，然后从其中选取一条数据可以通过以下语句进行，如果可以更新成功，那么就说明已经占用了这个资源 UPDATE T_RESOURCE SET STATE=2 WHERE STATE=1 AND ID=5780。</p></li><li><p>如果在分布式场景中，由于数据库的UPDATE操作是原子是原子的，其实上边这条语句理论上也没有问题，但是这条语句如果在典型的“ABA”情况下，我们是无法感知的。有人可能会问什么是“ABA”问题呢？大家可以网上搜索一下，这里我说简单一点就是，如果在你第一次SELECT和第二次UPDATE过程中，由于两次操作是非原子的，所以这过程中，如果有一个线程，先是占用了资源(STATE=2)，然后又释放了资源(STATE=1)，实际上最后你执行UPDATE操作的时候，是无法知道这个资源发生过变化的。也许你会说这个在你说的场景中应该也还好吧，但是在实际的使用过程中，比如银行账户存款或者扣款的过程中，这种情况是比较恐怖的。</p></li><li><p>那么如果使用乐观锁我们如何解决上边的问题呢？</p><blockquote><p> A. 先执行SELECT操作查询当前数据的数据版本号,比如当前数据版本号是26：<br>  SELECT ID, RESOURCE, STATE,VERSION FROM T_RESOURCE WHERE STATE=1 AND ID=5780;<br>  B. 执行更新操作：<br>  UPDATE T_RESOURE SET STATE=2, VERSION=27, UPDATE_TIME=NOW() WHERE RESOURCE=XXXXXX AND<br>  STATE=1 AND VERSION=26<br>  C. 如果上述UPDATE语句真正更新影响到了一行数据，那就说明占位成功。如果没有更新影响到一行数据<br>  ，则说明这个资源已经被别人占位了。</p></blockquote></li></ul><ol start="3"><li><p>基于数据库表做乐观锁的一些缺点:</p><ol><li> 这种操作方式，使原本一次的UPDATE操作，必须变为2次操作: SELECT版本号一次；UPDATE一次。增加了数据库操作的次数。</li><li> 如果业务场景中的一次业务流程中，多个资源都需要用保证数据一致性，那么如果全部使用基于数据库资源表的乐观锁，就要让每个资源都有一张资源表，这个在实际使用场景中肯定是无法满足的。而且这些都基于数据库操作，在高并发的要求下，对数据库连接的开销一定是无法忍受的。</li><li> 乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整，如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开。</li></ol></li></ol><p>讲了乐观锁的实现方式和缺点，是不是会觉得不敢使用乐观锁了呢？？？当然不是，在文章开头我自己的业务场景中，场景1和场景2的一部分都使用了基于数据库资源表的乐观锁，已经很好的解决了线上问题。所以大家要根据的具体业务场景选择技术方案，并不是随便找一个足够复杂、足够新潮的技术方案来解决业务问题就是好方案？！比如，如果在我的场景一中，我使用zookeeper做锁，可以这么做，但是真的有必要吗？？？答案觉得是没有必要的！！！</p><p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p><blockquote><p>数据库实现分布式锁的优点<br>    直接借助数据库，容易理解。<br>数据库实现分布式锁的缺点<br>    会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。<br>    操作数据库需要一定的开销，性能问题需要考虑。<br>    使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p></blockquote><h2 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a><strong>基于缓存</strong></h2><blockquote><ul><li>使用redis的setnx()用于分布式锁。（setNx，直接设置值为当前时间+超时时间，保持操作原子性）</li><li><del>使用memcached的add()方法，用于分布式锁。</del></li><li><del>使用Tair的put()方法，用于分布式锁。</del></li></ul></blockquote><h3 id="基于缓存实现分布式锁-Redis"><a href="#基于缓存实现分布式锁-Redis" class="headerlink" title="基于缓存实现分布式锁 Redis"></a>基于缓存实现分布式锁 Redis</h3><ul><li><p>使用redis的setnx()用于分布式锁。（原子性）</p></li><li><p>SETNX是将 key 的值设为 value，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。</p><blockquote><ul><li>返回1，说明该进程获得锁，SETNX将键 lock.id 的值设置为锁的超时时间，当前时间 +加上锁的有效时间。</li><li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</li></ul></blockquote></li></ul><p> <strong>存在死锁的问题</strong></p><p>​        SETNX实现分布式锁，可能会存在死锁的情况。与单机模式下的锁相比，分布式环境下不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。某个线程获取了锁之后，断开了与Redis 的连接，锁没有及时释放，竞争该锁的其他线程都会hung，产生死锁的情况。所以在这种情况下需要对获取的锁进行超时时间设置，即setExpire，超时自动释放锁</p><p><strong>Redission的分布式锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redission是redis官网推荐的一个redis客户端，除了基于redis的基础的CURD命令以外，重要的是就是Redission提供了方便好用的分布式锁API</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>一、 <strong>基本用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient redissonClient = RedissonTool.getInstance();</span><br><span class="line"></span><br><span class="line">      RLock distribute_lock = redissonClient.getLock(<span class="string">&quot;distribute_lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> result = distribute_lock.tryLock(<span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (distribute_lock.isLocked()) &#123;</span><br><span class="line">              distribute_lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>代码流程</strong></p><ol><li>通过 redissonClient 获取 RLock 实例</li><li>tryLock 获取尝试获取锁，第一个是等待时间，第二个是锁的超时时间，第三个是时间单位</li><li>执行完业务逻辑后，最终释放锁</li></ol><p>二、 <strong>具体实现</strong></p><blockquote><p>我们通过tryLock来分析redission分布式的实现，lock方法跟tryLock差不多，只不过没有最长等待时间的设置，会自旋循环等待锁的释放，直到获取锁为止</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">     <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">//获取当前线程ID，用于实现可重入锁</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">     <span class="comment">//尝试获取锁</span></span><br><span class="line">     Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">     <span class="comment">// lock acquired</span></span><br><span class="line">     <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     time -= (System.currentTimeMillis() - current);</span><br><span class="line">     <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">//等待时间结束，返回获取失败</span></span><br><span class="line">         acquireFailed(threadId);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     current = System.currentTimeMillis();</span><br><span class="line">     <span class="comment">//订阅锁的队列，等待锁被其余线程释放后通知</span></span><br><span class="line">     <span class="keyword">final</span> RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">     <span class="keyword">if</span> (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">             subscribeFuture.addListener(<span class="keyword">new</span> FutureListener&lt;RedissonLockEntry&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;RedissonLockEntry&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span> (subscribeFuture.isSuccess()) &#123;</span><br><span class="line">                         unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         acquireFailed(threadId);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         time -= (System.currentTimeMillis() - current);</span><br><span class="line">         <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">             acquireFailed(threadId);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">             ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">             <span class="comment">// lock acquired</span></span><br><span class="line">             <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             time -= (System.currentTimeMillis() - currentTime);</span><br><span class="line">             <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 acquireFailed(threadId);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// waiting for message，等待订阅的队列消息</span></span><br><span class="line">             currentTime = System.currentTimeMillis();</span><br><span class="line">             <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                 getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             time -= (System.currentTimeMillis() - currentTime);</span><br><span class="line">             <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 acquireFailed(threadId);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         unsubscribe(subscribeFuture, threadId);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><ol><li>首先 tryAcquire 尝试获取锁，若返回ttl为null，说明获取到锁了</li><li>判断等待时间是否过期，如果过期，直接返回获取锁失败</li><li>通过 Redis 的 Channel 订阅监听队列，subscribe 内部通过信号量 semaphore，再通过await方法阻塞，内部其实是用 CountDownLatch 来实现阻塞，获取 subscribe 异步执行的结果，来保证订阅成功，再判断是否到了等待时间</li><li>再次尝试申请锁和等待时间的判断，循环阻塞在这里等待锁释放的消息 RedissonLockEntry 也维护了一个semaphore 的信号量</li><li>无论是否释放锁，最终都要取消订阅这个队列消息</li><li>redission 内部的 getEntryName 是客户端实例ID + 锁名称 来保证多个实例下的锁可重入</li></ol><hr><p><strong>tryAcquire获取锁</strong></p><blockquote><p>redisssion获取锁的核心代码,内部其实是异步调用，但是用get方法阻塞了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Long <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(tryAcquireAsync(leaseTime, unit, threadId));</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br><span class="line"> <span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        &#125;</span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(LOCK_EXPIRATION_INTERVAL_SECONDS, TimeUnit.SECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Long ttlRemaining = future.getNow();</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>tryLockInnerAsync方法内部是基于Lua脚本来获取锁的</p><ul><li>先判断KEYS[1]（锁名称）对应的key是否存在，不存在获取到锁，hset设置key的value，pexpire设置过期时间，返回null表示获取到锁</li><li>存在的话，锁被占，hexists判断是否是当前线程的锁，若是的话，hincrby增加重入次数，重新设置过期时间，不是当前线程的锁，返回当前锁的过期时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">       internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                 <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                   Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>Redission避免死锁的解决方案：</p><p>Redission为了避免锁未被释放，采用了一个特殊的解决方案，若未设置过期时间的话，redission默认的过期时间是30s，同时未避免锁在业务未处理完成之前被提前释放，Redisson在获取到锁且默认过期时间的时候，会在当前客户端内部启动一个定时任务，每隔internalLockLeaseTime/3的时间去刷新key的过期时间，这样既避免了锁提前释放，同时如果客户端宕机的话，这个锁最多存活30s的时间就会自动释放（刷新过期时间的定时任务进程也宕机）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock acquired，获取到锁的时候设置定期更新时间的任务</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining) &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//expirationRenewalMap的并发安全MAP记录设置过的缓存，避免并发情况下重复设置任务，internalLockLeaseTime / 3的时间后重新设置过期时间</span></span><br><span class="line">               <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                      Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">            </span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, future.cause());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        scheduleExpirationRenewal(threadId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), task) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>unlock解锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123;</span><br><span class="line">        return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) &#x3D;&#x3D; 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot; +</span><br><span class="line">                &quot;end;&quot; +</span><br><span class="line">                &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) &#x3D;&#x3D; 0) then &quot; +</span><br><span class="line">                    &quot;return nil;&quot; +</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;local counter &#x3D; redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot; +</span><br><span class="line">                &quot;if (counter &gt; 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot; +</span><br><span class="line">                    &quot;return 0; &quot; +</span><br><span class="line">                &quot;else &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot; +</span><br><span class="line">                    &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot;+</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;return nil;&quot;,</span><br><span class="line">                Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   Redission的unlock解锁也是基于Lua脚本实现的，内部逻辑是先判断锁是否存在，不存在说明已经被释放了，发布锁释放消息后返回，锁存在再判断当前线程是否锁拥有者，不是的话，无权释放返回，解锁的话，会减去重入的次数，重新更新过期时间，若重入数捡完，删除当前key，发布锁释放消息</p><h2 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h2><blockquote><ul><li>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。</li></ul></blockquote><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><p>基于 zookeeper 临时有序节点可以实现的分布式锁。</p><p>大致思想即为：</p><blockquote><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有<br>序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。<br>当释放锁的时候，只需将这个临时节点删除即可。同时，排队的节点需要监听排在自己之前的节点，这样能<br>在节点释放时候接收到回调通知，让其获得锁。zk的session由客户端管理，其可以避免服务宕机导致的锁无<br>法释放，而产生的死锁问题，不需要关注锁超时。<br>复制代码</p></blockquote><p>来看下Zookeeper能不能解决前面提到的问题。</p><blockquote><ul><li>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul></blockquote><p>可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。</p><ul><li><p>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</p></li><li><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，<strong>那就是性能上可能并没有缓存服务那么高</strong>。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</p></li><li><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端到ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p></li></ul><p><strong>基于ZK的方案的总结</strong></p><p>使用Zookeeper实现分布式锁的优点</p><blockquote><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p></blockquote><p>使用Zookeeper实现分布式锁的缺点</p><blockquote><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></blockquote><h2 id="三种方案的比较"><a href="#三种方案的比较" class="headerlink" title="三种方案的比较"></a>三种方案的比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><ul><li><p>从理解的难易程度角度（从低到高）</p><blockquote><p>数据库 &gt; 缓存 &gt; Zookeeper</p></blockquote></li><li><p>从实现的复杂性角度（从低到高）</p><blockquote><p>Zookeeper &gt;= 缓存 &gt; 数据库</p></blockquote></li><li><p>从性能角度（从高到低）</p><blockquote><p>缓存 &gt; Zookeeper &gt;= 数据库</p></blockquote></li><li><p>从可靠性角度（从高到低）</p><blockquote><p>Zookeeper &gt; 缓存 &gt; 数据库</p></blockquote></li></ul><p>参考：<a href="https://juejin.cn/post/6844903726268809224">https://juejin.cn/post/6844903726268809224</a></p><p>参考：<a href="https://juejin.cn/post/6844903662762852359#heading-4">https://juejin.cn/post/6844903662762852359#heading-4</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distributed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC参数和调优</title>
      <link href="2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/"/>
      <url>2020/12/19/java/jvm/java-jvm-GC%E5%8F%82%E6%95%B0%E5%92%8C%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="GC参数和调优"><a href="#GC参数和调优" class="headerlink" title="GC参数和调优"></a>GC参数和调优</h2><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾分代收集</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾分代收集"><a href="#垃圾分代收集" class="headerlink" title="垃圾分代收集"></a>垃圾分代收集</h1><ul><li><p>Full GC ： 针对的是整个堆。包括：新生代、老年代、永久代。</p></li><li><p>针对HotSpot VM 的实现，他里面的GC其实准确分类只有两大类：</p><ul><li><p>部分收集器（Partial GC）：</p><ul><li>新生代收集器（Minor GC/ Yong GC）：只对新生代进行垃圾收集</li><li>老年代收集器（Major GC/Old GC）：只对老年代进行垃圾收集。</li><li>混合收集器（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li><p>整堆收集（Full GC）：收集整个Java堆和方法区。</p></li></ul></li></ul><h1 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h1><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/1610272750274.png" alt="1610272750274"></p><h1 id="对象默认存活年龄"><a href="#对象默认存活年龄" class="headerlink" title="对象默认存活年龄"></a>对象默认存活年龄</h1><ul><li>晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6，The default value is 15 for the parallel(throughput) collector</li></ul><h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h1><ul><li><p>对象优先在eden区分配</p></li><li><p>大对象直接进入老年代</p><ul><li>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。为了避免为大对象分配内存空间时由于分配担保机制带来的复制而降低效率</li></ul></li><li><p>长期存活的对象将进入老年代</p><ul><li>-XX:MaxTenuringThreshold</li></ul></li><li><p>动态对象年龄判定</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(HotSpot)的垃圾回收器</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm垃圾的回收作用范围"><a href="#jvm垃圾的回收作用范围" class="headerlink" title="jvm垃圾的回收作用范围"></a>jvm垃圾的回收作用范围</h1><p>下面描述的收集器是基于 JDK1.7 Update 14 之后的 HotSpot 虚拟机，这个虚拟机包含的所有收集器如下图：如果两个收集器之间存在连线，就说明他们可以搭配使用。</p><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/1610272098369.png" alt="1610272098369"></p><h1 id="jvm的7种垃圾回收器"><a href="#jvm的7种垃圾回收器" class="headerlink" title="jvm的7种垃圾回收器"></a>jvm的7种垃圾回收器</h1><h2 id="1-Serial收集器-单线程"><a href="#1-Serial收集器-单线程" class="headerlink" title="1.Serial收集器(单线程)"></a>1.Serial收集器(单线程)</h2><p>Serial收集器时最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。<br>Serial收集器依然是虚拟机运行在Cleent模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="2-ParNew收集器（Serial-多线程）"><a href="#2-ParNew收集器（Serial-多线程）" class="headerlink" title="2.ParNew收集器（Serial+多线程）"></a>2.ParNew收集器（Serial+多线程）</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The Worl、对象可分配规则、回收策略等都与Serial收集器完全一样。<br>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是除了Serial收集器之外，目前只有arNew它能与CMS收集器配合工作。</p><h2 id="3-Parallel-Scavenge-并行回收-收集器"><a href="#3-Parallel-Scavenge-并行回收-收集器" class="headerlink" title="3.Parallel Scavenge(并行回收)收集器"></a>3.Parallel Scavenge(并行回收)收集器</h2><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br>停顿时间越短就越适合需要与用户交互的程序良好的响应速度能提升用户体验，二高吞吐量则可用高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算二不需要太多的交互的任务。</p><p>Parallel Scavenga收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePPolicy/这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor去的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGvPauseMillis参数或者SGCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是paralel Scavenge收集器与ParNew收集器的一个重要区别</p><h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4.Serial Old收集器"></a>4.Serial Old收集器</h2><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记清除算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。</p><p>如果在 Server 模式下，主要两大用途：</p><ol><li>在 JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器使用</li><li>作为 CMS 收集器的后备预案，在并行收集发生 Concurrent Mode Failure 时使用</li></ol><h2 id="5-Paralled-Old收集器"><a href="#5-Paralled-Old收集器" class="headerlink" title="5.Paralled Old收集器"></a>5.Paralled Old收集器</h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-清理”算法。这个收集器在 1.6 中才开始提供。</p><h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h2><p>CMS（ Concurrent Mark Sweep ） 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务器的相应速度，希望系统停顿时间最短，已给用户带来较好的体验。 CMS 收集器就非常符合这类应用需求</p><p>CMS 收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更加复杂一些，整个过程为4个步骤:</p><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ol><p>其中，初始标记、重新标记这两个步骤仍然需要 “Stop the World”。</p><p>CMS 收集器的主要优点：并发收集，低停顿。</p><p>CMS 三个明显的缺点：</p><ol><li>CMS 收集器对 CPU 资源非常敏感。 CPU 个数少于4个时， CMS 对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的 CMS 收集器变种。所做的事情和单 CPU 年代 PC 机操作系统使用抢占式来模拟多线程任务机制的思想。</li><li>CMS 收集器无法处理浮动垃圾，可能出现“ Concurrent Mode Failure ”失败而导致另一次 Full Gc 的产生。在 JDK1.5 的默认设置下， CMS 收集器当老年代使用了 68% 的空间后就会被激活， 这是一个偏保守的设置， 如果在应用中老年代增长不是太快，可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK1.6 中， CMS 收集器的启动阈值已经提升到 92%。</li><li> CMS 是基于“标记-清除”算法实现的收集器，手机结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前发出 Full Gc。为了解决这个问题， CMS 收集器提供一个 -XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片整合并清理过程， 内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间变长了。虚拟机设计者还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction ，这个参数是用于设置执行多次不压缩 Full GC后，跟着来一次带压缩的FullGC（默认值为0，标识每次进入 FullGC时都进行碎片整理）</li></ol><h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h2><p>G1收集器的优势：</p><ol><li>并行与并发</li><li>分代收集</li><li>空间整理（标记整理算法，复制算法）</li><li>可预测的停顿（G1处追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M毫秒的时间片段内，消耗在垃圾收集器上的时间不超过 N 毫秒，这几乎已经实现 Java（ RTSJ ）的垃圾收集器的特征）</li></ol><p>使用 G1 收集器时， Java 堆的内存布局是整个规划为多个大小相等的独立区域（ Region ），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一小部分 Region 的集合。</p><p>G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个 Java 堆中进行全区域的垃圾收集。 G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值最大的 Region （这也就是 Garbage-First 名称的由来）。这种使用 Region 划分的内存空间以及优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽量可能高的效率。</p><p>G1 内存“化整为零”的思路</p><p>在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会遗漏。</p><p>如果不计算维护 Remembered Set 的操作， G1 收集器的运作大致可分为以下步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li>该算法分为 “标记” 和 “清除” 阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：<ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul></li></ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ul><li>为了解决效率问题，“复制” 收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</li></ul><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><ul><li>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li><li>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类和常量池引</title>
      <link href="2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h1><ul><li>字面量会到 java 堆中的常量池去找</li><li>new 的方式会在堆中创建</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-String%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/1610271202594.png" alt="1610271202594"></p><h1 id="String常量池的实现方式"><a href="#String常量池的实现方式" class="headerlink" title="String常量池的实现方式"></a>String常量池的实现方式</h1><ul><li>字面量：双引号括起来的</li><li>String.intern()：他的作用是：如果运行时常量池中已经包含一个等于此 Spring 对象内容的字符串，则返回常量池中该字符串的引用</li></ul><h1 id="String-s1-new-String-“abc”-；这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-；这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”)；这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”)；这句话创建了几个字符串对象？</h1><ul><li>将创建 1 或 2 个字符串，如果常量池中已存在字符串常量 “abc”，则只会在堆空间创建一个字符串常量 “abc” 。如果池中没有字符串常量 “abc” ，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共两个字符串对象。</li></ul><h1 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h1><ul><li><p>Java 基本类型的包装类的大部分都实现了常量池技术</p><ul><li> Byte、Short、Integer、Long：四种包装类默认创建了数字 [-128,127] 的相应类型的缓存数据</li><li>Character：创建了数值在[0,127]范围的缓存数据</li><li>Boolean；直接返回 True 或 False。</li></ul><blockquote><ul><li><p>如果超出对应范围仍然会去创建新的对象。</p></li><li><p>为啥把缓存设置为[-128,127]区间？ (参见issue、461)性能和资源之间的权衡。</p></li></ul></blockquote></li><li><p>算术运算符或比较运算符，对包装类型会有一个拆箱操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><ul><li>加载</li><li>连接<ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/1610292210392.png" alt="1610292210392"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>通过类的全限定名，找到 Class 文件，将 Class 文件中的静态存储结构转换成方法区运行时数据结构，在内存中生活才能一个代表该类的 Class 对象，作为方法区这些数据的入口</li><li>数组类型不通过类加载器创建，由 JVM 直接创建</li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证字节码文件的安全性和完整性：包括：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>为类的静态变量分配内存和设置初始化值</li><li>实例变量会在对象实例化时随着对象一块分配在Java堆中。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code> 方法的过程。</li><li>类初始化的情况<ul><li>new、设置或获取类的静态资源</li><li>反射调用</li><li>子类初始化，先初始化父类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制</li><li>Java8中，接口定义了默认方法时，接口实现类发生了初始化，先初始化接口</li></ul></li></ul><h1 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h1><ul><li>卸载类是该类的Class对象被GC</li><li>满足的条件<ul><li>该类的所有实例对象都已被GC，堆中不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC：自定义加载器加载的类是可以被卸载掉的</li></ul></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自 java.lang.ClassLoader：<ul><li>BootstrapClassLoader( 启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib 目录下的 jar 包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</li><li>ExtensionClassLoader (扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</li><li>AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用 classpath 下的所有jar包和类。</li></ul></li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><ul><li><strong>每一个类都有一个对应它的类加载器</strong> 。类加载的时候，会先判断这个类有没有被加载过。已经加载过的类直接返回，否则尝试加载。</li><li>加载的时候，会先委派该父类加载器的 loadClass 处理，因此所有请求都会到达顶层启动类加载器。当父类加载器无法处理时，才由自己来处理。</li><li>父类加载器为 null 时，由启动类加载器来处理。</li></ul><h2 id="双亲委派的好处"><a href="#双亲委派的好处" class="headerlink" title="双亲委派的好处"></a>双亲委派的好处</h2><ul><li>保证了 Java 程序的稳定运行，可以避免类的重复加载，也<strong>保证了 Java 的核心 API 不被篡改</strong>。</li><li>假设每个类加载器加载自己的话，就会出现我自定义一个 java.lang.Object 类的话，运行程序的时候，就有多个 Object 类了。</li></ul><h2 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h2><p>自定义加载器的话，需要继承 ClassLoader 。</p><ul><li>如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</li><li>如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的访问定位</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>java 程序通过栈上的 reference 数据来操作堆上的具体对象</p><p>对象的访问方式2种：<strong>使用句柄，直接指针</strong></p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><ul><li>如果使用句柄的话，那么java 堆中将会划分出一块内存来作为句柄池， reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据 与 类型数据各自的具体地址信息；</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270729163.png" alt="1610270729163"></p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><ul><li>如果使用直接指针访问，那么 java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 refrence 中存储的直接就是对象的地址</li></ul><p><img src="/2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1610270744133.png" alt="1610270744133"></p><blockquote><ul><li><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></li><li><p>使用直接指针访问方式最大的好处就是速度快，他节约了一次指针定位的时间开销。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的内存布局</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><blockquote><p>对象的内存布局分为3块区域：<strong>对象头、实例数据</strong>和<strong>对齐填充</strong></p></blockquote><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><ul><li>包含两部分信息：第一部分专用于存储对象自身的运行时数据（hash码、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><ul><li>实例数据部分是对象真正存储的有效信息，也就是程序中定义的各种类型的字段内容。</li></ul><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><ul><li>不是必然存在，仅仅起占位作用。</li><li>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整倍数，换句话说就是对象的大小必须是8字节的整倍数。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的过程</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java创建对象的过程"><a href="#Java创建对象的过程" class="headerlink" title="Java创建对象的过程"></a>Java创建对象的过程</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><ul><li>虚拟机遇到new指令时，首先去检查常量池中有没有这个类的符号应用，并且检查这个符号引用代表的类是否已被<strong>加载、验证、准备、解析、初始化</strong>过。如果没有，那么必须先执行相应的类的加载过程。</li></ul><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><ul><li>为新生对象分配内存，在类加载完成后就可以确定对象所需内存大小，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配的方式有”指针碰撞”和”空闲列表”，选择哪种方式由java堆是否规整决定，而java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定</li></ul><h3 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ul><li>适用于内存规整（没有内存碎片）</li><li>原理：用过的内存全部整理到一边，没有用过的内存放到另外一边，只要从没有用过的内存方向移动指定对象内存大小的位置即可。</li><li>GC收集器： Serial ， ParNew</li></ul><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ul><li>适用于堆内存不规整的情况下</li><li>原理：虚拟机会维护一个列表，该列表中记录哪些内存是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录</li><li>GC 收集器：CMS</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h3><ul><li>CAS + 失败重试：CAS 是一种乐观锁的实现方式。所谓乐观锁就是：每次不加锁而是假设没有冲突去完成某项操作，因为如果冲突失败就重试，直到成功为止。虚拟机采用CAS失败重试的方式保证更新操作的原子性</li><li>TLAB（Thread Local Allocation Buffer）：为每一个线程先在伊甸区分配一块内存，JVM 在给线程中对象分配内存时，首先在 TLAB 分配，当对象大于TLAB分配中的剩余内存或TLAB的内存用尽时，在采用CAS进行内存分配。</li></ul><h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><ul><li>内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化零值</strong>（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段数据类型所对应的零值。</li></ul><h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><ul><li>初始化零值完成之后，虚拟机需要对对象进行必要的设置。例如这个对象是哪个类的实例、如何才能找到<strong>类的元数据</strong>信息、对象的<strong>哈希码</strong>、对象的 <strong>GC</strong> 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如<strong>是否启用偏向锁</strong>等，对象头会有不同的设置方式。</li></ul><h2 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h2><ul><li>从虚拟机的视角来看，一个新的对象已经产生了，但从java程序的视角来看，对象创建才刚开始，<code>&lt;init&gt; </code> 方法还没有执行，所有字段都还为零。所以一般来说，执行完 new 指令后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm体系结构</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>​        JVM 是可运行 Java 代码的假想计算，包括<strong>一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域</strong>。 JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>完整内存模型图见：<a href="https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764">https://www.processon.com/diagraming/5d42ca2ce4b043dcf84e8764</a></p><p><img src="/2020/12/19/java/jvm/java-jvm-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1610267566650.png" alt="1610267566650"></p><ul><li>JVM 内存区域主要分为：线程私有区域【<strong>程序计数器、虚拟机栈、本地方法区</strong>】、线程共享区域【 <strong>JAVA 堆、方法区</strong>】、直接内存。</li></ul><ul><li>线程私有区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内，每个线程都与操作系统的本本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)。</li></ul><ul><li>线程区域随虚拟机的启动/关闭而创建/销毁。</li></ul><ul><li>直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用：在 JDK1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。</li></ul><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><ul><li>字节码解释器从程序计数器中取出指令，实现对流程的控制</li></ul><ul><li><p><strong>在线程切换的过程中，保存当前线程的执行位置，以便在线程恢复执行的时候找到正确的执行位置</strong></p></li><li><p>唯一一个不会发生 OutOfMemoryError 的区域。</p></li></ul><h3 id="Java虚拟机栈（线程私有）"><a href="#Java虚拟机栈（线程私有）" class="headerlink" title="Java虚拟机栈（线程私有）"></a>Java虚拟机栈（线程私有）</h3><ul><li>由一组栈帧组成，栈帧用来保存<strong>局部变量、操作数栈、动态链接、方法出口</strong>等信息，栈帧随着方法调用而创建，随着方法结束而销毁—-无论方法是正常完成还是异常完成（抛出了在方法内未捕获的异常）都算方法结束。</li><li>局部变量表主要存放了编译期可知的各种<strong>数据类型</strong>（boolean,byte,char,short,int,float,long,double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的应用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li><li>StackOverFlowError：若 java 虚拟机的内存大小不动态扩展，那么当线程请求栈的深度超过当前 java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li>OutOfMemory：若 java 虚拟机堆中没有空闲内存，并且垃圾收集器也无法提供更多的内存。就会抛出 OutOfMemoryError 错误。</li><li>每一次函数的调用就是对应栈帧的一次入栈到出栈的过程。</li></ul><h3 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h3><ul><li>使用到的是本地方法服务。</li><li>HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>线程私有区域，他的生命周期随着线程的创建而开始，随着线程的消亡而结束。</li></ul><h3 id="堆（-Heap-线程共享-）-运行时数据区"><a href="#堆（-Heap-线程共享-）-运行时数据区" class="headerlink" title="堆（ Heap-线程共享 ）-运行时数据区"></a>堆（ Heap-线程共享 ）-运行时数据区</h3><ul><li><p>目的是存放对象实例，几乎所有的对象实例和数组都在这里分配内存</p></li><li><p>随着JTI编译器的发展和逃逸分析技术的成熟，栈上分配、变量替换优化技术，使得所有对象在堆上的分配变得不那么绝对。<strong>如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存</strong>。</p></li><li><p>堆是垃圾收集器管理的主要区域，因此才被称为GC堆，现在垃圾收集器都是采用<strong>分代收集算法</strong>。Java堆细分：新生代和老年代，在细致一点的话就是：伊甸区，from区，to区。划分的目的是更好的回收内存，或者更快的分配内存。</p></li></ul><h3 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h3><ul><li>用于存放已被虚拟机加载的类信息，常量，静态变量，即时编译器后的代码数据。</li><li>java虚拟机规范把方法区描述为堆的一个逻辑部分，Non-Heap（非堆）</li><li>永久代就是HotsSpot虚拟机堆虚拟机规范方法区中的一种实现方式。也就是说，永久代是HotSpot的概念，方法区是java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。</li><li>-XX:PermSize=N  //方法区（永久代）初始大小</li><li>-XX:MaxPermSizze=N  //方法区（永久代）最大大小，超过这个值就会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError:PermGen</li></ul><h2 id="为什么元区间取代了永久代"><a href="#为什么元区间取代了永久代" class="headerlink" title="为什么元区间取代了永久代"></a>为什么元区间取代了永久代</h2><ul><li>永久代在 JVM 中受到 JVM 本身固定大小的限制，无法进行调整。</li><li>元空间使用的是直接内存，受本机可用内存的限制</li><li>元空间内存溢出：java.lang.OutOfMemoryError:MetaSpace</li><li>-XX:MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited ,这意味着他只受系统内存的限制</li><li>元空间里面存在的是元数据，这样加载多个类的元数据就不由 MaxPermSize 控制，而是由系统的实际可用空间来控制，这样能加载更多的类</li><li>在 JDK8 中，合并 HotSpot 和 Jrockit 的代码时，Jrockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了</li></ul><h2 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h2><ul><li>java7之前，运行时常量池包含字符串常量池。</li><li>java7，运行时常量池在永久代，字符串常量池在堆中。</li><li>java8，运行时常量池在元空间，字符串常量池在堆中。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul><li>本机的内存</li><li>JDK1.4 之后的 NIO ，引入了一种基于通道与缓存区的 I/O 方式，可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的应用操作，这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象死亡判断</title>
      <link href="2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/"/>
      <url>2020/12/19/java/jvm/java-jvm-%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="对象死亡判断"><a href="#对象死亡判断" class="headerlink" title="对象死亡判断"></a>对象死亡判断</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的</p><blockquote><p>​    难以解决对象间的循环引用。除了对象 objA和objB相互引用这对方外，这两个对象之间再无任何引用。但是他们因为相互引用对方，导致他们的应用计数器都不为0，于是引用计数算法无法通知GC回收器回收他们。</p></blockquote></li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始想下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li></ul><h4 id="可作为-GC-Roots-的对包括下面几种："><a href="#可作为-GC-Roots-的对包括下面几种：" class="headerlink" title="可作为 GC Roots 的对包括下面几种："></a>可作为 GC Roots 的对包括下面几种：</h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方发展（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>判定对象的存活与 “引用” 有关。</li><li>强引用（StrongReference）<ul><li>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。必不可少，垃圾收集器绝对不会回收他。当空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，是程序异常终止</li></ul></li><li>软引用<ul><li>如果一个对象具有软引用，可有可无，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</li></ul></li><li>弱引用<ul><li>可有可无，只具有弱引用的对象拥有更短暂的生命周期。在垃圾收集器线程扫描他所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></li><li>虚引用<ul><li>形同虚设。如果一个对象仅持有引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li></ul></li></ul><h2 id="不可达的对象并非-“不死不可”"><a href="#不可达的对象并非-“不死不可”" class="headerlink" title="不可达的对象并非 “不死不可”"></a>不可达的对象并非 “不死不可”</h2><ul><li>即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑阶段”，要真正宣告一个对象死亡，至少需要经历<strong>两次标记</strong>过程；可达性分析算法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法， 或 finalize 方法已经被虚拟机调用过时， 虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行二次标记，除非这个对象与应用链上的任何一个对象关联，否则真的会被回收。</li></ul><h2 id="如何判断一个常量是废弃的常量？"><a href="#如何判断一个常量是废弃的常量？" class="headerlink" title="如何判断一个常量是废弃的常量？"></a>如何判断一个常量是废弃的常量？</h2><ul><li>运行时常量池</li><li>加入在常量池中存在字符串 “abc” ， 如果当前没有任何 String 对象引用该字符串的话， 就说明常量 “abc” 就是废弃常量，如果这是发生内存回收的话而且有必要的话， “abc” 就会被系统清理出常量池。</li></ul><h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><ul><li>方法区主要回收的是无用的类</li><li>可以被回收<ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存穿透与雪崩</title>
      <link href="2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/"/>
      <url>2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存穿透（redis数据不存在，访问数据库）"><a href="#缓存穿透（redis数据不存在，访问数据库）" class="headerlink" title="缓存穿透（redis数据不存在，访问数据库）"></a>缓存穿透（redis数据不存在，访问数据库）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>在默认情况下，用户请求数据时，会先在缓存（Redis）中查找，若没找到即缓存未命中，再在数据库中查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景），缓存没有命中的话，就会将请求全部转移到数据库上，造成数据库的压力剧增，就有可能导致数据库的崩溃。</p></li><li><p>网络安全中的也有人恶意使用这种手段进行攻击称为洪水攻击。</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>对所有可能查询的参数以 hash 的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截，检验不通过则直接打回，减轻了存储系统的压力</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072357498.png" alt="1609072357498"></p><h3 id="缓存空对象（查询不到）"><a href="#缓存空对象（查询不到）" class="headerlink" title="缓存空对象（查询不到）"></a>缓存空对象（查询不到）</h3><p>一次查询若在缓存与数据库中都没有查询到，就在缓存中放一个空对象用于处理后续这个请求</p><p><img src="/2020/12/13/database/redis/redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9/1609072445647.png" alt="1609072445647"></p><p>这样做有一个缺陷：储存空对象也需要空间，大量空对象会消耗一定的空间，储存效率并不高。解决这个缺陷的方式就是 <strong>设置较短的过期时间</strong>。即使对空值设置了过期时间，还是会存在缓存层和储存层的数据会有一段时间的不一致，这对于需要保持一致性的业务会有影响。</p><h1 id="缓存击穿（单点量太大，缓存过期）"><a href="#缓存击穿（单点量太大，缓存过期）" class="headerlink" title="缓存击穿（单点量太大，缓存过期）"></a>缓存击穿（单点量太大，缓存过期）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在 key ，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时的 DB 请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个 key 的缓存不可用而导致的击穿，但是其他的 key 仍然可以使用缓存响应。</p></li><li><p>比如热搜排行榜，一个热点新闻同时被大量访问就可能导致缓存击穿。</p></li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h3><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候，也会清理部分书，而且此种方案会占用空间，一旦热点数据多了起来，就会占用大量空间</p><h3 id="加互斥锁（分布式锁）"><a href="#加互斥锁（分布式锁）" class="headerlink" title="加互斥锁（分布式锁）"></a>加互斥锁（分布式锁）</h3><p>在访问 key 之前，采用 setnx （set  if  not exists）来设置另一个短期 key 来锁住当前 key 的访问，访问结束再删除改短期 key 。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>大量的 key 设置了相同的过期时间，导致在缓存在同一时刻的 key 全部消失，造成瞬时 DB 请求量大、压力骤增、引起雪崩。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h3><p>这个思想的含义是：既然 redis 有可能挂掉，那就多增加几台 redis , 这样一台挂掉之后其他还可以继续工作，其实就是<strong>搭建集群</strong></p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>数据预热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部门可能大量访问的数据就会加载到内存中。在即将发生大并发访问前手动触发加载缓存不同的 key ，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>主从复制，是指将一台redis服务的数据，复制到其他的 redis 服务器。前者称为主节点（Master/Leader），后者称为从节点（Slave/Follower），数据的复制是单向的，只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</li></ul><ul><li>默认情况下，每台 Redis 服务器都是主节点，一个主节点可以有 0 个或者多个从节点，但是每个从节点只能有一个主节点。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式。</li><li>负载均衡：在主从复制的基础上，配合读写分离，有主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的情境下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还有哨兵和集群能都实施的基础。</li></ol><h2 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h2><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限</li></ol><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我们在讲解配置文件的时候，注意到有一个 replication 模块</p><p>查看当前库的信息： info replication</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master# 角色</span><br><span class="line">connected_slaves:0# 从机数量</span><br><span class="line">master_replid:f3265ac91a96212c069a098488f1557168e78338</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改一下信息：</p><ul><li>端口号</li><li>pid 文件名</li><li>日志文件名 </li><li>rdb 文件名</li></ul><p>启动单机多服务集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# ps -aux | grep redis</span><br><span class="line">root       2452  0.2  0.4 153988  8132 pts/0    Sl+  03:33   0:00 src/redis-server 127.0.0.1:6379</span><br><span class="line">root       2456  0.1  0.4 153988  8108 pts/1    Sl+  03:33   0:00 src/redis-server 127.0.0.1:6380</span><br><span class="line">root       2460  0.1  0.4 153988  8104 pts/2    Sl+  03:34   0:00 src/redis-server 127.0.0.1:6381</span><br><span class="line">root       2486  0.0  0.0 112812   972 pts/3    S+   03:34   0:00 grep --color=auto redis</span><br><span class="line">[root@localhost redis-5.0.4]# </span><br></pre></td></tr></table></figure><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p><strong>默认情况下，每台 Redis 服务器都是主节点； 我们一般情况下只用配置从机就好了！</strong></p><p>使用 REPLICAOF host port 就可以为从机配置主机了。</p><p>redis 6380 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; replicaof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info Replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:16d368a52b6b0f8c46b1a7a742722339410742be</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>redis 6381</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; REPLICAOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; INFO Replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:4</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:56</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:16d368a52b6b0f8c46b1a7a742722339410742be</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:56</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:43</span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line">127.0.0.1:6381&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后主机上也能看到从机的状态</p><p>redis 6379</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=154,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=154,lag=1</span><br><span class="line">master_replid:16d368a52b6b0f8c46b1a7a742722339410742be</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:154</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:154</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们这里使用命令搭建，是暂时的，真实开发中应该在从机配置文件中进行过配置，这样的话就是永久的。</p><p><img src="/2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1612342030970.png" alt="1612342030970"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只读，不能写，主机可读可写但是多用于写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; set name yangl</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; set name yangl</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.</span><br><span class="line">127.0.0.1:6381&gt; </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set name yangl</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;yangl&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化，集群中只是丢失了写操作，当主机恢复以后，又会连上从机恢复原状。</p></li><li><p>当从机宕机后，若不是使用配置的配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此次重新配置称为从机，又可以获取到主机的所有数据。这里就是提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令 REPLICAOF no one，这样执行以后从机独立出来称为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动？</p></blockquote><p>如果主机断开了连接，我们可以使用 REPLICAOF no one 让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大恢复了，那么就重新连接！</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>主从切换技术的方法是：<strong>当主机宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用</strong>。这不是一种推荐的方式，更多的时候，我们优先考虑哨兵模式。</p><h3 id="单机单个哨兵"><a href="#单机单个哨兵" class="headerlink" title="单机单个哨兵"></a>单机单个哨兵</h3><ul><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵检测到 master 宕机，会自动将 slave 切换成 master ， 然后通过 <strong>发布订阅模式</strong> 通知其他从服务器，修改配置文件，让它们切换成主机。</li></ul><p><img src="/2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/11320039-57a77ca2757d0924.webp" alt="img"></p><h3 id="多哨兵模式"><a href="#多哨兵模式" class="headerlink" title="多哨兵模式"></a>多哨兵模式</h3><p><img src="/2020/12/13/database/redis/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/11320039-3f40b17c0412116c.webp" alt="img"></p><p>哨兵的核心配置</p><table><thead><tr><th>配置项</th><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>port</td><td>整数</td><td>启动哨兵进程端口</td></tr><tr><td>dir</td><td>文件夹目录</td><td>哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td></tr><tr><td>sentinel down-after-milliseconds</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td>sentinel parallel-syncs</td><td>&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td>sentinel failover-timeout</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td>sentinel notification-script</td><td>&lt;服务名称&gt;&lt;脚本路径&gt;</td><td>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ul><li>数字1表示：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li></ul><blockquote><p>测试</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure><p>成功启动哨兵模式</p><p>// TOOD</p><p>此时哨兵模式监视着我们的主机6379，当我们断开主机后：</p><p>// TOOD</p><h3 id="哨兵的优缺点"><a href="#哨兵的优缺点" class="headerlink" title="哨兵的优缺点"></a>哨兵的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>哨兵集群，基于主从复制模式，所有的主从复制的优点，他都有</li><li>主从可以切换，故障可以转移，系统的可用性好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Redis 不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><blockquote><p>哨兵模式的全部配置</p></blockquote><h3 id="完整的哨兵模式配置文件-sentinel-conf"><a href="#完整的哨兵模式配置文件-sentinel-conf" class="headerlink" title="完整的哨兵模式配置文件 sentinel.conf"></a>完整的哨兵模式配置文件 sentinel.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h2 id="redis-红锁（redlock）"><a href="#redis-红锁（redlock）" class="headerlink" title="redis 红锁（redlock）"></a>redis 红锁（redlock）</h2><p>关于分布式锁，一般有三种选择，</p><ol><li>redis </li><li>zk</li><li>DB锁（悲观锁、乐观锁）</li></ol><p>其中用的最多的应该是redis。</p><p>redis 常用的方式有单节点、主从模式、哨兵模式、集群模式。</p><p>单节点在生产环境基本上不会使用，因为不能达到高可用，且连 RDB 或 AOF 备份都只能放在 master 上，所以基本上不会使用。</p><p>另外几种模式都无法避免两个问题：</p><ol><li>异步数据丢失。</li><li>脑裂问题。</li></ol><p>所以redis官方针对这种情况提出了红锁（<strong>Redlock</strong>）的概念。</p><p>假设有5个redis节点，这些节点之间既没有主从，也没有集群关系。客户端用相同的key和随机值在5个节点上请求锁，请求锁的超时时间应小于锁自动释放时间。当在3个（超过半数）redis上请求到锁的时候，才算是真正获取到了锁。如果没有获取到锁，则把部分已锁的redis释放掉。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis发布订阅模式</title>
      <link href="2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis发布订阅模式"><a href="#Redis发布订阅模式" class="headerlink" title="Redis发布订阅模式"></a>Redis发布订阅模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Redis发布订阅（pub/sub）是一种消息通信模式：发布者（pub）,发送消息，订阅者（sub）接收消息。</p><ul><li>下图展示了频道 channel1，以及订阅这个频道的三个客户端–client1、client2和client3之间的关系：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287271460.png" alt="1609287271460"></p><ul><li>当有新的消息通过PUBLISH命令发送给频道 channel1 时，这个消息就会被发送给订阅他的三个客户端：</li></ul><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287501584.png" alt="1609287501584"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PSUBSCRIBE pattern [pattern..]</code></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUNSUBSCRIBE pattern [pattern..]</code></td><td>退订一个或多个符合给定模式的频道。</td></tr><tr><td><code>PUBSUB subcommand [argument[argument]]</code></td><td>查看订阅与发布系统状态。</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向指定频道发布消息</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>订阅给定的一个或多个频道。</td></tr><tr><td><code>SUBSCRIBE channel [channel..]</code></td><td>退订一个或多个频道</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--------------- 订阅 yangl ---------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE yangl</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;# 订阅成功</span><br><span class="line">2) &quot;yangl&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;# 接受到 yangl 发布的消息</span><br><span class="line">2) &quot;yangl&quot;</span><br><span class="line">3) &quot;hello world&quot;</span><br><span class="line">1) &quot;message&quot;# 接受到 yangl 发布的消息</span><br><span class="line">2) &quot;yangl&quot;</span><br><span class="line">3) &quot;hello i am yangl&quot;</span><br><span class="line"></span><br><span class="line">--------------- 发布消息 yangl ---------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; PUBLISH yangl &quot;hello world&quot;# 发布消息到 yangl 频道</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH yangl &quot;hello i am yangl&quot; # 发布消息到 yangl 频道</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">----------------- 查看活跃的频道 ------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) &quot;yangl&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每个 redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer结构，结构的 pubsub_channels 属性是一个字典，这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2020/12/13/database/redis/redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1609287992211.png" alt="1609287992211"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度确不够快的话，那么不断积压消息会使 redis 输出缓冲区的体积变得越来越大，这可能使得 redis 本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短期时间发布者发布的消息。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>消息订阅：公众号订阅，微博关注等等（其实更多的是消息队列来进行实现）</li><li>多人在线聊天室</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ来处理。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="2020/12/13/database/redis/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/12/13/database/redis/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h1><ul><li>Redis基于<strong>Reactor模型</strong>设计开发了一套高效的<strong>事件处理</strong>模型。这套事件处理模型对应的事R<strong>edis中的文件事件处理器</strong>（file event handler）。<strong>由于文件处理器是单线程方式运行的，所以我们一般都说Redis是单线程模型。</strong></li></ul><h1 id="既然是单线程，怎么监听大量客户端连接"><a href="#既然是单线程，怎么监听大量客户端连接" class="headerlink" title="既然是单线程，怎么监听大量客户端连接"></a>既然是单线程，怎么监听大量客户端连接</h1><ul><li>Redis通过IO多路复用程序来监听来自客户端的大量连接。</li><li>IO多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</li><li>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. <strong>时间事件</strong>。</li></ul><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。<br>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>虽然文件事件处理器以单线程方式运行，但通过<strong>使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><ul><li>文件事件处理器（file event handler）主要是包含 4 个部分：<ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul></li></ul><p><img src="/2020/12/13/database/redis/redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/1612438936750.png" alt="1612438936750"></p><h1 id="Redis为什么不用多线程"><a href="#Redis为什么不用多线程" class="headerlink" title="Redis为什么不用多线程"></a>Redis为什么不用多线程</h1><ul><li>Redis 是单线程模型，但是， 实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</li><li>Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><h1 id="Redis6-0之后为什么引入了多线程"><a href="#Redis6-0之后为什么引入了多线程" class="headerlink" title="Redis6.0之后为什么引入了多线程"></a>Redis6.0之后为什么引入了多线程</h1><ul><li>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</li><li>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 redis.conf ：<ul><li>io-threads-do-reads yes</li></ul></li><li>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 redis.conf :<ul><li>io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="持久化——-RDB"><a href="#持久化——-RDB" class="headerlink" title="持久化—— RDB"></a>持久化—— RDB</h1><h2 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h2><ul><li><p>在指定时间间隔后，将内存中的数据快照写入硬盘，在恢复的时候，直接读取快照文件，进行数据的恢复。</p></li><li><p>默认情况下，redis将数据库快照保证在名字为 dump.rdb 的二进制文件中。文件名可以在配置文件中进行自定义。</p></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在进行rdb的时候，redis主线程是不会做io操作的，主线程会 fork 一个子线程来完成该操作：</p><ol><li>Redis 调用 fork 。 同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中</li><li>当子进程完成对新 RDB 文件写入时， Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件</li></ol><p>这种工作方式使得Redis 可以从写时复制（copy-on-write） 机制中获益（因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求）</p><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/20200513215141519.jpg" alt="在这里插入图片描述"></p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><ol><li>save 的规则满足的情况下， 会自动触发 rdb原则</li><li>执行 flushall 命令也会触发我们的 rdb 原则</li><li>退出 redis 也会自动产生 rdb 文件</li></ol><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>使用 save 命令， 会立刻对当前内存中的数据进行持久化， 但是会阻塞， 也就是不接受其他操作了</p><blockquote><p>由于 save 命令是同步命令， 会占用 Redis 的主进程。 若Redis 数据非常多时， save 命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/20200513215150892.jpg" alt="在这里插入图片描述"></p><h3 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h3><p>flushall 命令也会触发持久化</p><h3 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h3><p>满足配置条件中的触发条件：</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在 “N 秒内数据集至少有 M 个改动” 这一条件满足时， 会自动进行数据集保存操作。</p></blockquote><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/1611993214979.png" alt="1611993214979"></p><ul><li>save 900 1 # 900秒内， 至少1个key进行了修改，就进行持久化</li><li>save 300 10    # 300 秒内， 至少10个 key 进行了修改，则进行持久化</li><li>save 60 10000    # 60秒内， 至少10000个 key  进行了修改，则进行持久化</li></ul><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/20200513215220858.jpg" alt="在这里插入图片描述"></p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>bgsave 是异步进行， 进行持久化的时候， redis 还可以将继续响应客户端请求</p><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/2020051321523151.jpg" alt="在这里插入图片描述"></p><p>bgsave 和 save 对比</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了</li><li>fork 进程的时候， 会占用一定的内存空间</li></ol><h1 id="持久化——-AOF"><a href="#持久化——-AOF" class="headerlink" title="持久化—— AOF"></a>持久化—— AOF</h1><p>Append Only File</p><p>将我们所有的命令都记录下来， history 恢复的时候就把这个文件全部再执行一遍</p><blockquote><p>以日志的形式来记录每个写操作，将redis执行的指令记录下来（读操作不记录），只需追加文件但不可以修改文件，redis 启动之初会读取改文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>快照功能（RDB) 并不是非常耐久：如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入，以及未保存到快照中的那些数据，从1.1版本开始，Redis增加了一种完全耐久的持久方式：AOF持久化。</p><p>如果要使用AOF，需要修改配置文件：</p><p><img src="/2020/12/13/database/redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96/1609059576333.png" alt="1609059576333"></p><p>appendonly 默认是 no 不开启的，我们需要手动配置，然后重启 redis ，就可以生效</p><p>如果这个 aof 文件有错误，这时候 redis 是启动不起来的，我们需要修改这个 aof 文件</p><p>redis 给我们提供了一个工具， <code>redis-check-aof --fix</code></p><blockquote><ul><li>appendonly  yes 则表示启动AOF</li></ul><ul><li>appendfilename “appendonly.aof”  表示保存的文件名为 “appendonly.aof”</li></ul><ul><li><h1 id="appendfsync-always-每次修改都会sync-消耗性能"><a href="#appendfsync-always-每次修改都会sync-消耗性能" class="headerlink" title="appendfsync always # 每次修改都会sync 消耗性能"></a>appendfsync always # 每次修改都会sync 消耗性能</h1></li><li><p>appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据</p></li><li><h1 id="appendfsync-no-不执行-sync-这时候操作系统自己同步数据，速度最快"><a href="#appendfsync-no-不执行-sync-这时候操作系统自己同步数据，速度最快" class="headerlink" title="appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快"></a>appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</h1></li></ul></blockquote><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>每一次修改都会同步，文件的完整性会更加的好</li><li>每秒同步一次，可能会丢失最后一秒的数据</li><li>从不同步，效率最高</li></ul><p>缺点</p><ul><li>相对于数据文件来说，aof远远大于rdb，修复速度比 rdb 慢！</li><li>aof 运行效率也比 rdb 慢，所以我们 redis 默认的配置就是 rdb 持久化</li></ul><p>RDB与AOF的选择</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><p>如何选择使用哪种持久化方式？</p><ul><li><p>一般来说，如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p></li><li><p>如果你非常关心你的数据，但仍然可以承受部分数据数分钟以内的丢失，那么你可以选择只使用RDB 持久化</p></li><li><p>有很多用户都只是用AOF持久化，但并不推荐这种持久化方式：因为定时生成的AOF快照非常便于数据备份，并且RDB恢复数据集的速度也要比 AOF 恢复的速度快</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis事务</title>
      <link href="2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/12/13/database/redis/redis-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis事务概念"><a href="#Redis事务概念" class="headerlink" title="Redis事务概念"></a>Redis事务概念</h1><ul><li>Redis 的单条命令是保证原子性的，但是<strong>redis事务不能保证原子性</strong></li></ul><blockquote><p>Redis 事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按照顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>循序性</li><li>排他性</li></ul><hr><ol><li>Redis 事务没有隔离级别的概念</li><li>Redis 单条命令是保证原子性的，但是事务不保证原子性</li></ol></blockquote><h1 id="Redis-事务操作过程"><a href="#Redis-事务操作过程" class="headerlink" title="Redis 事务操作过程"></a>Redis 事务操作过程</h1><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ul><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>所有事务中的命令在加入时没有被执行，直到提交时才会开始执行（Exec）一次性完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name1 yangl1# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set name2 yangl2# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name1# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set name3 yangl3# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec# 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;yangl1&quot;</span><br><span class="line">4) OK</span><br><span class="line">5) 1) &quot;name2&quot;</span><br><span class="line">   2) &quot;name1&quot;</span><br><span class="line">   3) &quot;name3&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h2 id="取消事务-discurd"><a href="#取消事务-discurd" class="headerlink" title="取消事务(discurd)"></a>取消事务(discurd)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name1 yangl1# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set name2 yangl2# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD# 放弃事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC# 执行事务</span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; get name1# 被放弃事务中命令并未执行</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h2><h3 id="代码语法错误"><a href="#代码语法错误" class="headerlink" title="代码语法错误"></a>代码语法错误</h3><blockquote><p>（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI# 开始事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name1 yangl# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set name2 yangl2# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name1 name2# 错误命令</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;get&#x27; command# 会报错但是不影响后续命令入队</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; set name3 yangl3# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name3# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC# 执行事务</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.# 执行报错</span><br><span class="line">127.0.0.1:6379&gt; get name1</span><br><span class="line">(nil)# 其他命令并没有被执行</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h3 id="代码逻辑错误"><a href="#代码逻辑错误" class="headerlink" title="代码逻辑错误"></a>代码逻辑错误</h3><blockquote><p>（运行时异常） <strong>其他命令能正常执行 ——&gt; 所以不保证事务的原子性</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name1 yangl1# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set name2 yangl2# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR name1# 命令进入队列（运行时会报错，对字符串进行增量）</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name2# 命令进入队列</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC# 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an integer or out of range</span><br><span class="line">4) &quot;yangl2&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</li><li>所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</li></ol><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><h3 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h3><blockquote><p>使用  <code>watch key</code>  监控指定数据，相当于乐观锁加锁。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set user1 100# 设置用户1 余额:100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set suer2 0# 设置用户2 余额:0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH money# 监视money (上锁)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI # 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY user1 30# 用户1 余额减少：30</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY user2 30# 用户2 余额增加：30</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC# 执行事务，监视值没有被中途修改，事务正常执行</span><br><span class="line">1) (integer) 70</span><br><span class="line">2) (integer) 30</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h3 id="多线程操作"><a href="#多线程操作" class="headerlink" title="多线程操作"></a>多线程操作</h3><blockquote><p>测试多线程修改值，使用 watch 可以当做 redis 的乐观锁操作（相当于 get version）</p></blockquote><p>线程1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set user1 100# 设置用户1 余额:100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set user2 0# 设置用户2 余额:0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH user1# 监视money (上锁)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI# 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY user1 30# 用户1 余额减少：30</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY user2 30# 用户2 余额增加：30</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; # 此时事务并没有执行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY user1 100# 修改了 线程1 中监视的 user1</span><br><span class="line">(integer) 200</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p>线程1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC# 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span><br><span class="line">(nil) # 没有结果，说明事务执行失败</span><br><span class="line">127.0.0.1:6379&gt; get user1# 线程2 修改生效</span><br><span class="line">&quot;200&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user2# 线程1事务执行失败，数值没有被修改</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure><blockquote><p>解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code> 进行解锁。</p></blockquote><p>注意：每次提交执行 exec 后都会自动释放锁，不管是否成功</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis配置</title>
      <link href="2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/"/>
      <url>2020/12/13/database/redis/redis-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p><strong>redis-5.0.4 配置解读</strong></p><h2 id="开头说明"><a href="#开头说明" class="headerlink" title="开头说明"></a>开头说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis configuration file example.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that in order to read the configuration file, Redis must be</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> started with the file path as first argument:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># ./redis-server /path/to/redis.conf</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note on units: when memory size is needed, it is possible to specify</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it <span class="keyword">in</span> the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1k =&gt; 1000 bytes</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>容量单位不区分大小写，G和GB有区别</li></ul></blockquote><h2 id="INCLUDES（其他配置文件设置）"><a href="#INCLUDES（其他配置文件设置）" class="headerlink" title="INCLUDES（其他配置文件设置）"></a>INCLUDES（其他配置文件设置）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# INCLUDES ###################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Include one or more other config files here.  This is useful <span class="keyword">if</span> you</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> have a standard template that goes to all Redis servers but also need</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to customize a few per-server settings.  Include files can include</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> other files, so use this wisely.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> from admin or Redis Sentinel. Since Redis always uses the last processed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> line as value of a configuration directive, you<span class="string">&#x27;d better put includes</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> at the beginning of this file to avoid overwriting config change at runtime.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If instead you are interested in using includes to override configuration</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> options, it is better to use include as the last line.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># include /path/to/local.conf</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> include /path/to/other.conf</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>可以设置多个配置文件组合使用</li></ul></blockquote><h2 id="NETWORK（网络设置）"><a href="#NETWORK（网络设置）" class="headerlink" title="NETWORK（网络设置）"></a>NETWORK（网络设置）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# NETWORK #####################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default, <span class="keyword">if</span> no <span class="string">&quot;bind&quot;</span> configuration directive is specified, Redis listens</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> connections from all the network interfaces available on the server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is possible to listen to just one or multiple selected interfaces using</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the <span class="string">&quot;bind&quot;</span> configuration directive, followed by one or more IP addresses.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Examples:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1 ::1</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> internet, binding to all the interfaces is dangerous and will expose the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instance to everybody on the internet. So by default we uncomment the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> following <span class="built_in">bind</span> directive, that will force Redis to listen only into</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the IPv4 loopback interface address (this means Redis will be able to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> accept connections only from clients running into the same computer it</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is running).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Protected mode is a layer of security protection, <span class="keyword">in</span> order to avoid that</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis instances left open on the internet are accessed and exploited.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When protected mode is on and if:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) The server is not binding explicitly to a set of addresses using the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="string">&quot;bind&quot;</span> directive.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) No password is configured.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The server only accepts connections from clients connecting from the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sockets.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default protected mode is enabled. You should disable it only if</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you are sure you want clients from other hosts to connect to Redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> even <span class="keyword">if</span> no authentication is configured, nor a specific <span class="built_in">set</span> of interfaces</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are explicitly listed using the <span class="string">&quot;bind&quot;</span> directive.</span></span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Accept connections on the specified port, default is 6379 (IANA <span class="comment">#815344).</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If port 0 is specified Redis will not listen on a TCP socket.</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP listen() backlog.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># In high requests-per-second environments you need an high backlog in order</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to avoid slow clients connections issues. Note that the Linux kernel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to get the desired effect.</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unix socket.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Specify the path for the Unix socket that will be used to listen for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on a unix socket when not specified.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># unixsocket /tmp/redis.sock</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Close the connection after a client is idle <span class="keyword">for</span> N seconds (0 to <span class="built_in">disable</span>)</span></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP keepalive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of communication. This is useful <span class="keyword">for</span> two reasons:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) Detect dead peers.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Take the connection alive from the point of view of network</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    equipment <span class="keyword">in</span> the middle.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that to close the connection the double of the time is needed.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On other kernels the period depends on the kernel configuration.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A reasonable value for this option is 300 seconds, which is the new</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis default starting with Redis 3.2.1.</span></span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure><blockquote><ul><li>bind 127.0.0.1  # 只接受来自该IP地址的请求，如果不设置将处理所有请求，可设置多个。</li><li>protected-mode yes #  是否开启保护模式默认开启（yes）。假如配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。如果开启了密码和bind，可以开启。否则最好关闭，设置为no</li><li>port 6379    # 监听的端口号，默认6379</li><li>timeout 0 # 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接。默认值为0，表示不关闭。</li><li>tcp-keepalive 300 # 单位是秒，表示将周期性的使用 SO_KEEPALIVE 检测客户端是否还处于健康状态，避免服务器一直阻塞，默认300s，如果设置为0，则不会周期性的检测。</li></ul></blockquote><h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################ GENERAL #####################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis does not run as a daemon. Use <span class="string">&#x27;yes&#x27;</span> <span class="keyword">if</span> you need it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that Redis will write a pid file <span class="keyword">in</span> /var/run/redis.pid when daemonized.</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you run Redis from upstart or systemd, Redis can interact with your</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> supervision tree. Options:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   supervised no      - no supervision interaction</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   supervised systemd - signal systemd by writing READY=1 to <span class="variable">$NOTIFY_SOCKET</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   supervised auto    - detect upstart or systemd method based on</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note: these supervision methods only signal <span class="string">&quot;process is ready.&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       They <span class="keyword">do</span> not <span class="built_in">enable</span> continuous liveness pings back to your supervisor.</span></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If a pid file is specified, Redis writes it <span class="built_in">where</span> specified at startup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and removes it at <span class="built_in">exit</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When the server runs non daemonized, no pid file is created if none is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> specified <span class="keyword">in</span> the configuration. When the server is daemonized, the pid file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is used even <span class="keyword">if</span> not specified, defaulting to <span class="string">&quot;/var/run/redis.pid&quot;</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Creating a pid file is best effort: if Redis is not able to create it</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nothing bad happens, the server will start and run normally.</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the server verbosity level.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This can be one of:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug (a lot of information, useful <span class="keyword">for</span> development/testing)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice (moderately verbose, what you want <span class="keyword">in</span> production probably)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the <span class="built_in">log</span> file name. Also the empty string can be used to force</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis to <span class="built_in">log</span> on the standard output. Note that <span class="keyword">if</span> you use standard</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> output <span class="keyword">for</span> logging but daemonize, logs will be sent to /dev/null</span></span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">enable</span> logging to the system logger, just <span class="built_in">set</span> <span class="string">&#x27;syslog-enabled&#x27;</span> to yes,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the syslog identity.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a different one on a per-connection basis using SELECT &lt;dbid&gt; <span class="built_in">where</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dbid is a number between 0 and <span class="string">&#x27;databases&#x27;</span>-1</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis shows an ASCII art logo only when started to <span class="built_in">log</span> to the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> standard output and <span class="keyword">if</span> the standard output is a TTY. Basically this means</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that normally a logo is displayed only <span class="keyword">in</span> interactive sessions.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># However it is possible to force the pre-4.0 behavior and always show a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ASCII art logo <span class="keyword">in</span> startup logs by setting the following option to yes.</span></span><br><span class="line">always-show-logo yes</span><br></pre></td></tr></table></figure><h3 id="守护进程设置"><a href="#守护进程设置" class="headerlink" title="守护进程设置"></a>守护进程设置</h3><blockquote><ul><li>daemonize no # 是否在后台执行，yes：后台运行,即以守护线程的方式运行；no：不是后台运行。默认是no。</li><li>supervised no # 用来管理守护进程的</li><li>pidfile /var/run/redis_6379.pid # 当服务器运行非守护进程时，如果在配置中没有指定pid文件，则不会创建pid文件。当服务器被守护时，即使没有指定pid文件也会被使用，默认为”/var/run/redis.pid”。</li></ul></blockquote><h3 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h3><blockquote><ul><li><p>loglevel notice    # 日志级别设置，默认 notice。（有四种级别）</p><ul><li>debug # 很多信息，方便开发、测试</li><li>verbose # 许多有用的信息，但是没有debug级别信息多</li><li>notice # 适当的日志级别，适合生产环境</li><li>waring # 只有非常重要的信息</li></ul></li><li><p>logfile “”  # 配置log文件地址</p></li></ul></blockquote><h3 id="数据库数量设置"><a href="#数据库数量设置" class="headerlink" title="数据库数量设置"></a>数据库数量设置</h3><blockquote><ul><li>databases 16 # 默认16个数据库</li></ul></blockquote><h3 id="logo设置"><a href="#logo设置" class="headerlink" title="logo设置"></a>logo设置</h3><blockquote><ul><li>always-show-logo yes # 是否总是显示 redis 的 logo 即开启 redis 时候显示的打印的 logo</li></ul></blockquote><h2 id="SNAPSHOTTING（快照：持久化（RDB））"><a href="#SNAPSHOTTING（快照：持久化（RDB））" class="headerlink" title="SNAPSHOTTING（快照：持久化（RDB））"></a>SNAPSHOTTING（快照：持久化（RDB））</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### SNAPSHOTTING  ################################</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Save the DB on disk:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   Will save the DB if both the given number of seconds and the given</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   In the example below the behaviour will be to save:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 900 sec (15 min) <span class="keyword">if</span> at least 1 key changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 300 sec (5 min) <span class="keyword">if</span> at least 10 keys changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 60 sec <span class="keyword">if</span> at least 10000 keys changed</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   It is also possible to remove all the previously configured save</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   like <span class="keyword">in</span> the following example:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   save &quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis will stop accepting writes <span class="keyword">if</span> RDB snapshots are enabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This will make the user aware (<span class="keyword">in</span> a hard way) that data is not persisting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disaster will happen.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If the background saving process will start working again Redis will</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> automatically allow writes again.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and persistence, you may want to <span class="built_in">disable</span> this feature so that Redis will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">continue</span> to work as usual even <span class="keyword">if</span> there are problems with disk,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> permissions, and so forth.</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For default that<span class="string">&#x27;s set to &#x27;</span>yes<span class="string">&#x27; as it&#x27;</span>s almost always a win.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you want to save some CPU <span class="keyword">in</span> the saving child <span class="built_in">set</span> it to <span class="string">&#x27;no&#x27;</span> but</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the dataset will likely be bigger <span class="keyword">if</span> you have compressible values or keys.</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hit to pay (around 10%) when saving and loading RDB files, so you can <span class="built_in">disable</span> it</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> maximum performances.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tell the loading code to skip the check.</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The filename <span class="built_in">where</span> to dump the DB</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The working directory.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> above using the <span class="string">&#x27;dbfilename&#x27;</span> configuration directive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The Append Only File will also be created inside this directory.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><blockquote><ul><li>save 持久化规则，持久化文件 .rdb  .aof文件中（可开启多种，满足任意一个条件执行）<ul><li>save 900 1 # 900秒内， 至少1个key进行了修改，就进行持久化</li><li>save 300 10    # 300 秒内， 至少10个 key 进行了修改，则进行持久化</li><li>save 60 10000    # 60秒内， 至少10000个 key  进行了修改，则进行持久化</li></ul></li><li>stop-writes-on-bgsave-error yes    #  持久化如果出错，是否要继续工作。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li><li>rdbcompression yes    # rdb 持久化的时候启动压缩，需要消耗一定的 cpu 资源。如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li><li>rdbchecksum yes    # 保存rdb文件的时候，进行错误的检查校验。</li><li>dbfilename dump.rdb    # 保存文件名称为 dump.rdb</li><li>dir ./    # rdb 文件保存的目录，redis启动时就会恢复其中的数据。</li></ul></blockquote><h2 id="REPLICATION（主从复制）"><a href="#REPLICATION（主从复制）" class="headerlink" title="REPLICATION（主从复制）"></a>REPLICATION（主从复制）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################ REPLICATION #################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Master-Replica replication. Use replicaof to make a Redis instance a copy of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> another Redis server. A few things to understand ASAP about Redis replication.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   +------------------+      +---------------+</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   +------------------+      +---------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) Redis replication is asynchronous, but you can configure a master to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    stop accepting writes <span class="keyword">if</span> it appears to be not connected with at least</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    a given number of replicas.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Redis replicas are able to perform a partial resynchronization with the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    master <span class="keyword">if</span> the replication link is lost <span class="keyword">for</span> a relatively small amount of</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    time. You may want to configure the replication backlog size (see the next</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    sections of this file) with a sensible value depending on your needs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) Replication is automatic and does not need user intervention. After a</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    network partition replicas automatically try to reconnect to masters</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    and resynchronize with them.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If the master is password protected (using the <span class="string">&quot;requirepass&quot;</span> configuration</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> directive below) it is possible to tell the replica to authenticate before</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> starting the replication synchronization process, otherwise the master will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> refuse the replica request.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># masterauth &lt;master-password&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When a replica loses its connection with the master, or when the replication</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is still <span class="keyword">in</span> progress, the replica can act <span class="keyword">in</span> two different ways:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    still reply to client requests, possibly with out of date data, or the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    data <span class="built_in">set</span> may just be empty <span class="keyword">if</span> this is the first synchronization.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    an error <span class="string">&quot;SYNC with master in progress&quot;</span> to all the kind of commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    COMMAND, POST, HOST: and LATENCY.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">replica-serve-stale-data yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can configure a replica instance to accept writes or not. Writing against</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a replica instance may be useful to store some ephemeral data (because data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> written on a replica will be easily deleted after resync with the master) but</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> may also cause problems <span class="keyword">if</span> clients are writing to it because of a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> misconfiguration.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Since Redis 2.6 by default replicas are read-only.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note: read only replicas are not designed to be exposed to untrusted clients</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on the internet. It<span class="string">&#x27;s just a protection layer against misuse of the instance.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Still a <span class="built_in">read</span> only replica exports by default all the administrative commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> security of <span class="built_in">read</span> only replicas using <span class="string">&#x27;rename-command&#x27;</span> to shadow all the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> administrative / dangerous commands.</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication SYNC strategy: disk or socket.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># -------------------------------------------------------</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># New replicas and reconnecting replicas that are not able to continue the replication</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> process just receiving differences, need to <span class="keyword">do</span> what is called a <span class="string">&quot;full</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> synchronization<span class="string">&quot;. An RDB file is transmitted from the master to the replicas.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The transmission can happen <span class="keyword">in</span> two different ways:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                 file on disk. Later the file is transferred by the parent</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                 process to the replicas incrementally.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Diskless: The Redis master creates a new process that directly writes the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">              RDB file to replica sockets, without touching the disk at all.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># With disk-backed replication, while the RDB file is generated, more replicas</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> can be queued and served with the RDB file as soon as the current child producing</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the RDB file finishes its work. With diskless replication instead once</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the transfer starts, new replicas arriving will be queued and a new transfer</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will start when the current one terminates.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When diskless replication is used, the master waits a configurable amount of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> time (<span class="keyword">in</span> seconds) before starting the transfer <span class="keyword">in</span> the hope that multiple replicas</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will arrive and the transfer can be parallelized.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># With slow disks and fast (large bandwidth) networks, diskless replication</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> works better.</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When diskless replication is enabled, it is possible to configure the delay</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the server waits <span class="keyword">in</span> order to spawn the child that transfers the RDB via socket</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to the replicas.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This is important since once the transfer starts, it is not possible to serve</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> new replicas arriving, that will be queued <span class="keyword">for</span> the next RDB transfer, so the server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> waits a delay <span class="keyword">in</span> order to <span class="built_in">let</span> more replicas arrive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The delay is specified in seconds, and by default is 5 seconds. To disable</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it entirely just <span class="built_in">set</span> it to 0 seconds and the transfer will start ASAP.</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replicas send PINGs to server <span class="keyword">in</span> a predefined interval. It<span class="string">&#x27;s possible to change</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this interval with the repl_ping_replica_period option. The default value is 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-ping-replica-period 10</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following option sets the replication timeout <span class="keyword">for</span>:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Master timeout from the point of view of replicas (data, pings).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># It is important to make sure that this value is greater than the value</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> specified <span class="keyword">for</span> repl-ping-replica-period otherwise a timeout will be detected</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> every time there is low traffic between the master and the replica.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-timeout 60</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Disable TCP_NODELAY on the replica socket after SYNC?</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> less bandwidth to send data to replicas. But this can add a delay <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the data to appear on the replica side, up to 40 milliseconds with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux kernels using a default configuration.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be reduced but more bandwidth will be used <span class="keyword">for</span> replication.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default we optimize for low latency, but in very high traffic conditions</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or when the master and replicas are many hops away, turning this to <span class="string">&quot;yes&quot;</span> may</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be a good idea.</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the replication backlog size. The backlog is a buffer that accumulates</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replica data when replicas are disconnected <span class="keyword">for</span> some time, so that when a replica</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wants to reconnect again, often a full resync is not needed, but a partial</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> resync is enough, just passing the portion of data the replica missed <span class="keyword">while</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disconnected.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The bigger the replication backlog, the longer the time the replica can be</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disconnected and later be able to perform a partial resynchronization.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The backlog is only allocated once there is at least a replica connected.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-backlog-size 1mb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> After a master has no longer connected replicas <span class="keyword">for</span> some time, the backlog</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will be freed. The following option configures the amount of seconds that</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> need to elapse, starting from the time the last replica disconnected, <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the backlog buffer to be freed.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that replicas never free the backlog for timeout, since they may be</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> promoted to masters later, and should be able to correctly <span class="string">&quot;partially</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> resynchronize<span class="string">&quot; with the replicas: hence they should always accumulate backlog.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A value of 0 means to never release the backlog.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># repl-backlog-ttl 3600</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The replica priority is an <span class="built_in">integer</span> number published by Redis <span class="keyword">in</span> the INFO output.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is used by Redis Sentinel <span class="keyword">in</span> order to select a replica to promote into a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master <span class="keyword">if</span> the master is no longer working correctly.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A replica with a low priority number is considered better for promotion, so</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> instance <span class="keyword">if</span> there are three replicas with priority 10, 100, 25 Sentinel will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pick the one with priority 10, that is the lowest.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># However a special priority of 0 marks the replica as not able to perform the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> role of master, so a replica with priority of 0 will never be selected by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis Sentinel <span class="keyword">for</span> promotion.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default the priority is 100.</span></span></span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is possible <span class="keyword">for</span> a master to stop accepting writes <span class="keyword">if</span> there are less than</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> N replicas connected, having a lag less or equal than M seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The N replicas need to be in &quot;online&quot; state.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the last ping received from the replica, that is usually sent every second.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This option does not GUARANTEE that N replicas will accept the write, but</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will <span class="built_in">limit</span> the window of exposure <span class="keyword">for</span> lost writes <span class="keyword">in</span> <span class="keyword">case</span> not enough replicas</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are available, to the specified number of seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># min-replicas-to-write 3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-replicas-max-lag 10</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Setting one or the other to 0 disables the feature.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default min-replicas-to-write is set to 0 (feature disabled) and</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> min-replicas-max-lag is <span class="built_in">set</span> to 10.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> A Redis master is able to list the address and port of the attached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replicas <span class="keyword">in</span> different ways. For example the <span class="string">&quot;INFO replication&quot;</span> section</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offers this information, <span class="built_in">which</span> is used, among other tools, by</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis Sentinel <span class="keyword">in</span> order to discover replica instances.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Another place <span class="built_in">where</span> this info is available is <span class="keyword">in</span> the output of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;ROLE&quot;</span> <span class="built_in">command</span> of a master.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The listed IP and address normally reported by a replica is obtained</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the following way:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   IP: The address is auto detected by checking the peer address</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   of the socket used by the replica to connect with the master.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   Port: The port is communicated by the replica during the replication</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   handshake, and is normally the port that the replica is using to</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   listen <span class="keyword">for</span> connections.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># However when port forwarding or Network Address Translation (NAT) is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> used, the replica may be actually reachable via different IP and port</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pairs. The following two options can be used by a replica <span class="keyword">in</span> order to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> report to its master a specific <span class="built_in">set</span> of IP and port, so that both INFO</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and ROLE will report those values.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># There is no need to use both the options if you need to override just</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the port or the IP address.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># replica-announce-ip 5.5.5.5</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replica-announce-port 1234</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>replica-serve-stale-data yes #  当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：</p><ul><li>yes # (默认设置)，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候。</li><li>no # 副本会回复错误 “ SYNC with master in progress “ 到所有类型的命令，除了 INFO，replicaOF，AUTH，PING，SHUTDOWN，REPLCONF， ROLE， CONFIG，SUBSCRIBE， UNSUBSCRIBE，PSUBSCRIBE， PUNSUBSCRIBE， PUBLISH， PUBSUB，COMMAND， POST， HOST 和 LATENCY 。</li></ul></li><li><p>replica-read-only yes # 作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）</p></li><li><p>repl-diskless-sync no  # 是否使用 socket 方式复制数据。目前 redis 复制提供两种方式， disk 和socket 。如果新的 slave 连上来或者重连的 slave 无法部分同步，就会执行全量同步， master 会生成 rdb 文件。有2种方式：</p><ul><li>disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave 。 socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave 。 disk 方式的时候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件。</li><li>socket 的方式就的一个个 slave 顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式。</li></ul></li><li><p>repl-diskless-sync-delay 5 # 当启用无硬盘备份，服务器等待一段时间后才会通过 socket  向从站传送 RDB 文件，这个等待时间是可配置的。  这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次 RDB 传送。因此服务器等待一段时间以期望更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。</p></li><li><p>repl-disable-tcp-nodelay no # 同步之后是否禁用从站上的TCP_NODELAY 如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。  Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。</p></li></ul></blockquote><h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# SECURITY ###################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> commands.  This might be useful <span class="keyword">in</span> environments <span class="keyword">in</span> <span class="built_in">which</span> you <span class="keyword">do</span> not trust</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> others with access to the host running redis-server.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This should stay commented out for backward compatibility and because most</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> people <span class="keyword">do</span> not need auth (e.g. they run their own servers).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Warning: since Redis is pretty fast an outside user can try up to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 150k passwords per second against a good box. This means that you should</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use a very strong password otherwise it will be very easy to <span class="built_in">break</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># requirepass foobared</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Command renaming.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># It is possible to change the name of dangerous commands in a shared</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> environment. For instance the CONFIG <span class="built_in">command</span> may be renamed into something</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> hard to guess so that it will still be available <span class="keyword">for</span> internal-use tools</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but not available <span class="keyword">for</span> general clients.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Example:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># It is also possible to completely kill a command by renaming it into</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> an empty string:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Please note that changing the name of commands that are logged into the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF file or transmitted to replicas may cause problems.</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>requirepass foobared  # 密码设置</p></li><li><p>rename-command CONFIG “” # 命令重命名，特别是对于一些危险命令为了使得服务器更加安全。（空字符串就是关闭命令）</p></li></ul></blockquote><h2 id="CLIENTS（客户端连接设置）"><a href="#CLIENTS（客户端连接设置）" class="headerlink" title="CLIENTS（客户端连接设置）"></a>CLIENTS（客户端连接设置）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################## CLIENTS ####################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set the max number of connected clients at the same time. By default</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this <span class="built_in">limit</span> is <span class="built_in">set</span> to 10000 clients, however <span class="keyword">if</span> the Redis server is not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> able to configure the process file <span class="built_in">limit</span> to allow <span class="keyword">for</span> the specified <span class="built_in">limit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the max number of allowed clients is <span class="built_in">set</span> to the current file <span class="built_in">limit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> minus 32 (as Redis reserves a few file descriptors <span class="keyword">for</span> internal uses).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Once the limit is reached Redis will close all the new connections sending</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> an error <span class="string">&#x27;max number of clients reached&#x27;</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxclients 10000</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>maxclients 10000  # 设置客户端最大并发连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件。  描述符数 -32 （ redis server 自身会使用一些），如果设置  maxclients 为 0 。表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回max number of clients reached 错误信息</li></ul></blockquote><h2 id="MEMORY-MANAGEMENT-（内存管理）"><a href="#MEMORY-MANAGEMENT-（内存管理）" class="headerlink" title="MEMORY MANAGEMENT （内存管理）"></a>MEMORY MANAGEMENT （内存管理）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################# MEMORY MANAGEMENT ################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set a memory usage <span class="built_in">limit</span> to the specified amount of bytes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> When the memory <span class="built_in">limit</span> is reached Redis will try to remove keys</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> according to the eviction policy selected (see maxmemory-policy).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> to <span class="string">&#x27;noeviction&#x27;</span>, Redis will start to reply with errors to commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that would use more memory, like SET, LPUSH, and so on, and will <span class="built_in">continue</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to reply to read-only commands like GET.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> a hard memory <span class="built_in">limit</span> <span class="keyword">for</span> an instance (using the <span class="string">&#x27;noeviction&#x27;</span> policy).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the size of the output buffers needed to feed the replicas are subtracted</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> from the used memory count, so that network problems / resyncs will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> not trigger a loop <span class="built_in">where</span> keys are evicted, and <span class="keyword">in</span> turn the output</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> buffer of replicas is full with DELs of keys evicted triggering the deletion</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of more keys, and so forth until the database is completely emptied.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># In short... if you have replicas attached it is suggested that you set a lower</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">limit</span> <span class="keyword">for</span> maxmemory so that there is some free RAM on the system <span class="keyword">for</span> replica</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> output buffers (but this is not needed <span class="keyword">if</span> the policy is <span class="string">&#x27;noeviction&#x27;</span>).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory &lt;bytes&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is reached. You can select among five behaviors:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-lru -&gt; Evict any key using approximated LRU.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire <span class="built_in">set</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-lfu -&gt; Evict any key using approximated LFU.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-random -&gt; Remove a random key among the ones with an expire <span class="built_in">set</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-random -&gt; Remove a random key, any key.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> noeviction -&gt; Don<span class="string">&#x27;t evict anything, just return an error on write operations.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># LRU means Least Recently Used</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LFU means Least Frequently Used</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> randomized algorithms.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note: with any of the above policies, Redis will return an error on write</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       operations, when there are no suitable keys <span class="keyword">for</span> eviction.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#       At the date of writing these commands are: set setnx setex append</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       getset mset msetnx <span class="built_in">exec</span> sort</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default is:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory-policy noeviction</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> algorithms (<span class="keyword">in</span> order to save memory), so you can tune it <span class="keyword">for</span> speed or</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> accuracy. For default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> used less recently, you can change the sample size using the following</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> configuration directive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default of 5 produces good enough results. 10 Approximates very closely</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="literal">true</span> LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># maxmemory-samples 5</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Starting from Redis 5, by default a replica will ignore its maxmemory setting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (unless it is promoted to master after a failover or manually). It means</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that the eviction of keys will be just handled by the master, sending the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DEL commands to the replica as keys evict <span class="keyword">in</span> the master side.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This behavior ensures that masters and replicas stay consistent, and is usually</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> what you want, however <span class="keyword">if</span> your replica is writable, or you want the replica to have</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a different memory setting, and you are sure all the writes performed to the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replica are idempotent, <span class="keyword">then</span> you may change this default (but be sure to understand</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> what you are doing).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that since the replica by default does not evict, it may end using more</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> memory than the one <span class="built_in">set</span> via maxmemory (there are certain buffers that may</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be larger on the replica, or data structures may sometimes take more memory and so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> forth). So make sure you monitor your replicas and make sure they have enough</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> memory to never hit a real out-of-memory condition before the master hits</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the configured maxmemory setting.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># replica-ignore-maxmemory yes</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>maxmemory <bytes> # 设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。</bytes></li><li>maxmemory-policy noeviction  # 默认过期策略是：noeviction。有八种过期策略配置：<ul><li><strong>volatile-lru</strong> -&gt; Evict using approximated LRU, only keys with an expire set. # 只对设置了过期时间的 key 进行 lru</li><li><strong>allkeys-lru</strong> -&gt; Evict any key using approximated LRU. # 删除lru算法的key</li><li><strong>volatile-lfu</strong> -&gt; Evict using approximated LFU, only keys with an expire set. # 只对设置了过期时间的 key 进行 lfu</li><li><strong>allkeys-lfu</strong> -&gt; Evict any key using approximated LFU.    # 删除 lfu 算法的 key</li><li><strong>volatile-random</strong> -&gt; Remove a random key having an expire set. # 随机删除即将过期 key</li><li><strong>allkeys-random</strong> -&gt; Remove a random key, any key. # 随机删除</li><li><strong>volatile-ttl</strong> -&gt; Remove the key with the nearest expire time (minor TTL) # 删除即将过期的</li><li><strong>noeviction</strong> -&gt; Don’t evict anything, just return an error on write operations # 永不过期，返回错误</li></ul></li></ul></blockquote><h2 id="LAZY-FREEING（Redis-4-0-新增配置）"><a href="#LAZY-FREEING（Redis-4-0-新增配置）" class="headerlink" title="LAZY FREEING（Redis 4.0 新增配置）"></a>LAZY FREEING（Redis 4.0 新增配置）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################ LAZY FREEING ####################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis has two primitives to delete keys. One is called DEL and is a blocking</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deletion of the object. It means that the server stops processing new commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to reclaim all the memory associated with an object <span class="keyword">in</span> a synchronous</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> way. If the key deleted is associated with a small object, the time needed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to execute the DEL <span class="built_in">command</span> is very small and comparable to most other</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> O(1) or O(log_N) commands <span class="keyword">in</span> Redis. However <span class="keyword">if</span> the key is associated with an</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> aggregated value containing millions of elements, the server can block <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a long time (even seconds) <span class="keyword">in</span> order to complete the operation.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For the above reasons Redis also offers non blocking deletion primitives</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FLUSHDB commands, <span class="keyword">in</span> order to reclaim memory <span class="keyword">in</span> background. Those commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are executed <span class="keyword">in</span> constant time. Another thread will incrementally free the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> object <span class="keyword">in</span> the background as fast as possible.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It<span class="string">&#x27;s up to the design of the application to understand when it is a good</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> idea to use one or the other. However the Redis server sometimes has to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> delete keys or flush the whole database as a side effect of other operations.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specifically Redis deletes objects independently of a user call <span class="keyword">in</span> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> following scenarios:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="keyword">in</span> order to make room <span class="keyword">for</span> new data, without going over the specified</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    memory <span class="built_in">limit</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) Because of expire: when a key with an associated time to live (see the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    EXPIRE <span class="built_in">command</span>) must be deleted from memory.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) Because of a side effect of a <span class="built_in">command</span> that stores data on a key that may</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    already exist. For example the RENAME <span class="built_in">command</span> may delete the old key</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    content when it is replaced with another one. Similarly SUNIONSTORE</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    or SORT with STORE option may delete existing keys. The SET <span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    itself removes any old content of the specified key <span class="keyword">in</span> order to replace</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    it with the specified string.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4) During replication, when a replica performs a full resynchronization with</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    its master, the content of the whole database is removed <span class="keyword">in</span> order to</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load the RDB file just transferred.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># In all the above cases the default is to delete objects in a blocking way,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> like <span class="keyword">if</span> DEL was called. However you can configure each <span class="keyword">case</span> specifically</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to instead release memory <span class="keyword">in</span> a non-blocking way like <span class="keyword">if</span> UNLINK</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> was called, using the following configuration directives:</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br></pre></td></tr></table></figure><blockquote><p><strong>以非阻塞方式释放内存，使用以下配置指令调用</strong></p><ul><li>lazyfree-lazy-eviction no    # 当内存达到上限，分配失败后，是否异步驱逐key</li><li>lazyfree-lazy-expire no    # 是否异步进行 key 过期事件的处理</li><li>lazyfree-lazy-server-del no    # del 命令是否异步执行删除操作，类似unlink</li><li>replica-lazy-flush no    # replica client做全同步的时候，是否异步flush本地db</li></ul></blockquote><h2 id="APPEND-ONLY-MODE（持久化（AOF））"><a href="#APPEND-ONLY-MODE（持久化（AOF））" class="headerlink" title="APPEND ONLY MODE（持久化（AOF））"></a>APPEND ONLY MODE（持久化（AOF））</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################# APPEND ONLY MODE ###############################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> good enough <span class="keyword">in</span> many applications, but an issue with the Redis process or</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the configured save points).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (see later <span class="keyword">in</span> the config file) Redis can lose just one second of writes <span class="keyword">in</span> a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dramatic event like a server power outage, or a single write <span class="keyword">if</span> something</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> still running correctly.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> with the better durability guarantees.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The name of the append only file (default: <span class="string">&quot;appendonly.aof&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instead of waiting <span class="keyword">for</span> more data <span class="keyword">in</span> the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> data on disk, some other OS will just try to <span class="keyword">do</span> it ASAP.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Redis supports three different modes:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> always: fsync after every write to the append only <span class="built_in">log</span>. Slow, Safest.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> speed and data safety. It<span class="string">&#x27;s up to you to understand if you can relax this to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;no&quot;</span> that will <span class="built_in">let</span> the operating system flush the output buffer when</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it wants, <span class="keyword">for</span> better performances (but <span class="keyword">if</span> you can live with the idea of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> some data loss consider the default persistence mode that<span class="string">&#x27;s snapshotting),</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or on the contrary, use <span class="string">&quot;always&quot;</span> that<span class="string">&#x27;s very slow but a bit safer than</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># More details please check the following article:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When the AOF fsync policy is <span class="built_in">set</span> to always or everysec, and a background</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> saving process (a background save or AOF <span class="built_in">log</span> background rewriting) is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> performing a lot of I/O against the disk, <span class="keyword">in</span> some Linux configurations</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis may block too long on the fsync() call. Note that there is no fix <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this currently, as even performing fsync <span class="keyword">in</span> a different thread will block</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> our synchronous write(2) call.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># In order to mitigate this problem it&#x27;s possible to use the following option</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that will prevent fsync() from being called <span class="keyword">in</span> the main process <span class="keyword">while</span> a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BGSAVE or BGREWRITEAOF is <span class="keyword">in</span> progress.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the same as <span class="string">&quot;appendfsync none&quot;</span>. In practical terms, this means that it is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> possible to lose up to 30 seconds of <span class="built_in">log</span> <span class="keyword">in</span> the worst scenario (with the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> default Linux settings).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;no&quot;</span> that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis is able to automatically rewrite the <span class="built_in">log</span> file implicitly calling</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BGREWRITEAOF when the AOF <span class="built_in">log</span> size grows by the specified percentage.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> latest rewrite (<span class="keyword">if</span> no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the AOF at startup is used).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This base size is compared to the current size. If the current size is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you need to specify a minimal size <span class="keyword">for</span> the AOF file to be rewritten, this</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is useful to avoid rewriting the AOF file even <span class="keyword">if</span> the percentage increase</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is reached but it is still pretty small.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> startup process, when the AOF data gets loaded back into memory.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This may happen when the system <span class="built_in">where</span> Redis is running</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> data=ordered option (however this can<span class="string">&#x27;t happen when Redis itself</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Redis can either exit with an error when this happens, or load as much</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> data as possible (the default now) and start <span class="keyword">if</span> the AOF file is found</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the Redis server starts emitting a <span class="built_in">log</span> to inform the user of the event.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Otherwise <span class="keyword">if</span> the option is <span class="built_in">set</span> to no, the server aborts with an error</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and refuses to start. When the option is <span class="built_in">set</span> to no, the user requires</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to fix the AOF file using the <span class="string">&quot;redis-check-aof&quot;</span> utility before to restart</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the server.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that if the AOF file will be found to be corrupted in the middle</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the server will still <span class="built_in">exit</span> with an error. This option only applies when</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis will try to <span class="built_in">read</span> more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will be found.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When rewriting the AOF file, Redis is able to use an RDB preamble <span class="keyword">in</span> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF file <span class="keyword">for</span> faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   [RDB file][AOF tail]</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> string and loads the prefixed RDB file, and continues loading the AOF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tail.</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><blockquote><ul><li>appendonly no    # 默认不开启 AOF </li><li>appendfilename “appendonly.aof”    # 默认文件名</li><li>appendfsync always    # 持久化策略，默认always</li><li>appendfsync always    # 每次修改进行同步</li><li>appendfsync everysec    # 每秒执行一次同步</li><li>appendfsync no    # 不进行同步， 由操作系统进行同步，速度最快</li><li>no-appendfsync-on-rewrite no # 当主进程执行写 AOF 文件的时候不进行 appendfsync 操作。<strong>使用推荐：无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no</strong>。</li><li>auto-aof-rewrite-percentage 100 # 本次aof文件超过上次aof文件该值的百分比时，才会触发rewrite 。</li><li>auto-aof-rewrite-min-size 64mb # 设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</li><li>aof-load-truncated yes # redis在恢复时，会忽略最后一条可能存在问题的指令。默认值yes。即在aof写入时，可能存在指令写错的问题(突然断电，写了一半)，这种情况下，yes会log并继续，而no会直接恢复失败。</li><li>aof-use-rdb-preamble yes # 当重写AOF文件时，Redis能够使用RDB的前导，AOF文件可以更快地重写和恢复。当这个选项被打开时，重写的AOF文件由两个不同的节组成:(RDB文件)(AOF尾巴)</li></ul></blockquote><h2 id="LUA-SCRIPTING"><a href="#LUA-SCRIPTING" class="headerlink" title="LUA SCRIPTING"></a>LUA SCRIPTING</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### LUA SCRIPTING  ###############################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Max execution time of a Lua script <span class="keyword">in</span> milliseconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If the maximum execution time is reached Redis will log that a script is</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> still <span class="keyword">in</span> execution after the maximum allowed time and will start to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> reply to queries with an error.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When a long running script exceeds the maximum execution time only the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> used to stop a script that did not yet called write commands. The second</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is the only way to shut down the server <span class="keyword">in</span> the <span class="keyword">case</span> a write <span class="built_in">command</span> was</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> already issued by the script but the user doesn<span class="string">&#x27;t want to wait for the natural</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> termination of the script.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span></span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>lua-time-limit 5000 # 一个lua脚本执行的最大时间，单位为ms。</li></ul></blockquote><h2 id="REDIS-CLUSTER（redis-集群）"><a href="#REDIS-CLUSTER（redis-集群）" class="headerlink" title="REDIS CLUSTER（redis 集群）"></a>REDIS CLUSTER（redis 集群）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### REDIS CLUSTER  ###############################</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to mark it as <span class="string">&quot;mature&quot;</span> we need to <span class="built_in">wait</span> <span class="keyword">for</span> a non trivial percentage</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of users to deploy it <span class="keyword">in</span> production.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> started as cluster nodes can. In order to start a Redis instance as a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster node <span class="built_in">enable</span> the cluster support uncommenting the following:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-enabled yes</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Every cluster node has a cluster configuration file. This file is not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> intended to be edited by hand. It is created and updated by Redis nodes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Every Redis Cluster node requires a different cluster configuration file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Make sure that instances running <span class="keyword">in</span> the same system <span class="keyword">do</span> not have</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> overlapping cluster configuration file names.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-config-file nodes-6379.conf</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Cluster node timeout is the amount of milliseconds a node must be unreachable</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> it to be considered <span class="keyword">in</span> failure state.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Most other internal time limits are multiple of the node timeout.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-node-timeout 15000</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> A replica of a failing master will avoid to start a failover <span class="keyword">if</span> its data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> looks too old.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># There is no simple way for a replica to actually have an exact measure of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> its <span class="string">&quot;data age&quot;</span>, so the following two checks are performed:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1) If there are multiple replicas able to failover, they exchange messages</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="keyword">in</span> order to try to give an advantage to the replica with the best</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    replication offset (more data from the master processed).</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    Replicas will try to get their rank by offset, and apply to the start</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    of the failover a delay proportional to their rank.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 2) Every single replica computes the time of the last interaction with</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    its master. This can be the last ping or <span class="built_in">command</span> received (<span class="keyword">if</span> the master</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    is still <span class="keyword">in</span> the <span class="string">&quot;connected&quot;</span> state), or the time that elapsed since the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    disconnection with the master (<span class="keyword">if</span> the replication link is currently down).</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    If the last interaction is too old, the replica will not try to failover</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    at all.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the failover <span class="keyword">if</span>, since the last interaction with the master, the time</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elapsed is greater than:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replica will not try to failover <span class="keyword">if</span> it was not able to talk with the master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> longer than 310 seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A large replica-validity-factor may allow replicas with too old data to failover</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a master, <span class="keyword">while</span> a too small value may prevent the cluster from being able to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elect a replica at all.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For maximum availability, it is possible to set the replica-validity-factor</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to a value of 0, <span class="built_in">which</span> means, that replicas will always try to failover the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master regardless of the last time they interacted with the master.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (However they<span class="string">&#x27;ll always try to apply a delay proportional to their</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offset rank).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Zero is the only value able to guarantee that when all the partitions heal</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the cluster will always be able to <span class="built_in">continue</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-replica-validity-factor 10</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Cluster replicas are able to migrate to orphaned masters, that are masters</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that are left without working replicas. This improves the cluster ability</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to resist to failures as otherwise an orphaned master can<span class="string">&#x27;t be failed over</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> <span class="keyword">case</span> of failure <span class="keyword">if</span> it has no working replicas.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Replicas migrate to orphaned masters only if there are still at least a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> given number of other working replicas <span class="keyword">for</span> their old master. This number</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is the <span class="string">&quot;migration barrier&quot;</span>. A migration barrier of 1 means that a replica</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will migrate only <span class="keyword">if</span> there is at least 1 other working replica <span class="keyword">for</span> its master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and so forth. It usually reflects the number of replicas you want <span class="keyword">for</span> every</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master <span class="keyword">in</span> your cluster.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Default is 1 (replicas migrate only if their masters remain with at least</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> one replica). To <span class="built_in">disable</span> migration just <span class="built_in">set</span> it to a very large value.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> A value of 0 can be <span class="built_in">set</span> but is useful only <span class="keyword">for</span> debugging and dangerous</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> production.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-migration-barrier 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis Cluster nodes stop accepting queries <span class="keyword">if</span> they detect there</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is at least an <span class="built_in">hash</span> slot uncovered (no available node is serving it).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This way <span class="keyword">if</span> the cluster is partially down (<span class="keyword">for</span> example a range of <span class="built_in">hash</span> slots</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are no longer covered) all the cluster becomes, eventually, unavailable.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It automatically returns available as soon as all the slots are covered again.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># However sometimes you want the subset of the cluster which is working,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to <span class="built_in">continue</span> to accept queries <span class="keyword">for</span> the part of the key space that is still</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> covered. In order to <span class="keyword">do</span> so, just <span class="built_in">set</span> the cluster-require-full-coverage</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> option to no.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-require-full-coverage yes</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This option, when <span class="built_in">set</span> to yes, prevents replicas from trying to failover its</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> master during master failures. However the master can still perform a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> manual failover, <span class="keyword">if</span> forced to <span class="keyword">do</span> so.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># This is useful in different scenarios, especially in the case of multiple</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> data center operations, <span class="built_in">where</span> we want one side to never be promoted <span class="keyword">if</span> not</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the <span class="keyword">case</span> of a total DC failure.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-replica-no-failover no</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> In order to setup your cluster make sure to <span class="built_in">read</span> the documentation</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> available at http://redis.io web site.</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>cluster-enabled yes # 集群开关，默认是不开启集群模式（默认被注释掉）。</p></li><li><p>cluster-config-file nodes-6379.conf # 每个集群节点应该有自己的配置文件，这个文件是不应该手动修改的，它只能被Redis节点创建且更新，每个Redis集群节点需要不同的集群配置文件</p></li><li><p>cluster-node-timeout 15000 # 集群中节点互连（发送ping命令）超时的阀值，集群节点超时毫秒数。</p></li><li><p>cluster-replica-validity-factor 10 #  在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</p></li><li><p>cluster-migration-barrier 1 # 当一个Master拥有多少个好的Slave时就要割让一个Slave出来。例如设置为2，表示当一个Master拥有2个可用的Slave时，它的一个Slave会尝试迁移。</p></li><li><p>cluster-require-full-coverage yes # 默认情况下，集群全部的 slot 有节点负责，集群状态才为ok，才能提供服务。  设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</p></li><li><p>cluster-replica-no-failover no # </p></li></ul></blockquote><h2 id="CLUSTER-DOCKER-NAT-support"><a href="#CLUSTER-DOCKER-NAT-support" class="headerlink" title="CLUSTER DOCKER/NAT support"></a>CLUSTER DOCKER/NAT support</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In certain deployments, Redis Cluster nodes address discovery fails, because</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> addresses are NAT-ted or because ports are forwarded (the typical <span class="keyword">case</span> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Docker and other containers).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># In order to make Redis Cluster working in such environments, a static</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> configuration <span class="built_in">where</span> each node knows its public address is needed. The</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> following two options are used <span class="keyword">for</span> this scope, and are:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># * cluster-announce-ip</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * cluster-announce-port</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * cluster-announce-bus-port</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Each instruct the node about its address, client port, and cluster message</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bus port. The information is <span class="keyword">then</span> published <span class="keyword">in</span> the header of the bus packets</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> so that other nodes will be able to correctly map the address of the node</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> publishing the information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If the above options are not used, the normal Redis Cluster auto-detection</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> will be used instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Note that when remapped, the bus port may not be at the fixed offset of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> clients port + 10000, so you can specify any port and bus-port depending</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> on how they get remapped. If the bus-port is not <span class="built_in">set</span>, a fixed offset of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10000 will be used as usually.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Example:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># cluster-announce-ip 10.1.1.5</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-announce-port 6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster-announce-bus-port 6380</span></span><br></pre></td></tr></table></figure><blockquote><p>在一些特定的部署场景下，redis cluster 节点地址自动发现会失败，因为地址被NAT了，或者端口 被转发了(Docker容器中)。 为了让redis cluster在这种环境下正常工作，需要静态配置地址和端口，具体配置如下：</p><ul><li>cluster-announce-ip 10.10.10.10</li><li>cluster-announce-port 6379</li><li>cluster-announce-bus-port 6380  </li></ul><p>如果配置文件中没有上述配置项，那么rediscluster会使用标准的自动发现机制。</p></blockquote><h2 id="SLOW-LOG"><a href="#SLOW-LOG" class="headerlink" title="SLOW LOG"></a>SLOW LOG</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# SLOW LOG ###################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The Redis Slow Log is a system to <span class="built_in">log</span> queries that exceeded a specified</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but just the time needed to actually execute the <span class="built_in">command</span> (this is the only</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> stage of <span class="built_in">command</span> execution <span class="built_in">where</span> the thread is blocked and can not serve</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> other requests <span class="keyword">in</span> the meantime).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> what is the execution time, <span class="keyword">in</span> microseconds, to exceed <span class="keyword">in</span> order <span class="keyword">for</span> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">command</span> to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slow <span class="built_in">log</span>. When a new <span class="built_in">command</span> is logged the oldest one is removed from the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> queue of logged commands.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following time is expressed <span class="keyword">in</span> microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to one second. Note that a negative number disables the slow <span class="built_in">log</span>, <span class="keyword">while</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a value of zero forces the logging of every <span class="built_in">command</span>.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> There is no <span class="built_in">limit</span> to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can reclaim memory used by the slow <span class="built_in">log</span> with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure><blockquote><ul><li>slowlog-log-slower-than 10000 # 慢日志执行时间，单位是微秒，1000000等于1秒</li><li>slowlog-max-len 128 # slow长度，如果命令大于128，老的那个就没了，这个值没有限制，如果设置太大会占内存 可以通过 SLOWLOG RESET 命令来重置这个队列</li></ul></blockquote><h2 id="LATENCY-MONITOR"><a href="#LATENCY-MONITOR" class="headerlink" title="LATENCY MONITOR"></a>LATENCY MONITOR</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### LATENCY MONITOR ##############################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The Redis latency monitoring subsystem samples different operations</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> at runtime <span class="keyword">in</span> order to collect data related to possible sources of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> latency of a Redis instance.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Via the LATENCY command this information is available to the user that can</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> graphs and obtain reports.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The system only logs operations that were performed in a time equal or</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> greater than the amount of milliseconds specified via the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> latency-monitor-threshold configuration directive. When its value is <span class="built_in">set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to zero, the latency monitor is turned off.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default latency monitoring is disabled since it is mostly not needed</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> you don<span class="string">&#x27;t have latency issues, and collecting data has a performance</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> impact, that <span class="keyword">while</span> very small, can be measured under big load. Latency</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> monitoring can easily be enabled at runtime using the <span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot;</span> <span class="keyword">if</span> needed.</span></span><br><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure><blockquote><ul><li>latency-monitor-threshold 0 # redis 延迟监控系统会在运行时抽样一部分命令来帮助用户分析 redis 卡顿的原因。 通过 LATENCY 命令可以打印一些视图和报告。 redis 只会记录那些大于设定毫秒数的命令。 如果要关闭这个功能，就将 latency-monitor-threshold 设置为 0。 默认情况下 monitor 是关闭的，没有延迟问题不要一直开着 monitor ，因为开这个功能可能会对性能有很大影响。 在运行时也可以开这个功能，执行这个命令即可： CONFIG SET latency-monitor-threshold <milliseconds></milliseconds></li></ul></blockquote><h2 id="EVENT-NOTIFICATION（TODO-事件通知）"><a href="#EVENT-NOTIFICATION（TODO-事件通知）" class="headerlink" title="EVENT NOTIFICATION（TODO 事件通知）"></a>EVENT NOTIFICATION（TODO 事件通知）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################ EVENT NOTIFICATION ##############################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis can notify Pub/Sub clients about events happening <span class="keyword">in</span> the key space.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This feature is documented at http://redis.io/topics/notifications</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># For instance if keyspace events notification is enabled, and a client</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> performs a DEL operation on key <span class="string">&quot;foo&quot;</span> stored <span class="keyword">in</span> the Database 0, two</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># It is possible to select the events that Redis will notify among a set</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of classes. Every class is identified by a single character:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  $     String commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  l     List commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  s     Set commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  h     Hash commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  z     Sorted <span class="built_in">set</span> commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  e     Evicted events (events generated when a key is evicted <span class="keyword">for</span> maxmemory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  A     Alias <span class="keyword">for</span> g<span class="variable">$lshzxe</span>, so that the <span class="string">&quot;AKE&quot;</span> string means all the events.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  of zero or multiple characters. The empty string means that notifications</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  are disabled.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  Example: to enable list and generic events, from the point of view of the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">           event name, use:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  notify-keyspace-events Elg</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">             name __keyevent@0__:expired use:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  notify-keyspace-events Ex</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  By default all notifications are disabled because most users don&#x27;t need</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  this feature and the feature has some overhead. Note that <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  specify at least one of K or E, no events will be delivered.</span></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="ADVANCED-CONFIG-（TODO-高级设置）"><a href="#ADVANCED-CONFIG-（TODO-高级设置）" class="headerlink" title="ADVANCED CONFIG （TODO 高级设置）"></a>ADVANCED CONFIG （TODO 高级设置）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################## ADVANCED CONFIG ###############################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Hashes are encoded using a memory efficient data structure when they have a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> small number of entries, and the biggest entry does not exceed a given</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> threshold. These thresholds can be configured using the following directives.</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lists are also encoded <span class="keyword">in</span> a special way to save a lot of space.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of entries allowed per internal list node can be specified</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as a fixed maximum size or a maximum number of elements.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For a fixed maximum size, use -5 through -1, meaning:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -5: max size: 64 Kb  &lt;-- not recommended <span class="keyword">for</span> normal workloads</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -4: max size: 32 Kb  &lt;-- not recommended</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -3: max size: 16 Kb  &lt;-- probably not recommended</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Positive numbers mean store up to _exactly_ that number of elements</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> per list node.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but <span class="keyword">if</span> your use <span class="keyword">case</span> is unique, adjust the settings as necessary.</span></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lists may also be compressed.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Compress depth is the number of quicklist ziplist nodes from *each* side of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the list to *exclude* from compression.  The head and tail of the list</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> are always uncompressed <span class="keyword">for</span> fast push/pop operations.  Settings are:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0: <span class="built_in">disable</span> all list compression</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1: depth 1 means <span class="string">&quot;don&#x27;t start compressing until after 1 node into the list,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    going from either the head or tail<span class="string">&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    [head], [tail] will always be uncompressed; inner nodes will compress.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    2 here means: don<span class="string">&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    but compress all nodes between them.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> etc.</span></span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Sets have a special encoding <span class="keyword">in</span> just one <span class="keyword">case</span>: when a <span class="built_in">set</span> is composed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of just strings that happen to be integers <span class="keyword">in</span> radix 10 <span class="keyword">in</span> the range</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of 64 bit signed integers.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The following configuration setting sets the <span class="built_in">limit</span> <span class="keyword">in</span> the size of the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> <span class="keyword">in</span> order to use this special memory saving encoding.</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Similarly to hashes and lists, sorted sets are also specially encoded <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> order to save a lot of space. This encoding is only used when the length and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elements of a sorted <span class="built_in">set</span> are below the following limits:</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HyperLogLog sparse representation bytes <span class="built_in">limit</span>. The <span class="built_in">limit</span> includes the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 16 bytes header. When an HyperLogLog using the sparse representation crosses</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this <span class="built_in">limit</span>, it is converted into the dense representation.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A value greater than 16000 is totally useless, since at that point the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dense representation is more memory efficient.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The suggested value is ~ 3000 in order to have the benefits of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the space efficient encoding without slowing down too much PFADD,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> is O(N) with the sparse encoding. The value can be raised to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~ 10000 when CPU is not a concern, but space is, and the data <span class="built_in">set</span> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> composed of many HyperLogLogs with cardinality <span class="keyword">in</span> the 0 - 15000 range.</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Streams macro node max size / items. The stream data structure is a radix</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tree of big nodes that encode multiple items inside. Using this configuration</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it is possible to configure how big a single node can be <span class="keyword">in</span> bytes, and the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maximum number of items it may contain before switching to a new node when</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> appending new stream entries. If any of the following settings are <span class="built_in">set</span> to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zero, the <span class="built_in">limit</span> is ignored, so <span class="keyword">for</span> instance it is possible to <span class="built_in">set</span> just a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> max entires <span class="built_in">limit</span> by setting max-bytes to 0 and max-entries to the desired</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> value.</span></span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Active rehashing uses 1 millisecond every 100 milliseconds of CPU time <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> order to <span class="built_in">help</span> rehashing the main Redis <span class="built_in">hash</span> table (the one mapping top-level</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> keys to values). The <span class="built_in">hash</span> table implementation Redis uses (see dict.c)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> performs a lazy rehashing: the more operation you run into a <span class="built_in">hash</span> table</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that is rehashing, the more rehashing <span class="string">&quot;steps&quot;</span> are performed, so <span class="keyword">if</span> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> server is idle the rehashing is never complete and some more memory is used</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> by the <span class="built_in">hash</span> table.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default is to use this millisecond 10 times every second in order to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> actively <span class="built_in">rehash</span> the main dictionaries, freeing memory when possible.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># If unsure:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use <span class="string">&quot;activerehashing no&quot;</span> <span class="keyword">if</span> you have hard latency requirements and it is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> not a good thing <span class="keyword">in</span> your environment that Redis can reply from time to time</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to queries with 2 milliseconds delay.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> want to free memory asap when possible.</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The client output buffer limits can be used to force disconnection of clients</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that are not reading data from the server fast enough <span class="keyword">for</span> some reason (a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> common reason is that a Pub/Sub client can<span class="string">&#x27;t consume messages as fast as the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> publisher can produce them).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The limit can be set differently for the three different classes of clients:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># normal -&gt; normal clients including MONITOR clients</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> replica  -&gt; replica clients</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The syntax of every client-output-buffer-limit directive is the following:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># A client is immediately disconnected once the hard limit is reached, or if</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the soft <span class="built_in">limit</span> is reached and remains reached <span class="keyword">for</span> the specified number of</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> seconds (continuously).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> So <span class="keyword">for</span> instance <span class="keyword">if</span> the hard <span class="built_in">limit</span> is 32 megabytes and the soft <span class="built_in">limit</span> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 16 megabytes / 10 seconds, the client will get disconnected immediately</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> the size of the output buffers reach 32 megabytes, but will also get</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disconnected <span class="keyword">if</span> the client reaches 16 megabytes and continuously overcomes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the <span class="built_in">limit</span> <span class="keyword">for</span> 10 seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default normal clients are not limited because they don&#x27;t receive data</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> without asking (<span class="keyword">in</span> a push way), but just after a request, so only</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> asynchronous clients may create a scenario <span class="built_in">where</span> data is requested faster</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> than it can <span class="built_in">read</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Instead there is a default limit for pubsub and replica clients, since</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> subscribers and replicas receive data <span class="keyword">in</span> a push fashion.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span></span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Client query buffers accumulate new commands. They are limited to a fixed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> amount by default <span class="keyword">in</span> order to avoid that a protocol desynchronization (<span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instance due to a bug <span class="keyword">in</span> the client) will lead to unbound memory usage <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the query buffer. However you can configure it here <span class="keyword">if</span> you have very special</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> needs, such us huge multi/<span class="built_in">exec</span> requests or alike.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># client-query-buffer-limit 1gb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> In the Redis protocol, bulk requests, that are, elements representing single</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> strings, are normally limited ot 512 mb. However you can change this <span class="built_in">limit</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> here.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># proto-max-bulk-len 512mb</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis calls an internal <span class="keyword">function</span> to perform many background tasks, like</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> closing connections of clients <span class="keyword">in</span> timeout, purging expired keys that are</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> never requested, and so forth.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Not all tasks are performed with the same frequency, but Redis checks for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tasks to perform according to the specified <span class="string">&quot;hz&quot;</span> value.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis is idle, but at the same time will make Redis more responsive when</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> there are many keys expiring at the same time, and timeouts may be</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> handled with more precision.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The range is between 1 and 500, however a value over 100 is usually not</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a good idea. Most users should use the default of 10 and raise this up to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 100 only <span class="keyword">in</span> environments <span class="built_in">where</span> very low latency is required.</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Normally it is useful to have an HZ value <span class="built_in">which</span> is proportional to the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> number of clients connected. This is useful <span class="keyword">in</span> order, <span class="keyword">for</span> instance, to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> avoid too many clients are processed <span class="keyword">for</span> each background task invocation</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to avoid latency spikes.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Since the default HZ value by default is conservatively set to 10, Redis</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offers, and enables by default, the ability to use an adaptive HZ value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> will temporary raise when there are many connected clients.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># When dynamic HZ is enabled, the actual configured HZ will be used as</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as a baseline, but multiples of the configured HZ value will be actually</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> used as needed once more clients are connected. In this way an idle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instance will use very little CPU time <span class="keyword">while</span> a busy instance will be</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> more responsive.</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When a child rewrites the AOF file, <span class="keyword">if</span> the following option is enabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> big latency spikes.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When redis saves RDB file, <span class="keyword">if</span> the following option is enabled</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> big latency spikes.</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> how to improve the performances and how the keys LFU change over time, <span class="built_in">which</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is possible to inspect via the OBJECT FREQ <span class="built_in">command</span>.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># There are two tunable parameters in the Redis LFU implementation: the</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> of the old counter, when a key is accessed, the counter is incremented <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this way:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># 1. A random number R between 0 and 1 is extracted.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. The counter is incremented only <span class="keyword">if</span> R &lt; P.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> logarithmic factors:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># <span class="doctag">NOTE:</span> The above table was obtained by running the following commands:</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   redis-benchmark -n 1000000 incr foo</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   redis-cli object freq foo</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to accumulate hits.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The counter decay time is the time, in minutes, that must elapse in order</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> the key counter to be divided by two (or decremented <span class="keyword">if</span> it has a value</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> less &lt;= 10).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> decay the counter every time it happens to be scanned.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># lfu-log-factor 10</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lfu-decay-time 1</span></span><br></pre></td></tr></table></figure><h2 id="ADVANCED-CONFIG（TODO-活跃的碎片整理）"><a href="#ADVANCED-CONFIG（TODO-活跃的碎片整理）" class="headerlink" title="ADVANCED CONFIG（TODO 活跃的碎片整理）"></a>ADVANCED CONFIG（TODO 活跃的碎片整理）</h2>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构概览"><a href="#数据结构概览" class="headerlink" title="数据结构概览"></a>数据结构概览</h1><table><thead><tr><th>类型</th><th>编码</th><th>底层数据结构</th></tr></thead><tbody><tr><td>string</td><td>int</td><td>整数值</td></tr><tr><td>string</td><td>raw</td><td>简单动态字符串</td></tr><tr><td>string</td><td>embstr</td><td>用 embstr 编码的简单动态字符串</td></tr><tr><td>hash</td><td>ziplist</td><td>压缩列表</td></tr><tr><td>hash</td><td>hashtable</td><td>字典</td></tr><tr><td>list</td><td>ziplist</td><td>压缩列表</td></tr><tr><td>list</td><td>linkedlist</td><td>双端列表</td></tr><tr><td>set</td><td>intset</td><td>整数集合</td></tr><tr><td>set</td><td>hashtable</td><td>字典</td></tr><tr><td>zset</td><td>ziplist</td><td>压缩列表</td></tr><tr><td>zset</td><td>skiplist</td><td>跳表和字典</td></tr></tbody></table><h1 id="一：简单动态字符串（SDS）"><a href="#一：简单动态字符串（SDS）" class="headerlink" title="一：简单动态字符串（SDS）"></a>一：简单动态字符串（SDS）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>redis并没有使用C字符串，而是使用了名为简单动态字符串（SDS）的结构，SDS的定义如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf[] 中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 记录字符串长度，大小为4个字节</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf[]中未被使用字节数量，大小为4个字节</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// buf[]: 保存字符串，大小为字符串大小+1，因为buf[]最后一个字节保存&#x27;\0&#x27; </span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">    <span class="comment">// 所以sds的总大小为 = 4 + 4 + size(str) + 1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis-sds.jpg" alt="img"></p><h2 id="SDS的作用"><a href="#SDS的作用" class="headerlink" title="SDS的作用"></a>SDS的作用</h2><blockquote><p>那么 redis 为什么要使用看起来更占空间的 SDS 结构呢？主要有以下几个原因：</p></blockquote><ol><li><strong>O(1)复杂度获得string的长度</strong><ul><li>相比于 C 字符串需要遍历 string 才能获得长度 ( 复杂度 O ( N ) )， SDS 直接查询 len 的数值即可。</li></ul></li><li><strong>防止缓冲区溢出</strong> <ul><li>当修改 C 字符串时，如果没有分配够足够的内存，很容易造成缓冲区溢出。而使用SDS结构，当修改字符串时，会自动检测当前内存是否足够，如果内存足够，则会扩展 SDS 的空间，从而避免了缓冲区溢出。</li></ul></li><li><strong>减少修改字符串带来的频繁的内存分配</strong> <ul><li>每次增长或缩短 C 字符串，都需要重新分配内存，而 redis 经常被用在数据修改频繁的场合，所以 SDS 采用了两种策略从而避免了频繁的内存分配。  <ul><li>① 空间预分配：如上文所述， SDS 会自动分配内存，如果修改后字符串内存占用小于 1MB ，则会分配同样大小的未使用内存空间。（eg len: 20kb free: 10kb→ len: 40kb free 40kb），如果大于 1MB ，则分配 1MB 未使用内存空间。如此一来就可以避免因为字符串增长带来的频繁空间分配。  </li><li>② 惰性删除：当缩短字符串时， SDS 并没有释放掉相应的内存，而是保留下来，用 free 记录未使用的空间，为以后的增长字符串做准备。</li></ul></li></ul></li><li><strong>二进制安全</strong> <ul><li>SDS 会以处理二进制数据的形式存取 buf 中的内容，从而让 SDS 不仅可以保存任意编码的文本信息，还可以保存诸如图片、视频、压缩文件等二进制数据。</li></ul></li></ol><h2 id="SDS的其他机制"><a href="#SDS的其他机制" class="headerlink" title="SDS的其他机制"></a>SDS的其他机制</h2><h3 id="a、空间预分配"><a href="#a、空间预分配" class="headerlink" title="a、空间预分配"></a>a、空间预分配</h3><blockquote><p>空间预分配指的是当我们通过 <code>api</code> 对 <code>sds</code> 进行扩展空间的时候，假如未使用空间不够用，那么程序不仅会为 <code>sds</code> 分配必须要的空间，还会额外分配未使用空间，未使用空间分配大小主要有两种情况：</p></blockquote><ul><li><p>假如扩大长度之后的 <code>len</code> 属性小于等于 <code>1MB</code> （即 1024 * 1024），那么就会同时分配和 <code>len</code> 属性一样大小的未使用空间（<strong>此时 buf 数组已使用空间 = 未使用空间</strong>）。</p></li><li><p>假如扩大长度之后的 <code>len</code> 属性大于 <code>1MB</code>，那么就会分配 <code>1MB</code> 未使用空间大小。</p></li></ul><h3 id="b、惰性空间释放"><a href="#b、惰性空间释放" class="headerlink" title="b、惰性空间释放"></a>b、惰性空间释放</h3><blockquote><p>惰性空间释放指的是当我们需要通过 <code>api</code> 减小 <code>sds</code> 长度的时候，程序并不会立即释放未使用的空间，而只是更新 <code>free</code> 属性的值，这样空间就可以留给下一次使用。而为了防止出现内存溢出的情况，<code>sds</code> 单独提供给了 <code>api</code> 让我们在有需要的时候去真正的释放内存。</p></blockquote><h2 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h2><h3 id="a、二进制安全"><a href="#a、二进制安全" class="headerlink" title="a、二进制安全"></a>a、二进制安全</h3><p>所有的 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据，程序不会对其进行任何限制或者过滤，数据写入时是什么样，读取就是什么样，保证了存储数据时的安全性。</p><h3 id="b、兼容-C-字符串函数"><a href="#b、兼容-C-字符串函数" class="headerlink" title="b、兼容 C 字符串函数"></a>b、兼容 C 字符串函数</h3><p>虽然 SDS API 是二进制安全的，但是 SDS 依然可以复用 String 类型的一些库定义的函数。</p><h3 id="SDS-和-C-语言字符串区别"><a href="#SDS-和-C-语言字符串区别" class="headerlink" title="SDS 和 C 语言字符串区别"></a>SDS 和 C 语言字符串区别</h3><p>下面表格中列举了 <code>Redis</code> 中的 <code>sds</code> 和 <code>C</code> 语言中实现的字符串的区别：</p><table><thead><tr><th>C 字符串</th><th>SDS</th></tr></thead><tbody><tr><td>只能保存文本类不含空字符串 <code>\0</code> 数据</td><td>可以保存文本或者二进制数据，允许包含空字符串 <code>\0</code></td></tr><tr><td>获取字符串长度的复杂度为 <code>O(n)</code></td><td>获取字符串长度的复杂度为 <code>O(1)</code></td></tr><tr><td>操作字符串可能会造成缓冲区溢出</td><td>不会出现缓冲区溢出情况</td></tr><tr><td>修改字符串长度 <code>N</code> 次，<strong>必然需要</strong> <code>N</code>次内存重分配</td><td>修改字符串长度 <code>N</code> 次，<strong>最多需要</strong> <code>N</code> 次内存重分配</td></tr><tr><td>可以使用 <code>C</code> 字符串相关的<strong>所有</strong>函数</td><td>可以使用 <code>C</code> 字符串相关的<strong>部分</strong>函数</td></tr></tbody></table><h1 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist 压缩列表"></a>ziplist 压缩列表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p>压缩列表顾名思义是进行了压缩，每一个节点之间没有指针的指向，而是多个元素相邻，没有缝隙。<strong>所以 ziplist 是 Redis 为了节约内存而开发的</strong>，是由一系列特殊编码的连续内存块组成的顺序型数据结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    int32 zlbytes; <span class="comment">// 整个压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset; <span class="comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength; <span class="comment">// 元素个数</span></span><br><span class="line">    T[] entries; <span class="comment">// 元素内容列表，挨个挨个紧凑存储</span></span><br><span class="line">    int8 zlend; <span class="comment">// 标志压缩列表的结束，值恒为 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端列表（linkedlist）"><a href="#双端列表（linkedlist）" class="headerlink" title="双端列表（linkedlist）"></a>双端列表（linkedlist）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><h3 id="链表节点的定义"><a href="#链表节点的定义" class="headerlink" title="链表节点的定义"></a>链表节点的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值</span></span><br><span class="line">  <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure><p>但是 Redis 为了更好的操作，封装了一个链表结构 <strong>list</strong>. 结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">  &#x2F;&#x2F; 表头结点</span><br><span class="line">  listNode *head;</span><br><span class="line">  &#x2F;&#x2F; 表尾节点</span><br><span class="line">  listNode *tail;</span><br><span class="line">  &#x2F;&#x2F; 链表所包含的节点数量</span><br><span class="line">  unsigned long len;</span><br><span class="line">  &#x2F;&#x2F; 其他函数</span><br><span class="line">  ...</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure><h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p>下图是一个 list 结构，其中包含了三个 listNode.</p><p><img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/16f987a2dbd43141" alt="2020-01-05-14-14-45"></p><h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>从 listNode 的结构我们可以看到，包含了前直接点和后置节点。所以可以很方便的进行正向和反向的遍历。</p><h3 id="无环链表"><a href="#无环链表" class="headerlink" title="无环链表"></a>无环链表</h3><p>表头结点的 prev 指针和表尾结点的 next 指针都只想 null, 所以 Redis 的链表是一个无环链表。</p><h3 id="带有头指针和尾指针"><a href="#带有头指针和尾指针" class="headerlink" title="带有头指针和尾指针"></a>带有头指针和尾指针</h3><p>在 list 结构中，保存了当前链表的表头指针和表尾指针，因此可以快速的从头进行遍历或者从尾部开始遍历。</p><h3 id="带有长度计数器"><a href="#带有长度计数器" class="headerlink" title="带有长度计数器"></a>带有长度计数器</h3><p>list 结构中保存了当前链表长度的长度，因此对链表长度的统计时间复杂度是 O(1).</p><blockquote><p><strong>压缩列表占用内存少，但是是顺序型的数据结构，插入删除元素的操作比较复杂，所以压缩列表适合数据比较小的情况，当数据比较多的时候，双端列表的高效插入删除还是更好的选择</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表是一个比较常用的数据结构，在很多编程语言中都有实现，读者们接触也很多。因此本文没有专门去强调它的实现方法，而是大概介绍了下 Redis 中的链表的一个结构及其主要特性：</p><ol><li>Redis 的链表是双端链表。</li><li>封装了 list 结构，保存了链表的头尾指针以及链表长度。</li><li>Redis 的链表是无环链表。</li></ol><h1 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote><p>把ziplist和普通的双向链表结合起来。每个双链表节点中保存一个 ziplist ，然后每个 ziplist 中存一批 list 中的数据(具体ziplist大小可配置)，这样既可以避免大量链表指针带来的内存消耗，也可以避免 ziplist 更新导致的大量性能损耗，将大的 ziplist <strong>化整为零</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;        <span class="comment">/* 头结点 */</span></span><br><span class="line">    quicklistNode *tail;        <span class="comment">/* 尾结点 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* 在所有的ziplist中的entry总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* quicklist节点总数 */</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* 16位，每个节点的最大容量 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* 16位，quicklist的压缩深度，0表示所有节点都不压缩，否则就表示从两端开始有多少个节点不压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS;  <span class="comment">/*4位，bookmarks数组的大小，bookmarks是一个可选字段，用来quicklist重新分配内存空间时使用，不使用时不占用空间*/</span></span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist</span><br></pre></td></tr></table></figure><h3 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h3><p>quicklistNode 就是双链表的节点封装了，除了前后节点的指针外，这里还包含一些本节点的其他信息。比如是否是 LZF 压缩的节点、 ziplist 相关信，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">/* quicklist节点对应的ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist的字节数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist的item数*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* 数据类型，RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 这个节点以前压缩过吗？ */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* 未使用到的10位 */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><h2 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h2><p><img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4da1cb826f2547f5b655d8e4ad519eda_tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>可以看出 quicklist 其实就是简单的双链表，但这里多出来几个字段，先重点介绍下 compress 。在上图中我用了两种不同颜色的节点，其中绿色是普通的 ziplist 节点，而红色是被压缩后的 ziplist 节点( LZF 节点)，LZF 是种无损压缩算法。 redis 为了节省内存空间，会将 quicklist 的节点用 LZF 压缩后存储，但这里不是全部压缩，可以配置compress的值，<strong>compress为0表示所有节点都不压缩，否则就表示从两端开始有多少个节点不压缩</strong>，像我上图图示中，compress就是1，表示从两端开始，有1个节点不做LZF压缩。**compress默认是0(不压缩)，具体可以根据你们业务实际使用场景去配置。 **</p><blockquote><p>为什么不全部节点都压缩，而是流出compress这个可配置的口子呢？其实从统计而已，list两端的数据变更最为频繁，像lpush,rpush,lpop,rpop等命令都是在两端操作，如果频繁压缩或解压缩会代码不必要的性能损耗。从这里可以看出  <strong>redis其实并不是一味追求性能，它也在努力减少存储占用、在存储和性能之间做trade-off</strong>。</p></blockquote><p>这里还有个fill字段，它的含义是每个quicknode的节点<em>最大容量</em>，不同的数值有不同的含义，默认是-2，当然也可以配置为其他数值，具体数值含义如下：</p><ul><li>-1: 每个quicklistNode节点的ziplist所占字节数不能超过4kb。（建议配置）</li><li>-2: 每个quicklistNode节点的ziplist所占字节数不能超过8kb。（默认配置&amp;建议配置）</li><li>-3: 每个quicklistNode节点的ziplist所占字节数不能超过16kb。</li><li>-4: 每个quicklistNode节点的ziplist所占字节数不能超过32kb。</li><li>-5: 每个quicklistNode节点的ziplist所占字节数不能超过64kb。</li><li>任意正数: 表示：ziplist结构所最多包含的entry个数，最大为215215。</li></ul><h1 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h1><p>略</p><h1 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h1><h2 id="skiplist理解"><a href="#skiplist理解" class="headerlink" title="skiplist理解"></a>skiplist理解</h2><p>究竟何为跳表？我们先来考虑下这个场景，假设你有个有序链表，你想看某个特定的值是否出现在这个链表中，那你是不是只能遍历一次链表才能知道，时间复杂度为O(n)。<br> <img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/a9a0ea5bbe78419bb82c4fcd94e97f23_tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>可能有人会问为什么不直接用连续存储，我们还能用二分查找，用链表是想继续保留它修改时间复杂度低的优势。那我们如何优化单次查找的速度？其实思路很像是二分查找，但单链表无法随机访问的特性限制了我们，但二分逐渐缩小范围的思路启发了我们，<strong>能不能想什么办法逐渐缩小范围？</strong></p><p>我是不是可以在原链表之上新建一个链表，新链表是原链表每隔一个节点取一个。假设原链表为L0，新链表为L1，L1中的元素是L0中的第1、3、5、7、9……个节点，然后再建立L1和L0中各个节点的指针。这样L1就可以将L0中的范围缩小一半，同理对L1再建立新链表L2……，更高level的链表划分更大的区间，确定值域的大区间后，逐级向下缩小范围，如下图。<br> <img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/54dd47ea29464270851b947201205c69_tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"> 假设我们想找13，我们可以在L3中确定2-14的范围，在L2中确定8-14的范围，在L1中确定10-14的范围，在L0中找到13，整体寻找路径如下图红色路径，是不是比直接在L0中找13的绿色路径所经过的节点数少一些。<br> <img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/034f82a2234c4bf895ece591ed304c2d_tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>其实这种实现很像二分查找，只不过事先将二分查找的中间点存储下来了，用额外的空间换取了时间，很容易想到其时间复杂度和二分查找一致，都是O(logn)。<br> 小伙子很牛X吗，发明了这么牛逼的数据结构，能把有序链表的查找时间复杂度从O(n)降低到O(logn)，但是我有个问题，<strong>如果链表中插入或者删除了某个节点怎么办？</strong>，是不是每次数据变动都要重建整个数据结构？</p><p>其实不必，我们不需要严格保证两两层级之间的二分之一的关系，<strong>只需要概率上为二分之一</strong>就行，删除一个节点好说，直接把某个层级中对应的改节点删掉，插入节点时，新节点以指数递减的概率往上层链表插入即可。 比如L0中100%插入，L1中以1/2的概率插入，如果L1中插入了，L2中又以1/2的概率插入……  注意，<strong>只要高Level中有的节点，低Level中一定有，但高Level链表中出现的概率会随着level指数递减</strong>，最终跳表可能会长这个样子。<br> <img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9359b5da43e746bb8e80af03b931e301_tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"> 我们就这样重新发明了skiplist。</p><h2 id="Redis中的跳表"><a href="#Redis中的跳表" class="headerlink" title="Redis中的跳表"></a>Redis中的跳表</h2><p>Redis为了提供了有序集合(sorted set)相关的操作(比如zadd、zrange)，其底层实现就是skiplist。我们接下来看下redis是如何实现skiplist的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头尾指针 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;   <span class="comment">// skiplist的长度  </span></span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">// 最高多少级链表 </span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们先来看下redis中zskiplist的定义，没啥内容，就头尾指针、长度和级数，重点还是在zskiplistNode中。zskiplistNode中是有前向指针的，所以Level[0]其实是个双向链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;   <span class="comment">// 节点存储的具体值 </span></span><br><span class="line">    <span class="keyword">double</span> score;   <span class="comment">// 节点对应的分值 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 每一层的后向指针 </span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;  <span class="comment">// 到下一个节点的跨度 </span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>redis中的skiplist实现稍微和我们上文中讲的不大一样，它并不是简单的多级链表的形式，而是直接在zskiplistNode中的level[]将不同level的节点的关联关系组织起来，zskiplist的结构可视化如下。<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/096b97bbb6a7482ab0257724d31df4d6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="Redis为什么使用skiplist而不是平衡树"><a href="#Redis为什么使用skiplist而不是平衡树" class="headerlink" title="Redis为什么使用skiplist而不是平衡树"></a>Redis为什么使用skiplist而不是平衡树</h2><ul><li>skiplist并不是特别耗内存，只需要调整下节点到更高level的概率，就可以做到比B树更少的内存消耗。</li><li>sorted set可能会面对大量的zrange和zreverange操作，跳表作为单链表遍历的实现性能不亚于其他的平衡树。</li><li>实现和调试起来比较简单。 例如，实现O(log(N))时间复杂度的ZRANK只需要简单修改下代码即可。</li></ul><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/102120122">https://zhuanlan.zhihu.com/p/102120122</a></p><p><a href="https://juejin.cn/post/6844903829914271752">https://juejin.cn/post/6844903829914271752</a></p><p><a href="https://juejin.cn/post/6844903838571298824">https://juejin.cn/post/6844903838571298824</a></p><p><a href="https://juejin.cn/post/6844904008591605767">https://juejin.cn/post/6844904008591605767</a></p><p><a href="https://juejin.cn/post/6916347941129027592">https://juejin.cn/post/6916347941129027592</a></p><p><a href="https://juejin.cn/post/6844903863145742350">https://juejin.cn/post/6844903863145742350</a></p><p><a href="https://juejin.cn/post/6844904046369701896">https://juejin.cn/post/6844904046369701896</a></p><p><a href="https://juejin.cn/post/6921608335120662541">https://juejin.cn/post/6921608335120662541</a></p><p><a href="https://juejin.cn/post/6921608018463293447">https://juejin.cn/post/6921608018463293447</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="linux下-redis安装"><a href="#linux下-redis安装" class="headerlink" title="linux下 redis安装"></a>linux下 redis安装</h1><p>参考： <a href="https://www.redis.net.cn/download/">https://www.redis.net.cn/download/</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# </span><br><span class="line">[root@localhost redis]# wget http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br><span class="line">--2021-01-29 02:56:57--  http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 45.60.125.1</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|45.60.125.1|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1966337 (1.9M) [application/octet-stream]</span><br><span class="line">Saving to: ‘redis-5.0.4.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[=========================================================================================================================================&gt;] 1,966,337   55.7KB/s   <span class="keyword">in</span> 39s</span>    </span><br><span class="line"></span><br><span class="line">2021-01-29 02:57:36 (49.2 KB/s) - ‘redis-5.0.4.tar.gz’ saved [1966337/1966337]</span><br><span class="line"></span><br><span class="line">[root@localhost redis]# </span><br><span class="line">[root@localhost redis]# ls</span><br><span class="line">redis-5.0.4.tar.gz</span><br><span class="line">[root@localhost redis]#</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# tar xzf redis-5.0.4.tar.gz -C /usr/redis/</span><br><span class="line">[root@localhost redis]# cd /usr/redis/</span><br><span class="line">[root@localhost redis]# ls</span><br><span class="line">redis-5.0.4</span><br><span class="line">[root@localhost redis]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# yum install gcc-c++</span><br><span class="line">[root@localhost redis-5.0.4]# make</span><br><span class="line">    ............</span><br><span class="line">    INSTALL redis-sentinel</span><br><span class="line">    CC redis-cli.o</span><br><span class="line">    LINK redis-cli</span><br><span class="line">    CC redis-benchmark.o</span><br><span class="line">    LINK redis-benchmark</span><br><span class="line">    INSTALL redis-check-rdb</span><br><span class="line">    INSTALL redis-check-aof</span><br><span class="line"></span><br><span class="line">Hint: It&#x27;s a good idea to run &#x27;make test&#x27; ;)</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory `/usr/redis/redis-5.0.4/src&#x27;</span><br><span class="line">[root@localhost redis-5.0.4]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="启动服务（默认）"><a href="#启动服务（默认）" class="headerlink" title="启动服务（默认）"></a>启动服务（默认）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# src/redis-server </span><br><span class="line">2189:C 30 Jan 2021 01:49:16.869 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">2189:C 30 Jan 2021 01:49:16.869 # Redis version=5.0.4, bits=64, commit=00000000, modified=0, pid=2189, just started</span><br><span class="line">2189:C 30 Jan 2021 01:49:16.869 # Warning: no config file specified, using the default config. In order to specify a config file use src/redis-server /path/to/redis.conf</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.871 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 5.0.4 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 2189</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                               </span><br><span class="line"></span><br><span class="line">2189:M 30 Jan 2021 01:49:16.873 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.874 # Server initialized</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.874 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.874 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.903 * DB loaded from disk: 0.029 seconds</span><br><span class="line">2189:M 30 Jan 2021 01:49:16.903 * Ready to accept connections</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# src&#x2F;redis-cli </span><br><span class="line">127.0.0.1:6379&gt; set name yangl</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;yangl&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 <numreq> 请求</numreq></td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# src/redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">====== PING_INLINE ======</span><br><span class="line">  100000 requests completed in 1.37 seconds# 对10W个请求进行写入测试</span><br><span class="line">  100 parallel clients# 100个并发客户管</span><br><span class="line">  3 bytes payload# 每次写入3个字节</span><br><span class="line">  keep alive: 1# 只有一台服务器来处理这个请求，单机性能</span><br><span class="line"></span><br><span class="line">88.95% &lt;= 1 milliseconds</span><br><span class="line">97.47% &lt;= 2 milliseconds</span><br><span class="line">99.54% &lt;= 3 milliseconds</span><br><span class="line">99.88% &lt;= 4 milliseconds</span><br><span class="line">99.99% &lt;= 5 milliseconds</span><br><span class="line">100.00% &lt;= 5 milliseconds# 所有请求在 5 毫秒处理完成</span><br><span class="line">72992.70 requests per second# 每秒处理 72992.70 次请求</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2020/12/13/database/redis/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1611908215889.png" alt="1611908215889"></p><h2 id="key-操作"><a href="#key-操作" class="headerlink" title="key 操作"></a>key 操作</h2><blockquote><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p></blockquote><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-5.0.4]# src/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; keys *  # 查看当前数据库中所有的key</span><br><span class="line">1) &quot;foo&quot;</span><br><span class="line">2) &quot;key:__rand_int__&quot;</span><br><span class="line">3) &quot;mylist&quot;</span><br><span class="line">4) &quot;counter:__rand_int__&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; DBSIZE # 查看当前数据库的大小，与key数量相关</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; flushdb # 清空当前数据库中的键值对。</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set name yangl</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type name# 查看 name 的数据类型</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; set age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type age</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; move age 1# 将键值对移动到指定数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; EXISTS age # 判断键是否存在</span><br><span class="line">(integer) 0# 不存在</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1# 存在</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; SELECT 1# 切换数据库 DB 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; </span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; del age# 删除键值对</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; set age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; EXPIRE age 10# 设置键值对的过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; ttl age# 查看key的过期剩余时间</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379[1]&gt; ttl age</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[1]&gt; ttl age</span><br><span class="line">(integer) -2# -2 表示key过期，-1表示key未设置过期时间</span><br><span class="line">127.0.0.1:6379[1]&gt; get age# 过期的key 会被自动delete</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[1]&gt; </span><br><span class="line">127.0.0.1:6379[1]&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多命令参考：<a href="https://www.redis.net.cn/tutorial/3507.html">https://www.redis.net.cn/tutorial/3507.html</a></p><h1 id="5种最基本的数据类型"><a href="#5种最基本的数据类型" class="headerlink" title="5种最基本的数据类型"></a>5种最基本的数据类型</h1><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><h1 id="3种高级数据类型"><a href="#3种高级数据类型" class="headerlink" title="3种高级数据类型"></a>3种高级数据类型</h1><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h1 id="5-0最新版本数据类型"><a href="#5-0最新版本数据类型" class="headerlink" title="5.0最新版本数据类型"></a>5.0最新版本数据类型</h1><h1 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h1><p>参考：</p><p><a href="https://www.redis.net.cn/download/">https://www.redis.net.cn/download/</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
